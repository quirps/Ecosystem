{
  "address": "0x2A90CD9ef24120160968784C0442fD70A2A44cc1",
  "abi": [
    {
      "inputs": [],
      "name": "MigrationAlreadyCompleted",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MigrationAlreadyInitiated",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MigrationNotInitiated",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "eventId",
          "type": "uint256"
        }
      ],
      "name": "EventActivated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "eventId",
          "type": "uint256"
        }
      ],
      "name": "EventDeactivated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "eventId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "startTime",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "endTime",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "minEntries",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "maxEntries",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "imageUri",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "maxEntriesPerUser",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "enum LibEventFactory.EventStatus",
          "name": "status",
          "type": "uint8"
        }
      ],
      "name": "EventDetails",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "eventId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "addedTime",
          "type": "uint32"
        }
      ],
      "name": "EventExtended",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "eventId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "imageUri",
          "type": "string"
        }
      ],
      "name": "ImageUriUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "cancellor",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "timeCancelled",
          "type": "uint32"
        }
      ],
      "name": "MigrationCancelled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "initiatior",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "timeInitiatied",
          "type": "uint32"
        }
      ],
      "name": "MigrationInitiated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldOwner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "eventId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "merkleRoot",
          "type": "bytes32"
        }
      ],
      "name": "RefundsEnabled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "eventId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "ticketIds",
          "type": "uint256[]"
        }
      ],
      "name": "TicketDetails",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "eventId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "ticketIds",
          "type": "uint256[]"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        }
      ],
      "name": "TicketRedeemed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "eventId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "ticketId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "TicketRefunded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "ids",
          "type": "uint256[]"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "values",
          "type": "uint256[]"
        }
      ],
      "name": "TransferBatch",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "TransferSingle",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_startTime",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "_endTime",
          "type": "uint32"
        },
        {
          "internalType": "uint256",
          "name": "_minEntries",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_maxEntries",
          "type": "uint256"
        },
        {
          "internalType": "string",
          "name": "_imageUri",
          "type": "string"
        },
        {
          "internalType": "uint256[]",
          "name": "_ticketIds",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256",
          "name": "_maxEntriesPerUser",
          "type": "uint256"
        }
      ],
      "name": "createEvent",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "eventId",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "root",
          "type": "bytes32"
        }
      ],
      "name": "deactivateEvent",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "eventId",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "addedTime",
          "type": "uint32"
        }
      ],
      "name": "extendEvent",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "eventId",
          "type": "uint256"
        },
        {
          "internalType": "uint256[]",
          "name": "ticketIds",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        }
      ],
      "name": "redeemTickets",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "eventId",
          "type": "uint256"
        },
        {
          "internalType": "uint256[]",
          "name": "ticketIds",
          "type": "uint256[]"
        },
        {
          "internalType": "address",
          "name": "lowerBound",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "upperBound",
          "type": "address"
        },
        {
          "internalType": "bytes32[]",
          "name": "merkleProof",
          "type": "bytes32[]"
        }
      ],
      "name": "refundTicketsWithProof",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "eventId",
          "type": "uint256"
        },
        {
          "internalType": "string",
          "name": "imageUri",
          "type": "string"
        }
      ],
      "name": "setImageUri",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "eventId",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "root",
          "type": "bytes32"
        }
      ],
      "name": "setMerkleRoot",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x1166fc2dd324d8661e4f76d8aeed0b01a040e19497b14e6c31da8f402b2227a7",
  "receipt": {
    "to": null,
    "from": "0x1a47C1D6d5B47048536f1111C854e48fA9D76fdF",
    "contractAddress": "0x2A90CD9ef24120160968784C0442fD70A2A44cc1",
    "transactionIndex": 0,
    "gasUsed": "1775764",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x848fb6977cb8a2ce3dab772d76ddd38d393d79b3740a860f69757d590a261b2d",
    "transactionHash": "0x1166fc2dd324d8661e4f76d8aeed0b01a040e19497b14e6c31da8f402b2227a7",
    "logs": [],
    "blockNumber": 27,
    "cumulativeGasUsed": "1775764",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "54a7063fbd1377e55e2032f74c4aa199",
  "metadata": "{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"MigrationAlreadyCompleted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MigrationAlreadyInitiated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MigrationNotInitiated\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"}],\"name\":\"EventActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"}],\"name\":\"EventDeactivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"endTime\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minEntries\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxEntries\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"imageUri\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxEntriesPerUser\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum LibEventFactory.EventStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"EventDetails\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"addedTime\",\"type\":\"uint32\"}],\"name\":\"EventExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"imageUri\",\"type\":\"string\"}],\"name\":\"ImageUriUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cancellor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"timeCancelled\",\"type\":\"uint32\"}],\"name\":\"MigrationCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"initiatior\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"timeInitiatied\",\"type\":\"uint32\"}],\"name\":\"MigrationInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"RefundsEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ticketIds\",\"type\":\"uint256[]\"}],\"name\":\"TicketDetails\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ticketIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"TicketRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ticketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TicketRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_startTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_endTime\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_minEntries\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxEntries\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_imageUri\",\"type\":\"string\"},{\"internalType\":\"uint256[]\",\"name\":\"_ticketIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_maxEntriesPerUser\",\"type\":\"uint256\"}],\"name\":\"createEvent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"deactivateEvent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"addedTime\",\"type\":\"uint32\"}],\"name\":\"extendEvent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ticketIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"redeemTickets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ticketIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"lowerBound\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"upperBound\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"refundTicketsWithProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"imageUri\",\"type\":\"string\"}],\"name\":\"setImageUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"ApprovalForAll(address,address,bool)\":{\"details\":\"Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to `approved`.\"},\"EventActivated(uint256)\":{\"details\":\"Emitted when an event transitions from a pending state to an active state, which generally happens when the first ticket for the event is redeemed.\",\"params\":{\"eventId\":\"The unique identifier for the event.\"}},\"EventDeactivated(uint256)\":{\"details\":\"Emitted when an event is deactivated by the owner.\",\"params\":{\"eventId\":\"The unique identifier for the event.\"}},\"EventDetails(uint256,uint32,uint32,uint256,uint256,string,uint256,uint8)\":{\"details\":\"Emitted when a new event is created. Contains all the essential details regarding the event including its schedule and entry conditions.\",\"params\":{\"endTime\":\"The end time of the event, represented as a UNIX timestamp.\",\"eventId\":\"The unique identifier for the event.\",\"imageUri\":\"A URI pointing to the event's image resource.\",\"maxEntries\":\"The maximum number of entries allowed for the event.\",\"maxEntriesPerUser\":\"max entries a user can submit to event\",\"minEntries\":\"The minimum number of entries required for the event.\",\"startTime\":\"The start time of the event, represented as a UNIX timestamp.\",\"status\":\"The current status of the event.\"}},\"EventExtended(uint256,uint32)\":{\"details\":\"Emitted when an event's duration is extended\",\"params\":{\"addedTime\":\"Time added to the endTime property of the event\",\"eventId\":\"The unique identifier for the event.\"}},\"TicketDetails(uint256,uint256[])\":{\"details\":\"Emitted when ticket details for a specific event are defined or updated. Contains arrays of ticket IDs and their corresponding details.\",\"params\":{\"eventId\":\"The unique identifier for the event.\",\"ticketIds\":\"An array of unique identifiers for the tickets associated with the event.\"}},\"TicketRedeemed(uint256,uint256[],uint256[])\":{\"details\":\"Emitted when one or more tickets are redeemed for an event. Contains details of the ticket IDs and the respective amounts that have been redeemed.\",\"params\":{\"amounts\":\"An array of amounts representing the quantity redeemed for each corresponding ticket ID.\",\"eventId\":\"The unique identifier for the event.\",\"ticketIds\":\"An array of unique identifiers for the tickets that have been redeemed.\"}},\"TicketRefunded(uint256,uint256,uint256)\":{\"details\":\"Emitted when a ticket is refunded. This occurs after a successful call to the `refundTicketsWithProof` function, indicating that the refund was processed successfully.\",\"params\":{\"amount\":\"The amount that has been refunded for the particular ticket id.\",\"eventId\":\"The unique identifier for the event.\",\"ticketId\":\"The unique identifier for the ticket that has been refunded.\"}},\"TransferBatch(address,address,address,uint256[],uint256[])\":{\"details\":\"Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all transfers.\"},\"TransferSingle(address,address,address,uint256,uint256)\":{\"details\":\"Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\"}},\"kind\":\"dev\",\"methods\":{\"createEvent(uint32,uint32,uint256,uint256,string,uint256[],uint256)\":{\"details\":\"External function that allows for the creation of a new event\",\"params\":{\"_endTime\":\"The end time of the event\",\"_imageUri\":\"The URI for the event's image\",\"_maxEntries\":\"The maximum number of entries for the event\",\"_minEntries\":\"The minimum number of entries for the event\",\"_startTime\":\"The start time of the event\"},\"returns\":{\"_0\":\"The ID of the created event\"}},\"deactivateEvent(uint256,bytes32)\":{\"details\":\"Only callable by the owner or authorized addresses. Can be used to deactivate an event prematurely.\",\"params\":{\"eventId\":\"The ID of the event to deactivate.\",\"root\":\"Optionally, a new Merkle root to set. Pass bytes32(0) to not update the Merkle root.\"}},\"extendEvent(uint256,uint32)\":{\"details\":\"Only callable by the owner or authorized addresses. The event time extension should respect any set maximum limits.\",\"params\":{\"addedTime\":\"The additional time to add to the event's duration, in seconds.\",\"eventId\":\"The ID of the event to extend.\"}},\"redeemTickets(uint256,uint256[],uint256[])\":{\"details\":\"Batch process to redeem multiple tickets at once\",\"params\":{\"amounts\":\"The amounts corresponding to each ticket to be redeemed\",\"eventId\":\"The ID of the event\",\"ticketIds\":\"The IDs of the tickets to be redeemed\"}},\"refundTicketsWithProof(uint256,uint256[],address,address,bytes32[])\":{\"details\":\"Batch process to refund multiple tickets at once. We refund a user   if they can prove their addre\",\"params\":{\"eventId\":\"The ID of the event\",\"lowerBound\":\"Lower bound address \",\"merkleProof\":\"Lower bound address \",\"ticketIds\":\"The IDs of the tickets to be refunded\",\"upperBound\":\"upper bound address \"}},\"setImageUri(uint256,string)\":{\"details\":\"Only callable by the owner or authorized addresses.\",\"params\":{\"eventId\":\"The ID of the event to set the image URI for.\",\"imageUri\":\"The new image URI as a string.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"createEvent(uint32,uint32,uint256,uint256,string,uint256[],uint256)\":{\"notice\":\"Creates a new event\"},\"deactivateEvent(uint256,bytes32)\":{\"notice\":\"Deactivates the specified event and optionally updates the Merkle root.\"},\"extendEvent(uint256,uint32)\":{\"notice\":\"Extends the duration of the specified event by the added time.\"},\"redeemTickets(uint256,uint256[],uint256[])\":{\"notice\":\"Allows the redemption of multiple tickets for an event\"},\"refundTicketsWithProof(uint256,uint256[],address,address,bytes32[])\":{\"notice\":\"Allows the refund of tickets\"},\"setImageUri(uint256,string)\":{\"notice\":\"Sets a new image URI for the specified event.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/facets/Events/EventFactory.sol\":\"EventFactory\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/facets/ERC2771Recipient/LibERC2771Recipient.sol\":{\"content\":\"// LibEventStorage.sol\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n\\r\\nlibrary LibERC2771Recipient {\\r\\n    bytes32 constant STORAGE_POSITION = keccak256(\\\"diamond.storage.ERC2771Recipient\\\");\\r\\n\\r\\n   \\r\\n    struct ERC2771RecipientStorage {\\r\\n        address trustedForwarder;\\r\\n    }\\r\\n\\r\\n    function erc2771RecipientStorage() internal pure returns ( ERC2771RecipientStorage storage es) {\\r\\n        bytes32 position = STORAGE_POSITION;\\r\\n        assembly {\\r\\n            es.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n   function __getTrustedForwarder() internal  view returns (address trustedForwarder_){\\r\\n       ERC2771RecipientStorage storage es =  erc2771RecipientStorage();\\r\\n        trustedForwarder_ =  es.trustedForwarder;\\r\\n    }\\r\\n\\r\\n    function __setTrustedForwarder(address _forwarder) internal {\\r\\n        ERC2771RecipientStorage storage es =  erc2771RecipientStorage();\\r\\n        es.trustedForwarder = _forwarder; \\r\\n    }\\r\\n \\r\\n  \\r\\n    function _isTrustedForwarder(address forwarder) public  view returns(bool) {\\r\\n        ERC2771RecipientStorage storage es =  erc2771RecipientStorage();\\r\\n        return forwarder == es.trustedForwarder;\\r\\n    }\\r\\n \\r\\n    \\r\\n    function _msgSender() internal  view returns (address ret) {\\r\\n        if (msg.data.length >= 20 && _isTrustedForwarder(msg.sender)) {\\r\\n            // At this point we know that the sender is a trusted forwarder,\\r\\n            // so we trust that the last bytes of msg.data are the verified sender address.\\r\\n            // extract sender address from the end of msg.data\\r\\n            assembly {\\r\\n                ret := shr(96,calldataload(sub(calldatasize(),20)))\\r\\n            }\\r\\n        } else {\\r\\n            ret = msg.sender;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \\r\\n    function _msgData() internal  view returns (bytes calldata ret) {\\r\\n        if (msg.data.length >= 20 && _isTrustedForwarder(msg.sender)) {\\r\\n            return msg.data[0:msg.data.length-20];\\r\\n        } else {\\r\\n            return msg.data;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x6ff10e2f12c8a61f2ae6ff642711976888a210d309d0e03885193162664330cb\"},\"contracts/facets/ERC2771Recipient/_ERC2771Recipient.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// solhint-disable no-inline-assembly\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\n\\r\\n\\r\\nimport { LibERC2771Recipient } from \\\"./LibERC2771Recipient.sol\\\";  \\r\\n/**\\r\\n * @title The ERC-2771 Recipient Base Abstract Class - Implementation\\r\\n *\\r\\n * @notice Note that this contract was called `BaseRelayRecipient` in the previous revision of the GSN.\\r\\n *\\r\\n * @notice A base contract to be inherited by any contract that want to receive relayed transactions.\\r\\n *\\r\\n * @notice A subclass must use `_msgSender()` instead of `msg.sender`.\\r\\n */\\r\\ncontract iERC2771Recipient {\\r\\n \\r\\n    /*\\r\\n     * Forwarder singleton we accept calls from\\r\\n     */\\r\\n     \\r\\n    \\r\\n\\r\\n    function _getTrustedForwarder() internal  view returns (address forwarder){\\r\\n        return LibERC2771Recipient.__getTrustedForwarder();\\r\\n    }\\r\\n\\r\\n    function _setTrustedForwarder(address _forwarder) internal {\\r\\n        LibERC2771Recipient.__setTrustedForwarder(_forwarder); \\r\\n    }\\r\\n  \\r\\n  \\r\\n    function _isTrustedForwarder(address forwarder) internal  view returns(bool) {\\r\\n        return LibERC2771Recipient._isTrustedForwarder(forwarder);\\r\\n    } \\r\\n\\r\\n    \\r\\n    function msgSender() internal  view returns (address ret_) {\\r\\n        ret_ = LibERC2771Recipient._msgSender();\\r\\n    }\\r\\n    \\r\\n    function msgData() internal  view returns (bytes calldata ret_) {\\r\\n        ret_ = LibERC2771Recipient._msgData();\\r\\n    }\\r\\n}\",\"keccak256\":\"0x0a097bedc1831e582bf1b64b8406b71a3441ed6f9d09b12874821b94d3ce9a88\",\"license\":\"MIT\"},\"contracts/facets/Events/EventFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./_EventFactory.sol\\\";\\r\\nimport \\\"./IEventFactory.sol\\\";\\r\\nimport \\\"./LibEventFactory.sol\\\"; \\r\\nimport { LibOwnership } from \\\"../Ownership/LibOwnership.sol\\\";\\r\\n \\r\\ncontract EventFactory is IEventFactory, iEventFactory { \\r\\n     function setMerkleRoot(uint256 eventId, bytes32 root) external onlyOwner {\\r\\n        _setMerkleRoot(eventId, root);\\r\\n    }\\r\\n    function setImageUri(uint256 eventId, string memory imageUri) external onlyOwner {\\r\\n        _setImageUri(eventId, imageUri);\\r\\n    }\\r\\n    function createEvent(\\r\\n        uint32 _startTime,\\r\\n        uint32 _endTime,\\r\\n        uint256 _minEntries,\\r\\n        uint256 _maxEntries,\\r\\n        string calldata _imageUri, \\r\\n        uint256[] memory _ticketIds,\\r\\n        uint256 _maxEntriesPerUser\\r\\n    ) external returns (uint256) {\\r\\n         isEcosystemOwnerVerification();\\r\\n       return _createEvent(_startTime, _endTime, _minEntries, _maxEntries, _imageUri, _ticketIds, _maxEntriesPerUser);\\r\\n    }\\r\\n     function deactivateEvent(uint256 eventId, bytes32 root) external {\\r\\n        isEcosystemOwnerVerification();\\r\\n        _deactivateEvent(eventId, root);\\r\\n     }\\r\\n\\r\\n    function extendEvent(uint256 eventId, uint32 addedTime) external {\\r\\n         isEcosystemOwnerVerification();\\r\\n        _extendEvent(eventId, addedTime);\\r\\n    }\\r\\n\\r\\n    function redeemTickets(uint256 eventId, uint256[] calldata ticketIds, uint256[] calldata amounts) external {\\r\\n        _redeemTickets(eventId, ticketIds, amounts);\\r\\n    }\\r\\n\\r\\n\\r\\n    function refundTicketsWithProof(\\r\\n        uint256 eventId, \\r\\n        uint256[] memory ticketIds, \\r\\n        address lowerBound, \\r\\n        address upperBound, \\r\\n        bytes32[] calldata merkleProof\\r\\n    ) external  {\\r\\n        _refundTicketsWithProof(eventId, ticketIds, lowerBound, upperBound, merkleProof);\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n    facet per event architecture. \\r\\n    Would need to generate a new interface object, check for collisions,\\r\\n    clean up when done (can't pollute 2^32 too much)\\r\\n */\",\"keccak256\":\"0xa268127d232b0e3d41c7f5e7be654f8ea466850a4b30d00bee0838eced346ac2\",\"license\":\"MIT\"},\"contracts/facets/Events/IEventFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {LibEventFactory} from \\\"./LibEventFactory.sol\\\"; \\r\\n/// @title IEventFacet\\r\\n/// @dev Interface for the event management facet\\r\\ninterface IEventFactory {\\r\\n    /// @notice Sets the Merkle root for the specified event.\\r\\n    /// @dev Only callable by the owner or authorized addresses.\\r\\n    /// @param eventId The ID of the event to set the Merkle root for.\\r\\n    /// @param merkleRoot The new Merkle root.\\r\\n    function setMerkleRoot(uint256 eventId, bytes32 merkleRoot) external;\\r\\n\\r\\n    /// @notice Sets a new image URI for the specified event.\\r\\n    /// @dev Only callable by the owner or authorized addresses.\\r\\n    /// @param eventId The ID of the event to set the image URI for.\\r\\n    /// @param imageUri The new image URI as a string.\\r\\n    function setImageUri(uint256 eventId, string memory imageUri) external;\\r\\n\\r\\n    /// @notice Deactivates the specified event and optionally updates the Merkle root.\\r\\n    /// @dev Only callable by the owner or authorized addresses. Can be used to deactivate an event prematurely.\\r\\n    /// @param eventId The ID of the event to deactivate.\\r\\n    /// @param root Optionally, a new Merkle root to set. Pass bytes32(0) to not update the Merkle root.\\r\\n    function deactivateEvent(uint256 eventId, bytes32 root) external;\\r\\n\\r\\n    /// @notice Extends the duration of the specified event by the added time.\\r\\n    /// @dev Only callable by the owner or authorized addresses. The event time extension should respect any set maximum limits.\\r\\n    /// @param eventId The ID of the event to extend.\\r\\n    /// @param addedTime The additional time to add to the event's duration, in seconds.\\r\\n    function extendEvent(uint256 eventId, uint32 addedTime) external;\\r\\n\\r\\n    /// @notice Creates a new event\\r\\n    /// @dev External function that allows for the creation of a new event\\r\\n    /// @param _startTime The start time of the event\\r\\n    /// @param _endTime The end time of the event\\r\\n    /// @param _minEntries The minimum number of entries for the event\\r\\n    /// @param _maxEntries The maximum number of entries for the event\\r\\n    /// @param _imageUri The URI for the event's image\\r\\n    /// @return The ID of the created event\\r\\n    function createEvent(\\r\\n        uint32 _startTime,\\r\\n        uint32 _endTime,\\r\\n        uint256 _minEntries,\\r\\n        uint256 _maxEntries,\\r\\n        string calldata _imageUri, \\r\\n        uint256[] memory _ticketIds,\\r\\n        uint256 _maxEntriesPerUser\\r\\n    ) external returns (uint256);\\r\\n\\r\\n    /// @notice Allows the redemption of multiple tickets for an event\\r\\n    /// @dev Batch process to redeem multiple tickets at once\\r\\n    /// @param eventId The ID of the event\\r\\n    /// @param ticketIds The IDs of the tickets to be redeemed\\r\\n    /// @param amounts The amounts corresponding to each ticket to be redeemed\\r\\n    function redeemTickets(uint256 eventId, uint256[] calldata ticketIds, uint256[] calldata amounts) external;\\r\\n\\r\\n    /// @notice Allows the refund of tickets\\r\\n    /// @dev Batch process to refund multiple tickets at once. We refund a user\\r\\n          ///   if they can prove their addre\\r\\n    /// @param eventId The ID of the event\\r\\n    /// @param ticketIds The IDs of the tickets to be refunded\\r\\n    /// @param lowerBound Lower bound address \\r\\n    /// @param upperBound upper bound address \\r\\n    /// @param merkleProof Lower bound address \\r\\n\\r\\n    function refundTicketsWithProof(uint256 eventId, uint256[] calldata ticketIds, address lowerBound, \\r\\n        address upperBound, \\r\\n        bytes32[] calldata merkleProof) external;\\r\\n}\\r\\n\",\"keccak256\":\"0xd88519cd120f556f0fbe3065dd72d29ca2650f6c39a2247593da79fab3ff364d\",\"license\":\"MIT\"},\"contracts/facets/Events/LibEventFactory.sol\":{\"content\":\"// LibEventStorage.sol\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../Tokens/ERC1155/interfaces/IERC1155Transfer.sol\\\";  \\r\\n\\r\\nlibrary LibEventFactory {\\r\\n    bytes32 constant STORAGE_POSITION = keccak256(\\\"diamond.storage.EventFactory\\\");\\r\\n\\r\\n    struct TicketDetail {\\r\\n        uint256 minAmount;\\r\\n        uint256 maxAmount;\\r\\n    }\\r\\n\\r\\n    enum EventStatus {\\r\\n        Pending,\\r\\n        Active,\\r\\n        Deactivated,\\r\\n        Completed\\r\\n    }\\r\\n\\r\\n    struct EventDetail {\\r\\n        uint32 startTime;\\r\\n        uint32 endTime;\\r\\n        uint256 minEntries;\\r\\n        uint256 maxEntries;\\r\\n        uint256 currentEntries;\\r\\n        string imageUri;\\r\\n        EventStatus status;\\r\\n        bytes32 merkleRoot;\\r\\n        mapping(uint256 => TicketDetail) ticketDetails;\\r\\n        mapping(address => mapping(uint256 => uint256)) ticketsRedeemed;\\r\\n    }\\r\\n\\r\\n    struct EventStorage {\\r\\n        address owner;\\r\\n        IERC1155Transfer tokenContract;\\r\\n        mapping(uint256 => EventDetail) events;\\r\\n    }\\r\\n\\r\\n    function eventStorage() internal pure returns (EventStorage storage es) {\\r\\n        bytes32 position = STORAGE_POSITION;\\r\\n        assembly {\\r\\n            es.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getEventDetail(uint256 eventId) internal view returns (EventDetail storage) {\\r\\n        EventStorage storage es = eventStorage();\\r\\n        require(es.events[eventId].startTime != 0, \\\"Event does not exist\\\");\\r\\n        return es.events[eventId];\\r\\n    }\\r\\n\\r\\n    function getTicketDetail(uint256 eventId, uint256 ticketId) internal view returns (TicketDetail storage) {\\r\\n        return getEventDetail(eventId).ticketDetails[ticketId];\\r\\n    }\\r\\n\\r\\n    function getRedeemedTickets(uint256 eventId, address user, uint256[] memory ticketId) internal view returns (uint256[] memory) {\\r\\n        uint256[] memory redeemedTickets = new uint256[](ticketId.length);\\r\\n        for (uint256 i; i < ticketId.length; i++) {\\r\\n            redeemedTickets[i] = getEventDetail(eventId).ticketsRedeemed[user][ticketId[i]];\\r\\n        }\\r\\n        return redeemedTickets;\\r\\n    }\\r\\n\\r\\n    function getMerkleRoot(uint256 eventId) internal view returns (bytes32) {\\r\\n        return getEventDetail(eventId).merkleRoot;\\r\\n    }\\r\\n\\r\\n    function getEventTimes(uint256 eventId) internal view returns (uint32 startTime, uint32 endTime) {\\r\\n        EventDetail storage es = getEventDetail(eventId);\\r\\n        return (es.startTime, es.endTime);\\r\\n    }\\r\\n\\r\\n    function getEventEntries(uint256 eventId) internal view returns (uint256 minEntries, uint256 maxEntries, uint256 currentEntries) {\\r\\n        EventDetail storage es = getEventDetail(eventId);\\r\\n        return (es.minEntries, es.maxEntries, es.currentEntries);\\r\\n    }\\r\\n\\r\\n    function getEventImageUri(uint256 eventId) internal view returns (string memory) {\\r\\n        EventDetail storage es = getEventDetail(eventId);\\r\\n        return es.imageUri; \\r\\n    }\\r\\n\\r\\n    function getEventStatus(uint256 eventId) internal view returns (EventStatus) {\\r\\n        EventDetail storage es = getEventDetail(eventId);\\r\\n        return es.status;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x66bf6c44bc8def94e42e6f1542f6c83d2ac0691bcaaa0203de4fe1ee70fd73c3\"},\"contracts/facets/Events/_EventFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./LibEventFactory.sol\\\"; \\r\\nimport \\\"../../libraries/utils/MerkleProof.sol\\\"; \\r\\nimport \\\"../Tokens/ERC1155/interfaces/IERC1155Transfer.sol\\\";\\r\\nimport \\\"../Ownership/_Ownership.sol\\\"; \\r\\nimport {LibOwnership} from \\\"../Ownership/LibOwnership.sol\\\";\\r\\nimport \\\"../Tokens/ERC1155/internals/iERC1155Transfer.sol\\\"; \\r\\nimport \\\"hardhat/console.sol\\\";\\r\\n\\r\\ncontract iEventFactory is iOwnership, iERC1155Transfer { \\r\\n\\r\\n    /// @dev Emitted when an event is deactivated by the owner.\\r\\n    /// @param eventId The unique identifier for the event.\\r\\n    event EventDeactivated(uint256 eventId);\\r\\n\\r\\n    /// @dev Emitted when an event transitions from a pending state to an active state, which generally happens when the first ticket for the event is redeemed.\\r\\n    /// @param eventId The unique identifier for the event.\\r\\n    event EventActivated(uint256 eventId);\\r\\n\\r\\n    /// @dev Emitted when one or more tickets are redeemed for an event. Contains details of the ticket IDs and the respective amounts that have been redeemed.\\r\\n    /// @param eventId The unique identifier for the event.\\r\\n    /// @param ticketIds An array of unique identifiers for the tickets that have been redeemed.\\r\\n    /// @param amounts An array of amounts representing the quantity redeemed for each corresponding ticket ID.\\r\\n    event TicketRedeemed(uint256 eventId, uint256[] ticketIds, uint256[] amounts);\\r\\n\\r\\n    /// @dev Emitted when a ticket is refunded. This occurs after a successful call to the `refundTicketsWithProof` function, indicating that the refund was processed successfully.\\r\\n    /// @param eventId The unique identifier for the event.\\r\\n    /// @param ticketId The unique identifier for the ticket that has been refunded.\\r\\n    /// @param amount The amount that has been refunded for the particular ticket id.\\r\\n    event TicketRefunded(uint256 eventId, uint256 ticketId, uint256 amount);\\r\\n\\r\\n    /// @dev Emitted when a new event is created. Contains all the essential details regarding the event including its schedule and entry conditions.\\r\\n    /// @param eventId The unique identifier for the event.\\r\\n    /// @param startTime The start time of the event, represented as a UNIX timestamp.\\r\\n    /// @param endTime The end time of the event, represented as a UNIX timestamp.\\r\\n    /// @param minEntries The minimum number of entries required for the event.\\r\\n    /// @param maxEntries The maximum number of entries allowed for the event.\\r\\n    /// @param imageUri A URI pointing to the event's image resource.\\r\\n    /// @param maxEntriesPerUser max entries a user can submit to event\\r\\n    /// @param status The current status of the event.\\r\\n    event EventDetails(\\r\\n        uint256 eventId,\\r\\n        uint32 startTime,\\r\\n        uint32 endTime,\\r\\n        uint256 minEntries,\\r\\n        uint256 maxEntries,\\r\\n        string imageUri,\\r\\n        uint256 maxEntriesPerUser,\\r\\n        LibEventFactory.EventStatus status\\r\\n    );\\r\\n\\r\\n    /// @dev Emitted when ticket details for a specific event are defined or updated. Contains arrays of ticket IDs and their corresponding details.\\r\\n    /// @param eventId The unique identifier for the event.\\r\\n    /// @param ticketIds An array of unique identifiers for the tickets associated with the event.\\r\\n    event TicketDetails(uint256 eventId, uint256[] ticketIds);\\r\\n    /**\\r\\n     * @dev Emitted when an event's duration is extended\\r\\n     * @param eventId The unique identifier for the event.\\r\\n     * @param addedTime Time added to the endTime property of the event\\r\\n     */\\r\\n    event EventExtended(uint256 eventId, uint32 addedTime);\\r\\n\\r\\n    event ImageUriUpdated(uint256 eventId, string imageUri);\\r\\n    event RefundsEnabled(uint256 eventId, bytes32 merkleRoot);\\r\\n\\r\\n \\r\\n\\r\\n    function _extendEvent(uint256 eventId, uint32 addedTime) internal {\\r\\n        LibEventFactory.EventDetail storage eventDetail = LibEventFactory.getEventDetail(eventId);\\r\\n        eventDetail.endTime += addedTime;\\r\\n        emit EventExtended(eventId, addedTime);\\r\\n    }\\r\\n\\r\\n    function _deactivateEvent(uint256 eventId, bytes32 root) internal  {\\r\\n        \\r\\n        LibEventFactory.EventDetail storage eventDetail = LibEventFactory.getEventDetail(eventId);\\r\\n\\r\\n        require(\\r\\n            eventDetail.status == LibEventFactory.EventStatus.Active || eventDetail.status == LibEventFactory.EventStatus.Pending,\\r\\n            \\\"Event has already terminated\\\"\\r\\n        );\\r\\n\\r\\n        eventDetail.status = LibEventFactory.EventStatus.Deactivated;\\r\\n        emit EventDeactivated(eventId);\\r\\n\\r\\n        if (root != bytes32(0)) {\\r\\n            eventDetail.merkleRoot = root;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _setMerkleRoot(uint256 eventId, bytes32 root) internal {\\r\\n        LibEventFactory.EventDetail storage eventDetail = LibEventFactory.getEventDetail(eventId);\\r\\n        LibEventFactory.EventStatus _eventStatus = eventDetail.status;\\r\\n        require(\\r\\n            _eventStatus == LibEventFactory.EventStatus.Deactivated || _eventStatus == LibEventFactory.EventStatus.Completed,\\r\\n            \\\"Event must be finished.\\\"\\r\\n        );\\r\\n\\r\\n        bytes32 _merkleRoot = eventDetail.merkleRoot;\\r\\n        require(_merkleRoot == bytes32(0), \\\"Merkle root has already been set for this event.\\\");\\r\\n        eventDetail.merkleRoot = root;\\r\\n        emit RefundsEnabled(eventId, _merkleRoot);\\r\\n    }\\r\\n\\r\\n    function _setImageUri(uint256 eventId, string memory imageUri) internal {\\r\\n        LibEventFactory.EventDetail storage eventDetail = LibEventFactory.getEventDetail(eventId);\\r\\n        require(eventDetail.endTime != 0, \\\"Event does not exist\\\");\\r\\n        eventDetail.imageUri = imageUri;\\r\\n        emit ImageUriUpdated(eventId, imageUri);\\r\\n    }\\r\\n\\r\\n    // Additional functions such as `_redeemTickets`, `_refundTicketsWithProof`, and `_createEvent` would be implemented here following the existing logic, but leveraging the `LibEventFactory` library to interact with storage.\\r\\n\\r\\n    // Assuming the necessary imports and library setup are done at the top of your file\\r\\n\\r\\n    function _createEvent(\\r\\n        uint32 _startTime,\\r\\n        uint32 _endTime,\\r\\n        uint256 _minEntries,\\r\\n        uint256 _maxEntries,\\r\\n        string memory _imageUri,\\r\\n        uint256[] memory _ticketIds,\\r\\n        uint256 _maxEntriesPerUser\\r\\n    ) internal returns (uint256) {\\r\\n        LibEventFactory.EventStorage storage es = LibEventFactory.eventStorage();\\r\\n\\r\\n        require(_endTime > block.timestamp - 1, \\\"Must be non-trivial event time window\\\");\\r\\n        require(_maxEntries > 0,\\\"Must have non-trivial entrant amount\\\");\\r\\n        uint256 eventId = uint256(keccak256(abi.encodePacked(_startTime, _endTime, _minEntries, _maxEntries, _imageUri, block.timestamp)));\\r\\n        require(es.events[eventId].endTime == 0, \\\"Event must not exist\\\");\\r\\n        LibEventFactory.EventDetail storage newEvent = es.events[eventId];\\r\\n        newEvent.startTime = _startTime;\\r\\n        newEvent.endTime = _endTime;\\r\\n        newEvent.minEntries = _minEntries;\\r\\n        newEvent.maxEntries = _maxEntries;\\r\\n        newEvent.imageUri = _imageUri;\\r\\n        newEvent.status = uint32(block.timestamp) < _startTime\\r\\n            ? LibEventFactory.EventStatus.Pending\\r\\n            : LibEventFactory.EventStatus.Active;\\r\\n\\r\\n        emit EventDetails(eventId, _startTime, _endTime, _minEntries, _maxEntries, _imageUri, _maxEntriesPerUser, newEvent.status);\\r\\n\\r\\n        emit TicketDetails(eventId, _ticketIds);\\r\\n\\r\\n        return eventId;\\r\\n    }\\r\\n\\r\\n    function _redeemTickets(uint256 eventId, uint256[] memory ticketIds, uint256[] memory amounts) internal {\\r\\n        LibEventFactory.EventDetail storage eventDetail = LibEventFactory.getEventDetail(eventId);\\r\\n        LibEventFactory.EventStatus _status = eventDetail.status;\\r\\n\\r\\n        require(block.timestamp >= eventDetail.startTime && block.timestamp <= eventDetail.endTime, \\\"Event not active\\\");\\r\\n        require(ticketIds.length == amounts.length, \\\"Mismatched ticketIds and amounts lengths\\\");\\r\\n\\r\\n        if (_status == LibEventFactory.EventStatus.Pending) {\\r\\n            eventDetail.status = LibEventFactory.EventStatus.Active;\\r\\n            emit EventActivated(eventId);\\r\\n        }\\r\\n\\r\\n        for (uint i = 0; i < ticketIds.length; i++) {\\r\\n            LibEventFactory.TicketDetail storage ticketDetail = LibEventFactory.getTicketDetail(eventId, ticketIds[i]);\\r\\n            require(eventDetail.currentEntries + 1 <= eventDetail.maxEntries, \\\"Exceeding max entries\\\");\\r\\n            require(amounts[i] >= ticketDetail.minAmount && amounts[i] <= ticketDetail.maxAmount, \\\"Invalid ticket amount\\\");\\r\\n            console.log(\\\"address(this)\\\");\\r\\n            console.log(address(this));\\r\\n            // Transfer ERC1155 tokens from user to contract\\r\\n            _safeTransferFrom(msgSender(), address(this), ticketIds[i], amounts[i], \\\"\\\");\\r\\n\\r\\n            // Update event and ticket details\\r\\n            eventDetail.currentEntries += 1;\\r\\n            eventDetail.ticketsRedeemed[msgSender()][ticketIds[i]] += amounts[i];\\r\\n        }\\r\\n        emit TicketRedeemed(eventId, ticketIds, amounts);\\r\\n    }\\r\\n\\r\\n    function _refundTicketsWithProof(\\r\\n        uint256 eventId,\\r\\n        uint256[] memory ticketIds,\\r\\n        address lowerBound,\\r\\n        address upperBound,\\r\\n        bytes32[] calldata merkleProof\\r\\n    ) internal {\\r\\n        LibEventFactory.EventDetail storage eventDetail = LibEventFactory.getEventDetail(eventId);\\r\\n\\r\\n        require(validateNonInclusion(eventId, lowerBound, upperBound, merkleProof), \\\"Proof was invalid\\\");\\r\\n\\r\\n        for (uint i = 0; i < ticketIds.length; i++) {\\r\\n            uint256 amountToRefund = eventDetail.ticketsRedeemed[msgSender()][ticketIds[i]];\\r\\n            require(amountToRefund > 0, \\\"No tickets to refund for this ID\\\");\\r\\n\\r\\n            // Update event details before transfer to ensure state consistency\\r\\n            eventDetail.currentEntries -= 1;\\r\\n            eventDetail.ticketsRedeemed[msgSender()][ticketIds[i]] = 0;\\r\\n            // Transfer ERC1155 tokens back to the user\\r\\n            _safeTransferFrom(address(this), msgSender(), ticketIds[i], amountToRefund, \\\"\\\");\\r\\n            emit TicketRefunded(eventId, ticketIds[i], amountToRefund);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function validateNonInclusion(\\r\\n        uint256 eventId,\\r\\n        address lowerBound,\\r\\n        address upperBound,\\r\\n        bytes32[] calldata merkleProof\\r\\n    ) internal view returns (bool) {\\r\\n        LibEventFactory.EventDetail storage eventDetail = LibEventFactory.getEventDetail(eventId);\\r\\n\\r\\n        // Ensure sender is within bounds\\r\\n        require(\\r\\n            uint160(lowerBound) < uint160(msgSender()) && uint160(msgSender()) < uint160(upperBound),\\r\\n            \\\"Sender is not within the exclusive bounds\\\"\\r\\n        );\\r\\n\\r\\n        // Verify non-inclusion by proving\\r\\n        bytes32 leaf= keccak256(bytes.concat(keccak256(abi.encode(lowerBound, upperBound))));\\r\\n        // bytes32 leaf = keccak256(abi.encodePacked(lowerBound, upperBound));\\r\\n        return MerkleProof.verify(merkleProof, eventDetail.merkleRoot, leaf);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x53978276a42a228524b44f0afb57940b7bdc785a8a9ec2fa8d560ed502c357d9\",\"license\":\"MIT\"},\"contracts/facets/Ownership/LibOwnership.sol\":{\"content\":\"pragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n\\r\\nlibrary LibOwnership {\\r\\nbytes32 constant OWNERSHIP_STORAGE_POSITION = keccak256(\\\"diamond.ownership.storage\\\");\\r\\nuint24 constant MIGRATION_TRANSITION_LOCK_TIMESPAN = 259200; // 3 days\\r\\n\\r\\nstruct OwnershipStorage{\\r\\n    address ecosystemOwner;\\r\\n    address registry;\\r\\n    Migration migration;\\r\\n}\\r\\nstruct Migration{\\r\\n    bool isMigrating;\\r\\n    uint32 initiationTimestamp;\\r\\n}\\r\\n\\r\\nfunction ownershipStorage() internal pure returns (OwnershipStorage storage os) {\\r\\n        bytes32 position = OWNERSHIP_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            os.slot := position \\r\\n        }\\r\\n    }\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n        Should never be used outside of iOwnership.sol (exception for the initial diamond constructor)\\r\\n        @notice Sets the owner of this ecosystem\\r\\n        @param _newEcosystemOwner  new ecosystem owner \\r\\n     */\\r\\n    function _setEcosystemOwner(address _newEcosystemOwner) internal {\\r\\n        OwnershipStorage storage os = ownershipStorage();\\r\\n        address previousOwner = os.ecosystemOwner;\\r\\n        os.ecosystemOwner = _newEcosystemOwner;\\r\\n        emit OwnershipTransferred(previousOwner, _newEcosystemOwner);\\r\\n    }\\r\\n\\r\\n    function _ecosystemOwner() internal view returns (address ecosystemOwner_) {\\r\\n        ecosystemOwner_ = ownershipStorage().ecosystemOwner;\\r\\n    }\\r\\n\\r\\n    function _setRegistry(address _registry) internal {\\r\\n        OwnershipStorage storage os = ownershipStorage();\\r\\n        os.registry = _registry;\\r\\n    }\\r\\n    function _getRegistry() internal view returns (address registry_) {\\r\\n        OwnershipStorage storage os = ownershipStorage();\\r\\n        registry_ = os.registry;\\r\\n    }\\r\\n    \\r\\n    \\r\\n} \",\"keccak256\":\"0x424fd62131dbaccfa06ef6f6deb4e1ef1d75db9d9e0908c864faff0e1d52099e\"},\"contracts/facets/Ownership/_Ownership.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {LibOwnership} from \\\"./LibOwnership.sol\\\";\\r\\nimport {iERC2771Recipient} from \\\"../ERC2771Recipient/_ERC2771Recipient.sol\\\";     \\r\\n\\r\\ncontract iOwnership is iERC2771Recipient {\\r\\n    error MigrationAlreadyInitiated();\\r\\n    error MigrationAlreadyCompleted();\\r\\n    error MigrationNotInitiated();\\r\\n\\r\\n    event MigrationInitiated(address initiatior, uint32 timeInitiatied);\\r\\n    event MigrationCancelled(address cancellor, uint32 timeCancelled);\\r\\n    event OwnershipChanged(address oldOwner, address newOwner); \\r\\n    modifier onlyOwner(){\\r\\n        msgSender() == _ecosystemOwner();\\r\\n        _;\\r\\n    }\\r\\n    function _setEcosystemOwner( address _newOwner) internal {\\r\\n        isEcosystemOwnerVerification();\\r\\n        LibOwnership._setEcosystemOwner(_newOwner);\\r\\n    }\\r\\n\\r\\n    function _ecosystemOwner() internal view returns (address owner_) {\\r\\n        owner_ = LibOwnership._ecosystemOwner();\\r\\n    }\\r\\n\\r\\n    function isEcosystemOwnerVerification() internal view {\\r\\n        require( msgSender() == _ecosystemOwner(), \\\"Must be the Ecosystem owner\\\"); \\r\\n    }\\r\\n    \\r\\n\\r\\n    //Migration related methods\\r\\n\\r\\n    /**\\r\\n     * @dev sole purpose is to restrict user from having access to ecosystem modularity\\r\\n     * until they initiate a migration. only modular changes are done via registry until\\r\\n     * then. \\r\\n     */\\r\\n    function isEffectiveOwner() internal view {\\r\\n        LibOwnership.OwnershipStorage storage os = LibOwnership.ownershipStorage();\\r\\n        LibOwnership.Migration storage _migration = os.migration;\\r\\n        if( _migration.isMigrating && isMigrationPeriodOver( _migration.initiationTimestamp ) ){\\r\\n            require( msgSender() == os.ecosystemOwner, \\\"Sender must be the owner.\\\");\\r\\n        }\\r\\n        else{\\r\\n            require(msgSender() == os.registry, \\\"Sender must be from the registry.\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \\r\\n    /**\\r\\n     * @dev start the migration \\r\\n     */\\r\\n    function _initiateMigration() internal {\\r\\n        LibOwnership.OwnershipStorage storage os = LibOwnership.ownershipStorage();\\r\\n        LibOwnership.Migration storage _migration = os.migration;\\r\\n        if( _migration.isMigrating ){\\r\\n            revert MigrationAlreadyInitiated();\\r\\n        }\\r\\n        else{\\r\\n            _migration.isMigrating = true;\\r\\n            _migration.initiationTimestamp = uint32(block.timestamp);\\r\\n            emit MigrationInitiated(msgSender(), uint32(block.timestamp) );\\r\\n        } \\r\\n    }\\r\\n    function _cancelMigration() internal {\\r\\n        LibOwnership.OwnershipStorage storage os = LibOwnership.ownershipStorage();\\r\\n        LibOwnership.Migration storage _migration = os.migration;\\r\\n        uint32 _initiationTimestamp = _migration.initiationTimestamp;\\r\\n        if( _migration.isMigrating  ) {\\r\\n            if(isMigrationPeriodOver( _initiationTimestamp )){\\r\\n                revert MigrationAlreadyCompleted();\\r\\n            }\\r\\n            else{\\r\\n                _migration.isMigrating = false;\\r\\n                emit MigrationCancelled(msgSender(), uint32(block.timestamp));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            revert MigrationNotInitiated();\\r\\n        }\\r\\n        \\r\\n    }\\r\\n    function isMigrationPeriodOver( uint32 _initiationTimestamp ) internal view returns (bool isOver_){\\r\\n        isOver_ = uint32(block.timestamp) + LibOwnership.MIGRATION_TRANSITION_LOCK_TIMESPAN > _initiationTimestamp;\\r\\n    }\\r\\n}\\r\\n \",\"keccak256\":\"0x3fa7c0716afb600bfa154cef5596f51bb7a707b1d394648498ff24e35731f0ba\",\"license\":\"MIT\"},\"contracts/facets/Tokens/ERC1155/interfaces/IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev _Available since v3.1._\\r\\n */\\r\\ninterface IERC1155Receiver  {\\r\\n    /**\\r\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\r\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\r\\n     *\\r\\n     * NOTE: To accept the transfer, this must return\\r\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\r\\n     * (i.e. 0xf23a6e61, or its own function selector).\\r\\n     *\\r\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\r\\n     * @param from The address which previously owned the token\\r\\n     * @param id The ID of the token being transferred\\r\\n     * @param value The amount of tokens being transferred\\r\\n     * @param data Additional data with no specified format\\r\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\r\\n     */\\r\\n    function onERC1155Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 id,\\r\\n        uint256 value,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n\\r\\n    /**\\r\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\r\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\r\\n     * been updated.\\r\\n     *\\r\\n     * NOTE: To accept the transfer(s), this must return\\r\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\r\\n     * (i.e. 0xbc197c81, or its own function selector).\\r\\n     *\\r\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\r\\n     * @param from The address which previously owned the token\\r\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\r\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\r\\n     * @param data Additional data with no specified format\\r\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\r\\n     */\\r\\n    function onERC1155BatchReceived(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata values,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n}\\r\\n\",\"keccak256\":\"0x903479627911c42b944018e3af01eecab68fbc134c6002f8fdc21d1626abf762\",\"license\":\"MIT\"},\"contracts/facets/Tokens/ERC1155/interfaces/IERC1155Transfer.sol\":{\"content\":\"pragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\ninterface IERC1155Transfer{\\r\\n\\r\\n\\r\\n /**\\r\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\r\\n     *\\r\\n     * Emits a {TransferSingle} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\r\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\r\\n    \\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\r\\n     *\\r\\n     * Emits a {TransferBatch} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `ids` and `amounts` must have the same length.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata amounts,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n      /**\\r\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `operator` cannot be the caller.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\r\\n     *\\r\\n     * See {setApprovalForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\r\\n\\r\\n}\",\"keccak256\":\"0x1fba6f123b029993faac5769a036f58dd1ea79ce27136031aa2f366e982b0737\"},\"contracts/facets/Tokens/ERC1155/internals/iERC1155ContractTransfer.sol\":{\"content\":\"pragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../interfaces/IERC1155Receiver.sol\\\";\\r\\nimport \\\"../../../../libraries/utils/Address.sol\\\";\\r\\nimport \\\"./iERC1155Receiver.sol\\\";\\r\\n\\r\\n//Safety check for transfers to contracts\\r\\ncontract iERC1155ContractTransfer is iERC1155Receiver {\\r\\n    \\r\\n    using Address for address;\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\r\\n     */\\r\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\r\\n     * transfers.\\r\\n     */\\r\\n   /**\\r\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\r\\n     * transfers.\\r\\n     */\\r\\n    event TransferBatch(\\r\\n        address indexed operator,\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256[] ids,\\r\\n        uint256[] values\\r\\n    );\\r\\n\\r\\n     function _doSafeTransferAcceptanceCheck(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    ) internal {\\r\\n        if (to.isContract()) {\\r\\n            if( to == address(this)){\\r\\n               return;\\r\\n            }\\r\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\r\\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\\r\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\r\\n                }\\r\\n            } catch Error(string memory reason) {\\r\\n                revert(reason);\\r\\n            } catch {\\r\\n                revert(\\\"ERC1155: transfer to non-ERC1155Receiver implementer\\\");\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _doSafeBatchTransferAcceptanceCheck(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) internal {\\r\\n        if (to.isContract()) {\\r\\n            if( to == address(this)){\\r\\n               return;\\r\\n            }\\r\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\r\\n                bytes4 response\\r\\n            ) {\\r\\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\\r\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\r\\n                }\\r\\n            } catch Error(string memory reason) {\\r\\n                revert(reason);\\r\\n            } catch {\\r\\n                revert(\\\"ERC1155: transfer to non-ERC1155Receiver implementer\\\");\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n}\",\"keccak256\":\"0x929836d5a0c4a3961eb6d8c0dbc85213a50dff7fca377dd4df6e5e92832ab352\"},\"contracts/facets/Tokens/ERC1155/internals/iERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev _Available since v3.1._\\r\\n */\\r\\ncontract iERC1155Receiver   {\\r\\n\\r\\n    function _onERC1155Received(\\r\\n    ) internal pure returns (bytes4){\\r\\n        return 0xf23a6e61;\\r\\n    }\\r\\n    function _onERC1155BatchReceived(\\r\\n    ) internal pure returns (bytes4){\\r\\n        return 0xbc197c81;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xbeaf6ce27c1d8a0f9e54061b5cd887071a88a229e9ce742ad51d01e915b5b459\",\"license\":\"MIT\"},\"contracts/facets/Tokens/ERC1155/internals/iERC1155Transfer.sol\":{\"content\":\"pragma solidity ^0.8.0;\\r\\n\\r\\nimport {iERC2771Recipient} from \\\"../../../ERC2771Recipient/_ERC2771Recipient.sol\\\";    \\r\\nimport \\\"../libraries/LibERC1155.sol\\\";\\r\\nimport \\\"./iERC1155ContractTransfer.sol\\\";\\r\\nimport \\\"../interfaces/IERC1155Transfer.sol\\\";\\r\\n\\r\\ncontract iERC1155Transfer is iERC1155ContractTransfer, iERC2771Recipient {\\r\\n    /**\\r\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\r\\n     * `approved`.\\r\\n     */\\r\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\r\\n\\r\\n    /**\\r\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\r\\n     * transfers.\\r\\n     */\\r\\n\\r\\n    function _safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes memory data) internal {\\r\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\r\\n        LibERC1155.ERC1155Storage storage es = LibERC1155.erc1155Storage();\\r\\n        address operator = msgSender(); \\r\\n        uint256[] memory ids = LibERC1155._asSingletonArray(id);\\r\\n        uint256[] memory amounts = LibERC1155._asSingletonArray(amount);\\r\\n\\r\\n        uint256 fromBalance = es.balance[id][from];\\r\\n        require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\r\\n        unchecked {\\r\\n            es.balance[id][from] = fromBalance - amount;\\r\\n        }\\r\\n        es.balance[id][to] += amount;\\r\\n        emit TransferSingle(operator, from, to, id, amount);\\r\\n\\r\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\r\\n     *\\r\\n     * Emits a {TransferBatch} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function _safeBatchTransferFrom(address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal {\\r\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\r\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\r\\n        LibERC1155.ERC1155Storage storage es = LibERC1155.erc1155Storage();\\r\\n        address operator = msgSender();\\r\\n\\r\\n        for (uint256 i = 0; i < ids.length; ++i) {\\r\\n            uint256 id = ids[i];\\r\\n            uint256 amount = amounts[i];\\r\\n\\r\\n            uint256 fromBalance = es.balance[id][from];\\r\\n            require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\r\\n            unchecked {\\r\\n                es.balance[id][from] = fromBalance - amount;\\r\\n            }\\r\\n            es.balance[id][to] += amount;\\r\\n        }\\r\\n\\r\\n        emit TransferBatch(operator, from, to, ids, amounts);\\r\\n\\r\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     */\\r\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal {\\r\\n        require(owner != operator, \\\"ERC1155: setting approval status for self\\\");\\r\\n\\r\\n        LibERC1155.ERC1155Storage storage es = LibERC1155.erc1155Storage();\\r\\n        es.operatorApprovals[owner][operator] = approved;\\r\\n        emit ApprovalForAll(owner, operator, approved);\\r\\n    }\\r\\n\\r\\n    \\r\\n}\\r\\n\\r\\n\",\"keccak256\":\"0xbf776bb883cccddbaa660798a6e0f972c01864c9ee17fe9bf7ef3d0738a8da4f\"},\"contracts/facets/Tokens/ERC1155/libraries/LibERC1155.sol\":{\"content\":\"pragma solidity ^0.8.0;\\r\\n\\r\\nlibrary LibERC1155 {\\r\\n    bytes32 constant STORAGE_ERC1155 = \\\"diamond.storage.erc1155\\\";\\r\\n\\r\\n    struct ERC1155Storage {\\r\\n        // Mapping from token ID to account balances\\r\\n        mapping(uint256 => mapping(address => uint256)) balance;\\r\\n        // Mapping from account to operator approvals\\r\\n        mapping(address => mapping(address => bool)) operatorApprovals;\\r\\n        // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\r\\n        string uri;\\r\\n        uint256 totalSupply;\\r\\n    }\\r\\n\\r\\n    function erc1155Storage() internal pure returns (ERC1155Storage storage es_) {\\r\\n        bytes32 erc1155_key = STORAGE_ERC1155;\\r\\n        assembly {\\r\\n            es_.slot := erc1155_key\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getBalance(uint256 tokenId, address user) internal view returns (uint256 balance_) {\\r\\n        ERC1155Storage storage es = erc1155Storage();\\r\\n        balance_ = es.balance[tokenId][user];\\r\\n    }\\r\\n\\r\\n    function getOperatorApproval(address user, address operator) internal view returns (bool approved_) {\\r\\n        ERC1155Storage storage es = erc1155Storage();\\r\\n        approved_ = es.operatorApprovals[user][operator];\\r\\n    }\\r\\n    function _asSingletonArray(uint256 element) internal pure  returns (uint256[] memory) {\\r\\n        uint256[] memory array = new uint256[](1);\\r\\n        array[0] = element;\\r\\n\\r\\n        return array;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x2b0592f9db824744321e8eb08cfed2fb6f7ee07e0acd5d5daf3fc3e4c3318779\"},\"contracts/libraries/utils/Address.sol\":{\"content\":\"library Address {\\r\\n\\r\\n    /**\\r\\n     * Returns whether the target address is a contract\\r\\n     * @dev This function will return false if invoked during the constructor of a contract,\\r\\n     * as the code is not actually created until after the constructor finishes.\\r\\n     * @param account address of the account to check\\r\\n     * @return whether the target address is a contract\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        uint256 size;\\r\\n        // XXX Currently there is no better way to check if there is a contract in an address\\r\\n        // than to check the size of the code at that address.\\r\\n        // See https://ethereum.stackexchange.com/a/14016/36603\\r\\n        // for more details about how this works.\\r\\n        // TODO Check this again before the Serenity release, because all addresses will be\\r\\n        // contracts then.\\r\\n        // solium-disable-next-line security/no-inline-assembly\\r\\n        assembly { size := extcodesize(account) }\\r\\n        return size > 0;\\r\\n    }\\r\\n\\r\\n}\",\"keccak256\":\"0x332f7fa5b7e5de602575ce60b90e9f003ef7b6c5f6440064deb33ecca39c04d0\"},\"contracts/libraries/utils/MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev These functions deal with verification of Merkle Tree proofs.\\r\\n *\\r\\n * The tree and the proofs can be generated using our\\r\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\r\\n * You will find a quickstart guide in the readme.\\r\\n *\\r\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\r\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\r\\n * This is because the concatenation of a sorted pair of internal nodes in\\r\\n * the merkle tree could be reinterpreted as a leaf value.\\r\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\r\\n * against this attack out of the box.\\r\\n */\\r\\nlibrary MerkleProof {\\r\\n    /**\\r\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\r\\n     * defined by `root`. For this, a `proof` must be provided, containing\\r\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\r\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\r\\n     */\\r\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\r\\n        return processProof(proof, leaf) == root;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calldata version of {verify}\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\r\\n        return processProofCalldata(proof, leaf) == root;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\r\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\r\\n     * hash matches the root of the tree. When processing the proof, the pairs\\r\\n     * of leafs & pre-images are assumed to be sorted.\\r\\n     *\\r\\n     * _Available since v4.4._\\r\\n     */\\r\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\r\\n        bytes32 computedHash = leaf;\\r\\n        for (uint256 i = 0; i < proof.length; i++) {\\r\\n            computedHash = _hashPair(computedHash, proof[i]);\\r\\n        }\\r\\n        return computedHash;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calldata version of {processProof}\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\r\\n        bytes32 computedHash = leaf;\\r\\n        for (uint256 i = 0; i < proof.length; i++) {\\r\\n            computedHash = _hashPair(computedHash, proof[i]);\\r\\n        }\\r\\n        return computedHash;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\r\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\r\\n     *\\r\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function multiProofVerify(\\r\\n        bytes32[] memory proof,\\r\\n        bool[] memory proofFlags,\\r\\n        bytes32 root,\\r\\n        bytes32[] memory leaves\\r\\n    ) internal pure returns (bool) {\\r\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calldata version of {multiProofVerify}\\r\\n     *\\r\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function multiProofVerifyCalldata(\\r\\n        bytes32[] calldata proof,\\r\\n        bool[] calldata proofFlags,\\r\\n        bytes32 root,\\r\\n        bytes32[] memory leaves\\r\\n    ) internal pure returns (bool) {\\r\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\r\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\r\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\r\\n     * respectively.\\r\\n     *\\r\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\r\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\r\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function processMultiProof(\\r\\n        bytes32[] memory proof,\\r\\n        bool[] memory proofFlags,\\r\\n        bytes32[] memory leaves\\r\\n    ) internal pure returns (bytes32 merkleRoot) {\\r\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\r\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\r\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\r\\n        // the merkle tree.\\r\\n        uint256 leavesLen = leaves.length;\\r\\n        uint256 totalHashes = proofFlags.length;\\r\\n\\r\\n        // Check proof validity.\\r\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\r\\n\\r\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\r\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\r\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\r\\n        uint256 leafPos = 0;\\r\\n        uint256 hashPos = 0;\\r\\n        uint256 proofPos = 0;\\r\\n        // At each step, we compute the next hash using two values:\\r\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\r\\n        //   get the next hash.\\r\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\r\\n        //   `proof` array.\\r\\n        for (uint256 i = 0; i < totalHashes; i++) {\\r\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\r\\n            bytes32 b = proofFlags[i]\\r\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\r\\n                : proof[proofPos++];\\r\\n            hashes[i] = _hashPair(a, b);\\r\\n        }\\r\\n\\r\\n        if (totalHashes > 0) {\\r\\n            unchecked {\\r\\n                return hashes[totalHashes - 1];\\r\\n            }\\r\\n        } else if (leavesLen > 0) {\\r\\n            return leaves[0];\\r\\n        } else {\\r\\n            return proof[0];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calldata version of {processMultiProof}.\\r\\n     *\\r\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function processMultiProofCalldata(\\r\\n        bytes32[] calldata proof,\\r\\n        bool[] calldata proofFlags,\\r\\n        bytes32[] memory leaves\\r\\n    ) internal pure returns (bytes32 merkleRoot) {\\r\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\r\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\r\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\r\\n        // the merkle tree.\\r\\n        uint256 leavesLen = leaves.length;\\r\\n        uint256 totalHashes = proofFlags.length;\\r\\n\\r\\n        // Check proof validity.\\r\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\r\\n\\r\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\r\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\r\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\r\\n        uint256 leafPos = 0;\\r\\n        uint256 hashPos = 0;\\r\\n        uint256 proofPos = 0;\\r\\n        // At each step, we compute the next hash using two values:\\r\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\r\\n        //   get the next hash.\\r\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\r\\n        //   `proof` array.\\r\\n        for (uint256 i = 0; i < totalHashes; i++) {\\r\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\r\\n            bytes32 b = proofFlags[i]\\r\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\r\\n                : proof[proofPos++];\\r\\n            hashes[i] = _hashPair(a, b);\\r\\n        }\\r\\n\\r\\n        if (totalHashes > 0) {\\r\\n            unchecked {\\r\\n                return hashes[totalHashes - 1];\\r\\n            }\\r\\n        } else if (leavesLen > 0) {\\r\\n            return leaves[0];\\r\\n        } else {\\r\\n            return proof[0];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\r\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\r\\n    }\\r\\n\\r\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, a)\\r\\n            mstore(0x20, b)\\r\\n            value := keccak256(0x00, 0x40)\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x007ad9954e0a8c32075d39885e8a3fb2f754907afd84067db356592da5f5f2c3\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n}\\n\",\"keccak256\":\"0xf2560b5386574153057104d19a9e68a32ee912cf23c0c8df1fe9a0607f42d543\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6080604052348015600e575f5ffd5b50611f208061001c5f395ff3fe608060405234801561000f575f5ffd5b506004361061007a575f3560e01c80639486dbb9116100585780639486dbb9146100b9578063bf81838a146100de578063faa50303146100f1578063fee4557f14610104575f5ffd5b806315011d131461007e57806318712c211461009357806341e97bd6146100a6575b5f5ffd5b61009161008c366004611692565b610117565b005b6100916100a1366004611692565b61012d565b6100916100b43660046117d3565b610152565b6100cc6100c7366004611878565b610168565b60405190815260200160405180910390f35b6100916100ec36600461194b565b6101c4565b6100916100ff3660046119c2565b610237565b6100916101123660046119ec565b610249565b61011f61026e565b61012982826102e4565b5050565b6101356103cf565b6001600160a01b0316610146610406565b5050610129828261040f565b610160868686868686610555565b505050505050565b5f61017161026e565b6101b78989898989898080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152508b92508a915061077c9050565b9998505050505050505050565b610230858585808060200260200160405190810160405280939291908181526020018383602002808284375f92019190915250506040805160208089028281018201909352888252909350889250879182918501908490808284375f92019190915250610a2292505050565b5050505050565b61023f61026e565b6101298282610dd8565b6102516103cf565b6001600160a01b0316610262610406565b50506101298282610e72565b6102766103cf565b6001600160a01b0316610287610406565b6001600160a01b0316146102e25760405162461bcd60e51b815260206004820152601b60248201527f4d757374206265207468652045636f73797374656d206f776e6572000000000060448201526064015b60405180910390fd5b565b5f6102ee83610f14565b90506001600582015460ff16600381111561030b5761030b611a8c565b148061032e57505f600582015460ff16600381111561032c5761032c611a8c565b145b61037a5760405162461bcd60e51b815260206004820152601c60248201527f4576656e742068617320616c7265616479207465726d696e617465640000000060448201526064016102d9565b60058101805460ff191660021790556040518381527f9bec5b77a290657edefc9defa075c60a874e90f7cc9496853ca9962d58a4ffdd9060200160405180910390a181156103ca57600681018290555b505050565b5f6104017fd00049dc7109015045860694acecd3dc33338404aaf6e55a1c98a2bf41477b85546001600160a01b031690565b905090565b5f610401610fc0565b5f61041983610f14565b600581015490915060ff16600281600381111561043857610438611a8c565b14806104555750600381600381111561045357610453611a8c565b145b6104a15760405162461bcd60e51b815260206004820152601760248201527f4576656e74206d7573742062652066696e69736865642e00000000000000000060448201526064016102d9565b6006820154801561050d5760405162461bcd60e51b815260206004820152603060248201527f4d65726b6c6520726f6f742068617320616c7265616479206265656e2073657460448201526f103337b9103a3434b99032bb32b73a1760811b60648201526084016102d9565b6006830184905560408051868152602081018390527f4c0e452f95fa86af40b69d94e1ac2273e0fe6a68b007a4f05297a34b31c6211b91015b60405180910390a15050505050565b5f61055f87610f14565b905061056e8786868686611013565b6105ae5760405162461bcd60e51b8152602060048201526011602482015270141c9bdbd9881dd85cc81a5b9d985b1a59607a1b60448201526064016102d9565b5f5b8651811015610772575f826008015f6105c7610406565b6001600160a01b03166001600160a01b031681526020019081526020015f205f8984815181106105f9576105f9611aa0565b602002602001015181526020019081526020015f205490505f81116106605760405162461bcd60e51b815260206004820181905260248201527f4e6f207469636b65747320746f20726566756e6420666f72207468697320494460448201526064016102d9565b6001836003015f8282546106749190611ac8565b909155505f90506008840181610688610406565b6001600160a01b03166001600160a01b031681526020019081526020015f205f8a85815181106106ba576106ba611aa0565b602002602001015181526020019081526020015f208190555061070e306106df610406565b8a85815181106106f1576106f1611aa0565b60200260200101518460405180602001604052805f815250611161565b7fec9cd194e8c09237d75a9bd5892bc74482c824973dc58dc66f578df07f3ab23c8989848151811061074257610742611aa0565b6020908102919091018101516040805193845291830152810183905260600160405180910390a1506001016105b0565b5050505050505050565b5f7fd6270f957350f3d1a8daf6ddd325f6048f15afc2b88cdc50d3db0507046ca2956107a9600142611ac8565b8863ffffffff161161080b5760405162461bcd60e51b815260206004820152602560248201527f4d757374206265206e6f6e2d7472697669616c206576656e742074696d652077604482015264696e646f7760d81b60648201526084016102d9565b5f86116108665760405162461bcd60e51b8152602060048201526024808201527f4d7573742068617665206e6f6e2d7472697669616c20656e7472616e7420616d6044820152631bdd5b9d60e21b60648201526084016102d9565b5f89898989894260405160200161088296959493929190611adb565b60408051808303601f1901815291815281516020928301205f81815260028601909352912054909150640100000000900463ffffffff16156108fd5760405162461bcd60e51b8152602060048201526014602482015273115d995b9d081b5d5cdd081b9bdd08195e1a5cdd60621b60448201526064016102d9565b5f81815260028084016020526040909120805463ffffffff8c81166401000000000267ffffffffffffffff19909216908e1617178155600181018a90559081018890556004810161094e8882611ba9565b508a63ffffffff164263ffffffff161061096957600161096b565b5f5b60058201805460ff1916600183600381111561098957610989611a8c565b021790555060058101546040517fc37718a716de3e3514a648dd2693124bf41a17a81a7580714e58ac0259113718916109d39185918f918f918f918f918f918e9160ff1690611c91565b60405180910390a17f7dc985464b2053862162dfeac562684005dccaffae073c5d1b83ed5c6fea99928287604051610a0c929190611d40565b60405180910390a1509998505050505050505050565b5f610a2c84610f14565b6005810154815491925060ff169063ffffffff164210801590610a5e57508154640100000000900463ffffffff164211155b610a9d5760405162461bcd60e51b815260206004820152601060248201526f4576656e74206e6f742061637469766560801b60448201526064016102d9565b8251845114610aff5760405162461bcd60e51b815260206004820152602860248201527f4d69736d617463686564207469636b657449647320616e6420616d6f756e7473604482015267206c656e6774687360c01b60648201526084016102d9565b5f816003811115610b1257610b12611a8c565b03610b5a5760058201805460ff191660011790556040518581527ff5e10d7e08bcf93445bcb9f1e3b9f66dcd1431f0bb8befcfccab7fe5d387273b9060200160405180910390a15b5f5b8451811015610da4575f610b8987878481518110610b7c57610b7c611aa0565b6020026020010151611335565b9050836002015484600301546001610ba19190611d60565b1115610be75760405162461bcd60e51b8152602060048201526015602482015274457863656564696e67206d617820656e747269657360581b60448201526064016102d9565b805f0154858381518110610bfd57610bfd611aa0565b602002602001015110158015610c3057508060010154858381518110610c2557610c25611aa0565b602002602001015111155b610c745760405162461bcd60e51b8152602060048201526015602482015274125b9d985b1a59081d1a58dad95d08185b5bdd5b9d605a1b60448201526064016102d9565b610ca26040518060400160405280600d81526020016c6164647265737328746869732960981b815250611359565b610cab3061139f565b610cff610cb6610406565b30888581518110610cc957610cc9611aa0565b6020026020010151888681518110610ce357610ce3611aa0565b602002602001015160405180602001604052805f815250611161565b6001846003015f828254610d139190611d60565b92505081905550848281518110610d2c57610d2c611aa0565b6020026020010151846008015f610d41610406565b6001600160a01b03166001600160a01b031681526020019081526020015f205f888581518110610d7357610d73611aa0565b602002602001015181526020019081526020015f205f828254610d969190611d60565b909155505050600101610b5c565b507fde6d23a509cb93ef4386ac9d175fdd60bb46e74140e6216ebb00b3232c108a7285858560405161054693929190611d73565b5f610de283610f14565b805490915082908290600490610e07908490640100000000900463ffffffff16611da7565b92506101000a81548163ffffffff021916908363ffffffff1602179055507f9427ae61d55f3f11a26469a6854a9b85512ec245dc64f68653cfd41a945857f88383604051610e6592919091825263ffffffff16602082015260400190565b60405180910390a1505050565b5f610e7c83610f14565b8054909150640100000000900463ffffffff165f03610ed45760405162461bcd60e51b8152602060048201526014602482015273115d995b9d08191bd95cc81b9bdd08195e1a5cdd60621b60448201526064016102d9565b60048101610ee28382611ba9565b507fdbead81d714a5045b8e4f4f8d65f29c31ee4ee5242ad755bc4d41a2bdb8bf7998383604051610e65929190611dc3565b5f8181527fd6270f957350f3d1a8daf6ddd325f6048f15afc2b88cdc50d3db0507046ca29760205260408120547fd6270f957350f3d1a8daf6ddd325f6048f15afc2b88cdc50d3db0507046ca2959063ffffffff168203610fae5760405162461bcd60e51b8152602060048201526014602482015273115d995b9d08191bd95cc81b9bdd08195e1a5cdd60621b60448201526064016102d9565b5f928352600201602052506040902090565b5f60143610801590610ffb57507f413a4c31c13c7c3de0c7da37be5d779b152baf3f21a1cb760fda41eb8ca97776546001600160a01b031633145b1561100d575060131936013560601c90565b50335b90565b5f5f61101e87610f14565b9050611028610406565b6001600160a01b0316866001600160a01b03161080156110605750846001600160a01b0316611055610406565b6001600160a01b0316105b6110be5760405162461bcd60e51b815260206004820152602960248201527f53656e646572206973206e6f742077697468696e20746865206578636c757369604482015268766520626f756e647360b81b60648201526084016102d9565b604080516001600160a01b0380891660208301528716918101919091525f9060600160408051601f19818403018152828252805160209182012090830152016040516020818303038152906040528051906020012090506111558585808060200260200160405190810160405280939291908181526020018383602002808284375f920191909152505050506006840154836113e7565b98975050505050505050565b6001600160a01b0384166111c55760405162461bcd60e51b815260206004820152602560248201527f455243313135353a207472616e7366657220746f20746865207a65726f206164604482015264647265737360d81b60648201526084016102d9565b7f6469616d6f6e642e73746f726167652e657263313135350000000000000000005f6111ef610406565b90505f6111fb866113fc565b90505f611207866113fc565b5f888152602086815260408083206001600160a01b038e1684529091529020549091508681101561128d5760405162461bcd60e51b815260206004820152602a60248201527f455243313135353a20696e73756666696369656e742062616c616e636520666f60448201526939103a3930b739b332b960b11b60648201526084016102d9565b5f888152602086815260408083206001600160a01b038e8116855292528083208a85039055908b168252812080548992906112c9908490611d60565b909155505060408051898152602081018990526001600160a01b03808c16928d821692918816917fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62910160405180910390a4611329848b8b8b8b8b611445565b50505050505050505050565b5f61133f83610f14565b5f8381526007919091016020526040902090505b92915050565b61139c8160405160240161136d9190611ddb565b60408051601f198184030181529190526020810180516001600160e01b031663104c13eb60e21b1790526115f9565b50565b6040516001600160a01b038216602482015261139c9060440160408051601f198184030181529190526020810180516001600160e01b031663161765e160e11b1790526115f9565b5f826113f38584611602565b14949350505050565b6040805160018082528183019092526060915f91906020808301908036833701905050905082815f8151811061143457611434611aa0565b602090810291909101015292915050565b6001600160a01b0384163b15610160576001600160a01b03841630146101605760405163f23a6e6160e01b81526001600160a01b0385169063f23a6e61906114999089908990889088908890600401611ded565b6020604051808303815f875af19250505080156114d3575060408051601f3d908101601f191682019092526114d091810190611e31565b60015b61157f576114df611e58565b806308c379a00361151857506114f3611e70565b806114fe575061151a565b8060405162461bcd60e51b81526004016102d99190611ddb565b505b60405162461bcd60e51b815260206004820152603460248201527f455243313135353a207472616e7366657220746f206e6f6e2d455243313135356044820152732932b1b2b4bb32b91034b6b83632b6b2b73a32b960611b60648201526084016102d9565b6001600160e01b0319811663f23a6e6160e01b146115f05760405162461bcd60e51b815260206004820152602860248201527f455243313135353a204552433131353552656365697665722072656a656374656044820152676420746f6b656e7360c01b60648201526084016102d9565b50505050505050565b61139c81611644565b5f81815b845181101561163c576116328286838151811061162557611625611aa0565b6020026020010151611663565b9150600101611606565b509392505050565b5f6a636f6e736f6c652e6c6f6790505f5f835160208501845afa505050565b5f81831061167d575f82815260208490526040902061168b565b5f8381526020839052604090205b9392505050565b5f5f604083850312156116a3575f5ffd5b50508035926020909101359150565b634e487b7160e01b5f52604160045260245ffd5b601f8201601f191681016001600160401b03811182821017156116eb576116eb6116b2565b6040525050565b5f82601f830112611701575f5ffd5b81356001600160401b0381111561171a5761171a6116b2565b8060051b60405161172e60208301826116c6565b918252602081850181019290810186841115611748575f5ffd5b6020860192505b8383101561176757823581526020928301920161174f565b5095945050505050565b80356001600160a01b0381168114611787575f5ffd5b919050565b5f5f83601f84011261179c575f5ffd5b5081356001600160401b038111156117b2575f5ffd5b6020830191508360208260051b85010111156117cc575f5ffd5b9250929050565b5f5f5f5f5f5f60a087890312156117e8575f5ffd5b8635955060208701356001600160401b03811115611804575f5ffd5b61181089828a016116f2565b95505061181f60408801611771565b935061182d60608801611771565b925060808701356001600160401b03811115611847575f5ffd5b61185389828a0161178c565b979a9699509497509295939492505050565b803563ffffffff81168114611787575f5ffd5b5f5f5f5f5f5f5f5f60e0898b03121561188f575f5ffd5b61189889611865565b97506118a660208a01611865565b9650604089013595506060890135945060808901356001600160401b038111156118ce575f5ffd5b8901601f81018b136118de575f5ffd5b80356001600160401b038111156118f3575f5ffd5b8b6020828401011115611904575f5ffd5b6020919091019450925060a08901356001600160401b03811115611926575f5ffd5b6119328b828c016116f2565b989b979a50959894979396929550929360c00135925050565b5f5f5f5f5f6060868803121561195f575f5ffd5b8535945060208601356001600160401b0381111561197b575f5ffd5b6119878882890161178c565b90955093505060408601356001600160401b038111156119a5575f5ffd5b6119b18882890161178c565b969995985093965092949392505050565b5f5f604083850312156119d3575f5ffd5b823591506119e360208401611865565b90509250929050565b5f5f604083850312156119fd575f5ffd5b8235915060208301356001600160401b03811115611a19575f5ffd5b8301601f81018513611a29575f5ffd5b80356001600160401b03811115611a4257611a426116b2565b604051611a59601f8301601f1916602001826116c6565b818152866020838501011115611a6d575f5ffd5b816020840160208301375f602083830101528093505050509250929050565b634e487b7160e01b5f52602160045260245ffd5b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b8181038181111561135357611353611ab4565b63ffffffff60e01b8760e01b16815263ffffffff60e01b8660e01b1660048201528460088201528360288201525f83518060208601604885015e60489201918201929092526068019695505050505050565b600181811c90821680611b4157607f821691505b602082108103611b5f57634e487b7160e01b5f52602260045260245ffd5b50919050565b601f8211156103ca57805f5260205f20601f840160051c81016020851015611b8a5750805b601f840160051c820191505b81811015610230575f8155600101611b96565b81516001600160401b03811115611bc257611bc26116b2565b611bd681611bd08454611b2d565b84611b65565b6020601f821160018114611c08575f8315611bf15750848201515b5f19600385901b1c1916600184901b178455610230565b5f84815260208120601f198516915b82811015611c375787850151825560209485019460019092019101611c17565b5084821015611c5457868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b88815263ffffffff8816602082015263ffffffff8716604082015285606082015284608082015261010060a08201525f611ccf610100830186611c63565b90508360c083015260048310611cf357634e487b7160e01b5f52602160045260245ffd5b8260e08301529998505050505050505050565b5f8151808452602084019350602083015f5b82811015611d36578151865260209586019590910190600101611d18565b5093949350505050565b828152604060208201525f611d586040830184611d06565b949350505050565b8082018082111561135357611353611ab4565b838152606060208201525f611d8b6060830185611d06565b8281036040840152611d9d8185611d06565b9695505050505050565b63ffffffff818116838216019081111561135357611353611ab4565b828152604060208201525f611d586040830184611c63565b602081525f61168b6020830184611c63565b6001600160a01b03868116825285166020820152604081018490526060810183905260a0608082018190525f90611e2690830184611c63565b979650505050505050565b5f60208284031215611e41575f5ffd5b81516001600160e01b03198116811461168b575f5ffd5b5f60033d11156110105760045f5f3e505f5160e01c90565b5f60443d1015611e7d5790565b6040513d600319016004823e80513d60248201116001600160401b0382111715611ea657505090565b80820180516001600160401b03811115611ec1575050505090565b3d8401600319018282016020011115611edb575050505090565b61163c602082850101856116c656fea2646970667358221220199e9468206bcb1ffada6d2ab3220e3dd70b1884b1fa66deca0852a349a7496064736f6c634300081c0033",
  "deployedBytecode": "0x608060405234801561000f575f5ffd5b506004361061007a575f3560e01c80639486dbb9116100585780639486dbb9146100b9578063bf81838a146100de578063faa50303146100f1578063fee4557f14610104575f5ffd5b806315011d131461007e57806318712c211461009357806341e97bd6146100a6575b5f5ffd5b61009161008c366004611692565b610117565b005b6100916100a1366004611692565b61012d565b6100916100b43660046117d3565b610152565b6100cc6100c7366004611878565b610168565b60405190815260200160405180910390f35b6100916100ec36600461194b565b6101c4565b6100916100ff3660046119c2565b610237565b6100916101123660046119ec565b610249565b61011f61026e565b61012982826102e4565b5050565b6101356103cf565b6001600160a01b0316610146610406565b5050610129828261040f565b610160868686868686610555565b505050505050565b5f61017161026e565b6101b78989898989898080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152508b92508a915061077c9050565b9998505050505050505050565b610230858585808060200260200160405190810160405280939291908181526020018383602002808284375f92019190915250506040805160208089028281018201909352888252909350889250879182918501908490808284375f92019190915250610a2292505050565b5050505050565b61023f61026e565b6101298282610dd8565b6102516103cf565b6001600160a01b0316610262610406565b50506101298282610e72565b6102766103cf565b6001600160a01b0316610287610406565b6001600160a01b0316146102e25760405162461bcd60e51b815260206004820152601b60248201527f4d757374206265207468652045636f73797374656d206f776e6572000000000060448201526064015b60405180910390fd5b565b5f6102ee83610f14565b90506001600582015460ff16600381111561030b5761030b611a8c565b148061032e57505f600582015460ff16600381111561032c5761032c611a8c565b145b61037a5760405162461bcd60e51b815260206004820152601c60248201527f4576656e742068617320616c7265616479207465726d696e617465640000000060448201526064016102d9565b60058101805460ff191660021790556040518381527f9bec5b77a290657edefc9defa075c60a874e90f7cc9496853ca9962d58a4ffdd9060200160405180910390a181156103ca57600681018290555b505050565b5f6104017fd00049dc7109015045860694acecd3dc33338404aaf6e55a1c98a2bf41477b85546001600160a01b031690565b905090565b5f610401610fc0565b5f61041983610f14565b600581015490915060ff16600281600381111561043857610438611a8c565b14806104555750600381600381111561045357610453611a8c565b145b6104a15760405162461bcd60e51b815260206004820152601760248201527f4576656e74206d7573742062652066696e69736865642e00000000000000000060448201526064016102d9565b6006820154801561050d5760405162461bcd60e51b815260206004820152603060248201527f4d65726b6c6520726f6f742068617320616c7265616479206265656e2073657460448201526f103337b9103a3434b99032bb32b73a1760811b60648201526084016102d9565b6006830184905560408051868152602081018390527f4c0e452f95fa86af40b69d94e1ac2273e0fe6a68b007a4f05297a34b31c6211b91015b60405180910390a15050505050565b5f61055f87610f14565b905061056e8786868686611013565b6105ae5760405162461bcd60e51b8152602060048201526011602482015270141c9bdbd9881dd85cc81a5b9d985b1a59607a1b60448201526064016102d9565b5f5b8651811015610772575f826008015f6105c7610406565b6001600160a01b03166001600160a01b031681526020019081526020015f205f8984815181106105f9576105f9611aa0565b602002602001015181526020019081526020015f205490505f81116106605760405162461bcd60e51b815260206004820181905260248201527f4e6f207469636b65747320746f20726566756e6420666f72207468697320494460448201526064016102d9565b6001836003015f8282546106749190611ac8565b909155505f90506008840181610688610406565b6001600160a01b03166001600160a01b031681526020019081526020015f205f8a85815181106106ba576106ba611aa0565b602002602001015181526020019081526020015f208190555061070e306106df610406565b8a85815181106106f1576106f1611aa0565b60200260200101518460405180602001604052805f815250611161565b7fec9cd194e8c09237d75a9bd5892bc74482c824973dc58dc66f578df07f3ab23c8989848151811061074257610742611aa0565b6020908102919091018101516040805193845291830152810183905260600160405180910390a1506001016105b0565b5050505050505050565b5f7fd6270f957350f3d1a8daf6ddd325f6048f15afc2b88cdc50d3db0507046ca2956107a9600142611ac8565b8863ffffffff161161080b5760405162461bcd60e51b815260206004820152602560248201527f4d757374206265206e6f6e2d7472697669616c206576656e742074696d652077604482015264696e646f7760d81b60648201526084016102d9565b5f86116108665760405162461bcd60e51b8152602060048201526024808201527f4d7573742068617665206e6f6e2d7472697669616c20656e7472616e7420616d6044820152631bdd5b9d60e21b60648201526084016102d9565b5f89898989894260405160200161088296959493929190611adb565b60408051808303601f1901815291815281516020928301205f81815260028601909352912054909150640100000000900463ffffffff16156108fd5760405162461bcd60e51b8152602060048201526014602482015273115d995b9d081b5d5cdd081b9bdd08195e1a5cdd60621b60448201526064016102d9565b5f81815260028084016020526040909120805463ffffffff8c81166401000000000267ffffffffffffffff19909216908e1617178155600181018a90559081018890556004810161094e8882611ba9565b508a63ffffffff164263ffffffff161061096957600161096b565b5f5b60058201805460ff1916600183600381111561098957610989611a8c565b021790555060058101546040517fc37718a716de3e3514a648dd2693124bf41a17a81a7580714e58ac0259113718916109d39185918f918f918f918f918f918e9160ff1690611c91565b60405180910390a17f7dc985464b2053862162dfeac562684005dccaffae073c5d1b83ed5c6fea99928287604051610a0c929190611d40565b60405180910390a1509998505050505050505050565b5f610a2c84610f14565b6005810154815491925060ff169063ffffffff164210801590610a5e57508154640100000000900463ffffffff164211155b610a9d5760405162461bcd60e51b815260206004820152601060248201526f4576656e74206e6f742061637469766560801b60448201526064016102d9565b8251845114610aff5760405162461bcd60e51b815260206004820152602860248201527f4d69736d617463686564207469636b657449647320616e6420616d6f756e7473604482015267206c656e6774687360c01b60648201526084016102d9565b5f816003811115610b1257610b12611a8c565b03610b5a5760058201805460ff191660011790556040518581527ff5e10d7e08bcf93445bcb9f1e3b9f66dcd1431f0bb8befcfccab7fe5d387273b9060200160405180910390a15b5f5b8451811015610da4575f610b8987878481518110610b7c57610b7c611aa0565b6020026020010151611335565b9050836002015484600301546001610ba19190611d60565b1115610be75760405162461bcd60e51b8152602060048201526015602482015274457863656564696e67206d617820656e747269657360581b60448201526064016102d9565b805f0154858381518110610bfd57610bfd611aa0565b602002602001015110158015610c3057508060010154858381518110610c2557610c25611aa0565b602002602001015111155b610c745760405162461bcd60e51b8152602060048201526015602482015274125b9d985b1a59081d1a58dad95d08185b5bdd5b9d605a1b60448201526064016102d9565b610ca26040518060400160405280600d81526020016c6164647265737328746869732960981b815250611359565b610cab3061139f565b610cff610cb6610406565b30888581518110610cc957610cc9611aa0565b6020026020010151888681518110610ce357610ce3611aa0565b602002602001015160405180602001604052805f815250611161565b6001846003015f828254610d139190611d60565b92505081905550848281518110610d2c57610d2c611aa0565b6020026020010151846008015f610d41610406565b6001600160a01b03166001600160a01b031681526020019081526020015f205f888581518110610d7357610d73611aa0565b602002602001015181526020019081526020015f205f828254610d969190611d60565b909155505050600101610b5c565b507fde6d23a509cb93ef4386ac9d175fdd60bb46e74140e6216ebb00b3232c108a7285858560405161054693929190611d73565b5f610de283610f14565b805490915082908290600490610e07908490640100000000900463ffffffff16611da7565b92506101000a81548163ffffffff021916908363ffffffff1602179055507f9427ae61d55f3f11a26469a6854a9b85512ec245dc64f68653cfd41a945857f88383604051610e6592919091825263ffffffff16602082015260400190565b60405180910390a1505050565b5f610e7c83610f14565b8054909150640100000000900463ffffffff165f03610ed45760405162461bcd60e51b8152602060048201526014602482015273115d995b9d08191bd95cc81b9bdd08195e1a5cdd60621b60448201526064016102d9565b60048101610ee28382611ba9565b507fdbead81d714a5045b8e4f4f8d65f29c31ee4ee5242ad755bc4d41a2bdb8bf7998383604051610e65929190611dc3565b5f8181527fd6270f957350f3d1a8daf6ddd325f6048f15afc2b88cdc50d3db0507046ca29760205260408120547fd6270f957350f3d1a8daf6ddd325f6048f15afc2b88cdc50d3db0507046ca2959063ffffffff168203610fae5760405162461bcd60e51b8152602060048201526014602482015273115d995b9d08191bd95cc81b9bdd08195e1a5cdd60621b60448201526064016102d9565b5f928352600201602052506040902090565b5f60143610801590610ffb57507f413a4c31c13c7c3de0c7da37be5d779b152baf3f21a1cb760fda41eb8ca97776546001600160a01b031633145b1561100d575060131936013560601c90565b50335b90565b5f5f61101e87610f14565b9050611028610406565b6001600160a01b0316866001600160a01b03161080156110605750846001600160a01b0316611055610406565b6001600160a01b0316105b6110be5760405162461bcd60e51b815260206004820152602960248201527f53656e646572206973206e6f742077697468696e20746865206578636c757369604482015268766520626f756e647360b81b60648201526084016102d9565b604080516001600160a01b0380891660208301528716918101919091525f9060600160408051601f19818403018152828252805160209182012090830152016040516020818303038152906040528051906020012090506111558585808060200260200160405190810160405280939291908181526020018383602002808284375f920191909152505050506006840154836113e7565b98975050505050505050565b6001600160a01b0384166111c55760405162461bcd60e51b815260206004820152602560248201527f455243313135353a207472616e7366657220746f20746865207a65726f206164604482015264647265737360d81b60648201526084016102d9565b7f6469616d6f6e642e73746f726167652e657263313135350000000000000000005f6111ef610406565b90505f6111fb866113fc565b90505f611207866113fc565b5f888152602086815260408083206001600160a01b038e1684529091529020549091508681101561128d5760405162461bcd60e51b815260206004820152602a60248201527f455243313135353a20696e73756666696369656e742062616c616e636520666f60448201526939103a3930b739b332b960b11b60648201526084016102d9565b5f888152602086815260408083206001600160a01b038e8116855292528083208a85039055908b168252812080548992906112c9908490611d60565b909155505060408051898152602081018990526001600160a01b03808c16928d821692918816917fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62910160405180910390a4611329848b8b8b8b8b611445565b50505050505050505050565b5f61133f83610f14565b5f8381526007919091016020526040902090505b92915050565b61139c8160405160240161136d9190611ddb565b60408051601f198184030181529190526020810180516001600160e01b031663104c13eb60e21b1790526115f9565b50565b6040516001600160a01b038216602482015261139c9060440160408051601f198184030181529190526020810180516001600160e01b031663161765e160e11b1790526115f9565b5f826113f38584611602565b14949350505050565b6040805160018082528183019092526060915f91906020808301908036833701905050905082815f8151811061143457611434611aa0565b602090810291909101015292915050565b6001600160a01b0384163b15610160576001600160a01b03841630146101605760405163f23a6e6160e01b81526001600160a01b0385169063f23a6e61906114999089908990889088908890600401611ded565b6020604051808303815f875af19250505080156114d3575060408051601f3d908101601f191682019092526114d091810190611e31565b60015b61157f576114df611e58565b806308c379a00361151857506114f3611e70565b806114fe575061151a565b8060405162461bcd60e51b81526004016102d99190611ddb565b505b60405162461bcd60e51b815260206004820152603460248201527f455243313135353a207472616e7366657220746f206e6f6e2d455243313135356044820152732932b1b2b4bb32b91034b6b83632b6b2b73a32b960611b60648201526084016102d9565b6001600160e01b0319811663f23a6e6160e01b146115f05760405162461bcd60e51b815260206004820152602860248201527f455243313135353a204552433131353552656365697665722072656a656374656044820152676420746f6b656e7360c01b60648201526084016102d9565b50505050505050565b61139c81611644565b5f81815b845181101561163c576116328286838151811061162557611625611aa0565b6020026020010151611663565b9150600101611606565b509392505050565b5f6a636f6e736f6c652e6c6f6790505f5f835160208501845afa505050565b5f81831061167d575f82815260208490526040902061168b565b5f8381526020839052604090205b9392505050565b5f5f604083850312156116a3575f5ffd5b50508035926020909101359150565b634e487b7160e01b5f52604160045260245ffd5b601f8201601f191681016001600160401b03811182821017156116eb576116eb6116b2565b6040525050565b5f82601f830112611701575f5ffd5b81356001600160401b0381111561171a5761171a6116b2565b8060051b60405161172e60208301826116c6565b918252602081850181019290810186841115611748575f5ffd5b6020860192505b8383101561176757823581526020928301920161174f565b5095945050505050565b80356001600160a01b0381168114611787575f5ffd5b919050565b5f5f83601f84011261179c575f5ffd5b5081356001600160401b038111156117b2575f5ffd5b6020830191508360208260051b85010111156117cc575f5ffd5b9250929050565b5f5f5f5f5f5f60a087890312156117e8575f5ffd5b8635955060208701356001600160401b03811115611804575f5ffd5b61181089828a016116f2565b95505061181f60408801611771565b935061182d60608801611771565b925060808701356001600160401b03811115611847575f5ffd5b61185389828a0161178c565b979a9699509497509295939492505050565b803563ffffffff81168114611787575f5ffd5b5f5f5f5f5f5f5f5f60e0898b03121561188f575f5ffd5b61189889611865565b97506118a660208a01611865565b9650604089013595506060890135945060808901356001600160401b038111156118ce575f5ffd5b8901601f81018b136118de575f5ffd5b80356001600160401b038111156118f3575f5ffd5b8b6020828401011115611904575f5ffd5b6020919091019450925060a08901356001600160401b03811115611926575f5ffd5b6119328b828c016116f2565b989b979a50959894979396929550929360c00135925050565b5f5f5f5f5f6060868803121561195f575f5ffd5b8535945060208601356001600160401b0381111561197b575f5ffd5b6119878882890161178c565b90955093505060408601356001600160401b038111156119a5575f5ffd5b6119b18882890161178c565b969995985093965092949392505050565b5f5f604083850312156119d3575f5ffd5b823591506119e360208401611865565b90509250929050565b5f5f604083850312156119fd575f5ffd5b8235915060208301356001600160401b03811115611a19575f5ffd5b8301601f81018513611a29575f5ffd5b80356001600160401b03811115611a4257611a426116b2565b604051611a59601f8301601f1916602001826116c6565b818152866020838501011115611a6d575f5ffd5b816020840160208301375f602083830101528093505050509250929050565b634e487b7160e01b5f52602160045260245ffd5b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b8181038181111561135357611353611ab4565b63ffffffff60e01b8760e01b16815263ffffffff60e01b8660e01b1660048201528460088201528360288201525f83518060208601604885015e60489201918201929092526068019695505050505050565b600181811c90821680611b4157607f821691505b602082108103611b5f57634e487b7160e01b5f52602260045260245ffd5b50919050565b601f8211156103ca57805f5260205f20601f840160051c81016020851015611b8a5750805b601f840160051c820191505b81811015610230575f8155600101611b96565b81516001600160401b03811115611bc257611bc26116b2565b611bd681611bd08454611b2d565b84611b65565b6020601f821160018114611c08575f8315611bf15750848201515b5f19600385901b1c1916600184901b178455610230565b5f84815260208120601f198516915b82811015611c375787850151825560209485019460019092019101611c17565b5084821015611c5457868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b88815263ffffffff8816602082015263ffffffff8716604082015285606082015284608082015261010060a08201525f611ccf610100830186611c63565b90508360c083015260048310611cf357634e487b7160e01b5f52602160045260245ffd5b8260e08301529998505050505050505050565b5f8151808452602084019350602083015f5b82811015611d36578151865260209586019590910190600101611d18565b5093949350505050565b828152604060208201525f611d586040830184611d06565b949350505050565b8082018082111561135357611353611ab4565b838152606060208201525f611d8b6060830185611d06565b8281036040840152611d9d8185611d06565b9695505050505050565b63ffffffff818116838216019081111561135357611353611ab4565b828152604060208201525f611d586040830184611c63565b602081525f61168b6020830184611c63565b6001600160a01b03868116825285166020820152604081018490526060810183905260a0608082018190525f90611e2690830184611c63565b979650505050505050565b5f60208284031215611e41575f5ffd5b81516001600160e01b03198116811461168b575f5ffd5b5f60033d11156110105760045f5f3e505f5160e01c90565b5f60443d1015611e7d5790565b6040513d600319016004823e80513d60248201116001600160401b0382111715611ea657505090565b80820180516001600160401b03811115611ec1575050505090565b3d8401600319018282016020011115611edb575050505090565b61163c602082850101856116c656fea2646970667358221220199e9468206bcb1ffada6d2ab3220e3dd70b1884b1fa66deca0852a349a7496064736f6c634300081c0033",
  "devdoc": {
    "events": {
      "ApprovalForAll(address,address,bool)": {
        "details": "Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to `approved`."
      },
      "EventActivated(uint256)": {
        "details": "Emitted when an event transitions from a pending state to an active state, which generally happens when the first ticket for the event is redeemed.",
        "params": {
          "eventId": "The unique identifier for the event."
        }
      },
      "EventDeactivated(uint256)": {
        "details": "Emitted when an event is deactivated by the owner.",
        "params": {
          "eventId": "The unique identifier for the event."
        }
      },
      "EventDetails(uint256,uint32,uint32,uint256,uint256,string,uint256,uint8)": {
        "details": "Emitted when a new event is created. Contains all the essential details regarding the event including its schedule and entry conditions.",
        "params": {
          "endTime": "The end time of the event, represented as a UNIX timestamp.",
          "eventId": "The unique identifier for the event.",
          "imageUri": "A URI pointing to the event's image resource.",
          "maxEntries": "The maximum number of entries allowed for the event.",
          "maxEntriesPerUser": "max entries a user can submit to event",
          "minEntries": "The minimum number of entries required for the event.",
          "startTime": "The start time of the event, represented as a UNIX timestamp.",
          "status": "The current status of the event."
        }
      },
      "EventExtended(uint256,uint32)": {
        "details": "Emitted when an event's duration is extended",
        "params": {
          "addedTime": "Time added to the endTime property of the event",
          "eventId": "The unique identifier for the event."
        }
      },
      "TicketDetails(uint256,uint256[])": {
        "details": "Emitted when ticket details for a specific event are defined or updated. Contains arrays of ticket IDs and their corresponding details.",
        "params": {
          "eventId": "The unique identifier for the event.",
          "ticketIds": "An array of unique identifiers for the tickets associated with the event."
        }
      },
      "TicketRedeemed(uint256,uint256[],uint256[])": {
        "details": "Emitted when one or more tickets are redeemed for an event. Contains details of the ticket IDs and the respective amounts that have been redeemed.",
        "params": {
          "amounts": "An array of amounts representing the quantity redeemed for each corresponding ticket ID.",
          "eventId": "The unique identifier for the event.",
          "ticketIds": "An array of unique identifiers for the tickets that have been redeemed."
        }
      },
      "TicketRefunded(uint256,uint256,uint256)": {
        "details": "Emitted when a ticket is refunded. This occurs after a successful call to the `refundTicketsWithProof` function, indicating that the refund was processed successfully.",
        "params": {
          "amount": "The amount that has been refunded for the particular ticket id.",
          "eventId": "The unique identifier for the event.",
          "ticketId": "The unique identifier for the ticket that has been refunded."
        }
      },
      "TransferBatch(address,address,address,uint256[],uint256[])": {
        "details": "Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all transfers."
      },
      "TransferSingle(address,address,address,uint256,uint256)": {
        "details": "Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`."
      }
    },
    "kind": "dev",
    "methods": {
      "createEvent(uint32,uint32,uint256,uint256,string,uint256[],uint256)": {
        "details": "External function that allows for the creation of a new event",
        "params": {
          "_endTime": "The end time of the event",
          "_imageUri": "The URI for the event's image",
          "_maxEntries": "The maximum number of entries for the event",
          "_minEntries": "The minimum number of entries for the event",
          "_startTime": "The start time of the event"
        },
        "returns": {
          "_0": "The ID of the created event"
        }
      },
      "deactivateEvent(uint256,bytes32)": {
        "details": "Only callable by the owner or authorized addresses. Can be used to deactivate an event prematurely.",
        "params": {
          "eventId": "The ID of the event to deactivate.",
          "root": "Optionally, a new Merkle root to set. Pass bytes32(0) to not update the Merkle root."
        }
      },
      "extendEvent(uint256,uint32)": {
        "details": "Only callable by the owner or authorized addresses. The event time extension should respect any set maximum limits.",
        "params": {
          "addedTime": "The additional time to add to the event's duration, in seconds.",
          "eventId": "The ID of the event to extend."
        }
      },
      "redeemTickets(uint256,uint256[],uint256[])": {
        "details": "Batch process to redeem multiple tickets at once",
        "params": {
          "amounts": "The amounts corresponding to each ticket to be redeemed",
          "eventId": "The ID of the event",
          "ticketIds": "The IDs of the tickets to be redeemed"
        }
      },
      "refundTicketsWithProof(uint256,uint256[],address,address,bytes32[])": {
        "details": "Batch process to refund multiple tickets at once. We refund a user   if they can prove their addre",
        "params": {
          "eventId": "The ID of the event",
          "lowerBound": "Lower bound address ",
          "merkleProof": "Lower bound address ",
          "ticketIds": "The IDs of the tickets to be refunded",
          "upperBound": "upper bound address "
        }
      },
      "setImageUri(uint256,string)": {
        "details": "Only callable by the owner or authorized addresses.",
        "params": {
          "eventId": "The ID of the event to set the image URI for.",
          "imageUri": "The new image URI as a string."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "createEvent(uint32,uint32,uint256,uint256,string,uint256[],uint256)": {
        "notice": "Creates a new event"
      },
      "deactivateEvent(uint256,bytes32)": {
        "notice": "Deactivates the specified event and optionally updates the Merkle root."
      },
      "extendEvent(uint256,uint32)": {
        "notice": "Extends the duration of the specified event by the added time."
      },
      "redeemTickets(uint256,uint256[],uint256[])": {
        "notice": "Allows the redemption of multiple tickets for an event"
      },
      "refundTicketsWithProof(uint256,uint256[],address,address,bytes32[])": {
        "notice": "Allows the refund of tickets"
      },
      "setImageUri(uint256,string)": {
        "notice": "Sets a new image URI for the specified event."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}