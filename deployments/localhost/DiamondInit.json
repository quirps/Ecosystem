{
  "address": "0xbD304DA71DddEc95DE6e5819d4A43fb382E6fB1e",
  "abi": [
    {
      "inputs": [],
      "name": "init",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x462d4757fcf5203d99a77d79631c6bcbaf49f7d929b0355088e08a079f16b3e3",
  "receipt": {
    "to": null,
    "from": "0x1a47C1D6d5B47048536f1111C854e48fA9D76fdF",
    "contractAddress": "0xbD304DA71DddEc95DE6e5819d4A43fb382E6fB1e",
    "transactionIndex": 0,
    "gasUsed": "132555",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x6d03fce348923d588257248be420dc5f784166ea2890db38a734d78001d2fd20",
    "transactionHash": "0x462d4757fcf5203d99a77d79631c6bcbaf49f7d929b0355088e08a079f16b3e3",
    "logs": [],
    "blockNumber": 7,
    "cumulativeGasUsed": "132555",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "54a7063fbd1377e55e2032f74c4aa199",
  "metadata": "{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/upgradeInitializers/DiamondInit.sol\":\"DiamondInit\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IERC165 {\\r\\n    /// @notice Query if a contract implements an interface\\r\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\r\\n    /// @dev Interface identification is specified in ERC-165. This function\\r\\n    ///  uses less than 30,000 gas.\\r\\n    /// @return `true` if the contract implements `interfaceID` and\\r\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\",\"keccak256\":\"0x2deeed007d7ea76735bf06eefa327e2a2a37c3b2690619d57a91401f3382300b\",\"license\":\"MIT\"},\"contracts/IERC173.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/// @title ERC-173 Contract Ownership Standard\\r\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\r\\n/* is ERC165 */\\r\\ninterface IERC173 {\\r\\n    /// @dev This emits when ownership of a contract changes.\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /// @notice Get the address of the owner\\r\\n    /// @return owner_ The address of the owner.\\r\\n    function owner() external view returns (address owner_);\\r\\n\\r\\n    /// @notice Set the address of the new owner of the contract\\r\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\r\\n    /// @param _newOwner The address of the new owner of the contract\\r\\n    function transferOwnership(address _newOwner) external;\\r\\n}\\r\\n\",\"keccak256\":\"0x0617cc298103723214d1987960e4a4f7482dd327362cb9a9d3dc6d69e42bb7dc\",\"license\":\"MIT\"},\"contracts/facets/Diamond/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\r\\n/******************************************************************************/\\r\\n\\r\\ninterface IDiamondCut {\\r\\n    enum FacetCutAction {Add, Replace, Remove}\\r\\n    // Add=0, Replace=1, Remove=2\\r\\n\\r\\n    struct FacetCut {\\r\\n        address facetAddress;\\r\\n        FacetCutAction action;  \\r\\n        bytes4[] functionSelectors;\\r\\n    }\\r\\n\\r\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\r\\n    ///         a function with delegatecall\\r\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\r\\n    /// @param _init The address of the contract or facet to execute _calldata\\r\\n    /// @param _calldata A function call, including function selector and arguments\\r\\n    ///                  _calldata is executed with delegatecall on _init\\r\\n    function diamondCut(\\r\\n        FacetCut[] calldata _diamondCut,\\r\\n        address _init,\\r\\n        bytes calldata _calldata\\r\\n    ) external;\\r\\n\\r\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\r\\n}\\r\\n\",\"keccak256\":\"0x46092c4cf4268459a2d39671813fec1bd4779825a010e4650314366b75d135b1\",\"license\":\"MIT\"},\"contracts/facets/Diamond/IDiamondLoupe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\r\\n/******************************************************************************/\\r\\n\\r\\n// A loupe is a small magnifying glass used to look at diamonds.\\r\\n// These functions look at diamonds\\r\\ninterface IDiamondLoupe {\\r\\n    /// These functions are expected to be called frequently\\r\\n    /// by tools.\\r\\n \\r\\n    struct Facet {\\r\\n        address facetAddress;\\r\\n        bytes4[] functionSelectors;\\r\\n    }\\r\\n\\r\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\r\\n    /// @return facets_ Facet\\r\\n    function facets() external view returns (Facet[] memory facets_);\\r\\n\\r\\n    /// @notice Gets all the function selectors supported by a specific facet.\\r\\n    /// @param _facet The facet address.\\r\\n    /// @return facetFunctionSelectors_\\r\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\r\\n\\r\\n    /// @notice Get all the facet addresses used by a diamond.\\r\\n    /// @return facetAddresses_\\r\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\r\\n\\r\\n    /// @notice Gets the facet that supports the given selector.\\r\\n    /// @dev If facet is not found return address(0).\\r\\n    /// @param _functionSelector The function selector.\\r\\n    /// @return facetAddress_ The facet address.\\r\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\r\\n}\\r\\n\",\"keccak256\":\"0x5b2b9e09167f5bdb33958653616780c676ea31137e0e192d5820e5c3ddc07001\",\"license\":\"MIT\"},\"contracts/facets/Diamond/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\r\\n/******************************************************************************/\\r\\nimport { IDiamondCut } from \\\"./IDiamondCut.sol\\\";\\r\\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\\r\\n// The loupe functions are required by the EIP2535 Diamonds standard\\r\\nimport {LibOwnership} from \\\"../Ownership/LibOwnership.sol\\\";\\r\\n\\r\\nlibrary LibDiamond {\\r\\n    error InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\\r\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\r\\n    \\r\\n    struct FacetAddressAndPosition {\\r\\n        address facetAddress;\\r\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\r\\n    }\\r\\n\\r\\n    struct FacetFunctionSelectors {\\r\\n        bytes4[] functionSelectors;\\r\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\r\\n    }\\r\\n\\r\\n    struct DiamondStorage {\\r\\n        // maps function selector to the facet address and\\r\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\r\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\r\\n        // maps facet addresses to function selectors\\r\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\r\\n        // facet addresses\\r\\n        address[] facetAddresses;\\r\\n        // Used to query if a contract implements an interface.\\r\\n        // Used to implement ERC-165.\\r\\n        mapping(bytes4 => bool) supportedInterfaces;\\r\\n        \\r\\n    }\\r\\n\\r\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\r\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n\\r\\n\\r\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\r\\n\\r\\n    // Internal function version of diamondCut\\r\\n    function diamondCut(\\r\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\r\\n        address _init,\\r\\n        bytes memory _calldata\\r\\n    ) internal {\\r\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\r\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\r\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\r\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\r\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\r\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\r\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\r\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\r\\n            } else {\\r\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\r\\n            }\\r\\n        }\\r\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\r\\n        initializeDiamondCut(_init, _calldata);\\r\\n    }\\r\\n\\r\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\r\\n\\r\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\r\\n        DiamondStorage storage ds = diamondStorage();        \\r\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\r\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\r\\n        // add new facet address if it does not exist\\r\\n        if (selectorPosition == 0) {\\r\\n            addFacet(ds, _facetAddress);            \\r\\n        }\\r\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\r\\n            bytes4 selector = _functionSelectors[selectorIndex];\\r\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\r\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\r\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\r\\n            selectorPosition++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\r\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\r\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\r\\n        // add new facet address if it does not exist\\r\\n        if (selectorPosition == 0) {\\r\\n            addFacet(ds, _facetAddress);\\r\\n        }\\r\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\r\\n            bytes4 selector = _functionSelectors[selectorIndex];\\r\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\r\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\r\\n            removeFunction(ds, oldFacetAddress, selector);\\r\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\r\\n            selectorPosition++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\r\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        // if function does not exist then do nothing and return\\r\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\r\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\r\\n            bytes4 selector = _functionSelectors[selectorIndex];\\r\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\r\\n            removeFunction(ds, oldFacetAddress, selector);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\r\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\r\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\r\\n        ds.facetAddresses.push(_facetAddress);\\r\\n    }    \\r\\n\\r\\n\\r\\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\\r\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\r\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\r\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\r\\n    }\\r\\n\\r\\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \\r\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\r\\n        // an immutable function is a function defined directly in a diamond\\r\\n        require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\r\\n        // replace selector with last selector, then delete last selector\\r\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\r\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\r\\n        // if not the same then replace _selector with lastSelector\\r\\n        if (selectorPosition != lastSelectorPosition) {\\r\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\r\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\r\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\r\\n        }\\r\\n        // delete the last selector\\r\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\r\\n        delete ds.selectorToFacetAndPosition[_selector];\\r\\n\\r\\n        // if no more selectors for facet address then delete the facet address\\r\\n        if (lastSelectorPosition == 0) {\\r\\n            // replace facet address with last facet address and delete last facet address\\r\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\r\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\r\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\r\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\r\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\r\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\r\\n            }\\r\\n            ds.facetAddresses.pop();\\r\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\r\\n        if (_init == address(0)) {\\r\\n            return;\\r\\n        }\\r\\n        enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");        \\r\\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\\r\\n        if (!success) {\\r\\n            if (error.length > 0) {\\r\\n                // bubble up error\\r\\n                /// @solidity memory-safe-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(error)\\r\\n                    revert(add(32, error), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert InitializationFunctionReverted(_init, _calldata);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\r\\n        uint256 contractSize;\\r\\n        assembly {\\r\\n            contractSize := extcodesize(_contract)\\r\\n        }\\r\\n        require(contractSize > 0, _errorMessage);\\r\\n    }\\r\\n    \\r\\n}\\r\\n\\r\\n\",\"keccak256\":\"0x868d20580f4a8e3d6cb846ab3cf06418c71f74fb00920f6c8188de631d54f118\",\"license\":\"MIT\"},\"contracts/facets/Ownership/LibOwnership.sol\":{\"content\":\"pragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n\\r\\nlibrary LibOwnership {\\r\\nbytes32 constant OWNERSHIP_STORAGE_POSITION = keccak256(\\\"diamond.ownership.storage\\\");\\r\\nuint24 constant MIGRATION_TRANSITION_LOCK_TIMESPAN = 259200; // 3 days\\r\\n\\r\\nstruct OwnershipStorage{\\r\\n    address ecosystemOwner;\\r\\n    address registry;\\r\\n    Migration migration;\\r\\n}\\r\\nstruct Migration{\\r\\n    bool isMigrating;\\r\\n    uint32 initiationTimestamp;\\r\\n}\\r\\n\\r\\nfunction ownershipStorage() internal pure returns (OwnershipStorage storage os) {\\r\\n        bytes32 position = OWNERSHIP_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            os.slot := position \\r\\n        }\\r\\n    }\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n        Should never be used outside of iOwnership.sol (exception for the initial diamond constructor)\\r\\n        @notice Sets the owner of this ecosystem\\r\\n        @param _newEcosystemOwner  new ecosystem owner \\r\\n     */\\r\\n    function _setEcosystemOwner(address _newEcosystemOwner) internal {\\r\\n        OwnershipStorage storage os = ownershipStorage();\\r\\n        address previousOwner = os.ecosystemOwner;\\r\\n        os.ecosystemOwner = _newEcosystemOwner;\\r\\n        emit OwnershipTransferred(previousOwner, _newEcosystemOwner);\\r\\n    }\\r\\n\\r\\n    function _ecosystemOwner() internal view returns (address ecosystemOwner_) {\\r\\n        ecosystemOwner_ = ownershipStorage().ecosystemOwner;\\r\\n    }\\r\\n\\r\\n    function _setRegistry(address _registry) internal {\\r\\n        OwnershipStorage storage os = ownershipStorage();\\r\\n        os.registry = _registry;\\r\\n    }\\r\\n    function _getRegistry() internal view returns (address registry_) {\\r\\n        OwnershipStorage storage os = ownershipStorage();\\r\\n        registry_ = os.registry;\\r\\n    }\\r\\n    \\r\\n    \\r\\n} \",\"keccak256\":\"0x424fd62131dbaccfa06ef6f6deb4e1ef1d75db9d9e0908c864faff0e1d52099e\"},\"contracts/facets/Stake/IStake.sol\":{\"content\":\"pragma solidity ^0.8.9;\\r\\n\\r\\ninterface IStake{\\r\\n\\r\\n    enum StakeTier {Continious, SevenDay, FourteenDay, TwentyEightDay} \\r\\n    struct RewardRate{\\r\\n        uint16 initialRate;\\r\\n        uint16 rateIncrease;\\r\\n        uint16 rateIncreaseStopDuration;\\r\\n    }\\r\\n\\r\\n    struct StakePosition{\\r\\n        address user;\\r\\n        uint256 amount;\\r\\n        StakeTier tier;\\r\\n        uint32 startTime;\\r\\n    }\\r\\n    \\r\\n    function fundStakeAccount(uint256 amount) external;\\r\\n    function stake( uint256 amount, StakeTier tier, uint256 stakeId) external;\\r\\n    function stakeContract( address user, uint256 amount, StakeTier tier, uint256 stakeId) external;\\r\\n    function stakeVirtual(address staker, uint256 amount, StakeTier tier, uint256 stakeId) external;\\r\\n    function batchStake( address[] memory user, uint256[] memory amount, StakeTier[] memory tier, uint256[] memory stakeIds) external;\\r\\n    function setRewardRates(StakeTier[] memory _stakeTier, RewardRate[] memory _rewardRate) external;\\r\\n    function unstake( uint256 amount, uint256 stakeId) external;\\r\\n    function unstakeContract(address user, uint256 amount, uint256 stakeId) external returns(uint256);\\r\\n    function unstakeVirtual(address staker, uint256 amount, uint256 stakeId) external;\\r\\n    function getGasStakeFee() external returns ( uint24, uint24 );\\r\\n    \\r\\n}\",\"keccak256\":\"0x709dd4ad6e87a794937ccd0eb8e78b2f7085bfbcb8c9f7eab149290c2e1e6153\"},\"contracts/upgradeInitializers/DiamondInit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\r\\n*\\r\\n* Implementation of a diamond.\\r\\n/******************************************************************************/\\r\\n\\r\\nimport {LibDiamond} from \\\"../facets/Diamond/LibDiamond.sol\\\";\\r\\nimport { IDiamondLoupe } from \\\"../facets/Diamond/IDiamondLoupe.sol\\\";\\r\\nimport { IDiamondCut } from \\\"../facets/Diamond/IDiamondCut.sol\\\";\\r\\nimport { IERC173 } from \\\"../IERC173.sol\\\";\\r\\nimport { IERC165 } from \\\"../IERC165.sol\\\";\\r\\nimport { IStake } from \\\"../facets/Stake/IStake.sol\\\";\\r\\nimport { IStake } from \\\"../facets/Stake/IStake.sol\\\";\\r\\n\\r\\n\\r\\n// It is expected that this contract is customized if you want to deploy your diamond\\r\\n// with data from a deployment script. Use the init function to initialize state variables\\r\\n// of your diamond. Add parameters to the init funciton if you need to.\\r\\n\\r\\ncontract DiamondInit {    \\r\\n\\r\\n    // You can add parameters to this function in order to pass in \\r\\n    // data to set your own state variables\\r\\n    function init() external {\\r\\n        // adding ERC165 data\\r\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\r\\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\\r\\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\\r\\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\\r\\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\\r\\n        ds.supportedInterfaces[type(IStake).interfaceId] = true;\\r\\n\\r\\n        // add your own state variables \\r\\n        // EIP-2535 specifies that the `diamondCut` function takes two optional \\r\\n        // arguments: address _init and bytes calldata _calldata\\r\\n        // These arguments are used to execute an arbitrary function using delegatecall\\r\\n        // in order to set state variables in the diamond during deployment or an upgrade\\r\\n        // More info here: https://eips.ethereum.org/EIPS/eip-2535#diamond-interface \\r\\n    }\\r\\n\\r\\n\\r\\n}\\r\\n\",\"keccak256\":\"0x5f095eb312fad91fb76eec90f278cfe014386d4fca3f7e1f3fddb4b3d39cba5f\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6080604052348015600e575f5ffd5b5061016e8061001c5f395ff3fe608060405234801561000f575f5ffd5b5060043610610029575f3560e01c8063e1c7392a1461002d575b5f5ffd5b6101367fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131f6020527f699d9daa71b280d05a152715774afa0a81a312594b2d731d6b0b2552b7d6f69f8054600160ff1991821681179092557ff97e938d8af42f52387bb74b8b526fda8f184cc2aa534340a8d75a88fbecc77580548216831790557f65d510a5d8f7ef134ec444f7f34ee808c8eeb5177cdfd16be0c40fe1ab43369580548216831790557f5622121b47b8cd0120c4efe45dd5483242f54a3d49bd7679be565d47694918c38054821683179055632444e55160e21b5f527ff67fcea9b5bce34e31d67109bf05edfb565d41216b0004b5658f701e961765bc80549091169091179055565b00fea26469706673582212209f98e8db7c5cd3ac7f96c1d5d9db6097a501fe0ffa504ab6a799043f6d8a8cd164736f6c634300081c0033",
  "deployedBytecode": "0x608060405234801561000f575f5ffd5b5060043610610029575f3560e01c8063e1c7392a1461002d575b5f5ffd5b6101367fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131f6020527f699d9daa71b280d05a152715774afa0a81a312594b2d731d6b0b2552b7d6f69f8054600160ff1991821681179092557ff97e938d8af42f52387bb74b8b526fda8f184cc2aa534340a8d75a88fbecc77580548216831790557f65d510a5d8f7ef134ec444f7f34ee808c8eeb5177cdfd16be0c40fe1ab43369580548216831790557f5622121b47b8cd0120c4efe45dd5483242f54a3d49bd7679be565d47694918c38054821683179055632444e55160e21b5f527ff67fcea9b5bce34e31d67109bf05edfb565d41216b0004b5658f701e961765bc80549091169091179055565b00fea26469706673582212209f98e8db7c5cd3ac7f96c1d5d9db6097a501fe0ffa504ab6a799043f6d8a8cd164736f6c634300081c0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}