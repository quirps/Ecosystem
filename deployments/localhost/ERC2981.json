{
  "address": "0x471D34cBA4dDad233B6a563Fca774a74bFa3EA4E",
  "abi": [
    {
      "inputs": [],
      "name": "MigrationAlreadyCompleted",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MigrationAlreadyInitiated",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MigrationNotInitiated",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "cancellor",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "timeCancelled",
          "type": "uint32"
        }
      ],
      "name": "MigrationCancelled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "initiatior",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "timeInitiatied",
          "type": "uint32"
        }
      ],
      "name": "MigrationInitiated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldOwner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "salePrice",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "royaltyAmount",
          "type": "uint256"
        }
      ],
      "name": "RoyaltyFeeAccessed",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "salePrice",
          "type": "uint256"
        }
      ],
      "name": "royaltyInfo",
      "outputs": [
        {
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "royaltyAmount",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xf5da617489aa3c64df4feaa528525226e64f680c9fbf2191599ed4f84b029cc1",
  "receipt": {
    "to": null,
    "from": "0x1a47C1D6d5B47048536f1111C854e48fA9D76fdF",
    "contractAddress": "0x471D34cBA4dDad233B6a563Fca774a74bFa3EA4E",
    "transactionIndex": 0,
    "gasUsed": "191275",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xc91d013bce89213524a8219d56e3bb8a854b496ace8222f53446a767cdaa50fa",
    "transactionHash": "0xf5da617489aa3c64df4feaa528525226e64f680c9fbf2191599ed4f84b029cc1",
    "logs": [],
    "blockNumber": 31,
    "cumulativeGasUsed": "191275",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "54a7063fbd1377e55e2032f74c4aa199",
  "metadata": "{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"MigrationAlreadyCompleted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MigrationAlreadyInitiated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MigrationNotInitiated\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cancellor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"timeCancelled\",\"type\":\"uint32\"}],\"name\":\"MigrationCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"initiatior\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"timeInitiatied\",\"type\":\"uint32\"}],\"name\":\"MigrationInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"royaltyAmount\",\"type\":\"uint256\"}],\"name\":\"RoyaltyFeeAccessed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/facets/ERC2981/ERC2981.sol\":\"ERC2981\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/facets/ERC2771Recipient/LibERC2771Recipient.sol\":{\"content\":\"// LibEventStorage.sol\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n\\r\\nlibrary LibERC2771Recipient {\\r\\n    bytes32 constant STORAGE_POSITION = keccak256(\\\"diamond.storage.ERC2771Recipient\\\");\\r\\n\\r\\n   \\r\\n    struct ERC2771RecipientStorage {\\r\\n        address trustedForwarder;\\r\\n    }\\r\\n\\r\\n    function erc2771RecipientStorage() internal pure returns ( ERC2771RecipientStorage storage es) {\\r\\n        bytes32 position = STORAGE_POSITION;\\r\\n        assembly {\\r\\n            es.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n   function __getTrustedForwarder() internal  view returns (address trustedForwarder_){\\r\\n       ERC2771RecipientStorage storage es =  erc2771RecipientStorage();\\r\\n        trustedForwarder_ =  es.trustedForwarder;\\r\\n    }\\r\\n\\r\\n    function __setTrustedForwarder(address _forwarder) internal {\\r\\n        ERC2771RecipientStorage storage es =  erc2771RecipientStorage();\\r\\n        es.trustedForwarder = _forwarder; \\r\\n    }\\r\\n \\r\\n  \\r\\n    function _isTrustedForwarder(address forwarder) public  view returns(bool) {\\r\\n        ERC2771RecipientStorage storage es =  erc2771RecipientStorage();\\r\\n        return forwarder == es.trustedForwarder;\\r\\n    }\\r\\n \\r\\n    \\r\\n    function _msgSender() internal  view returns (address ret) {\\r\\n        if (msg.data.length >= 20 && _isTrustedForwarder(msg.sender)) {\\r\\n            // At this point we know that the sender is a trusted forwarder,\\r\\n            // so we trust that the last bytes of msg.data are the verified sender address.\\r\\n            // extract sender address from the end of msg.data\\r\\n            assembly {\\r\\n                ret := shr(96,calldataload(sub(calldatasize(),20)))\\r\\n            }\\r\\n        } else {\\r\\n            ret = msg.sender;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \\r\\n    function _msgData() internal  view returns (bytes calldata ret) {\\r\\n        if (msg.data.length >= 20 && _isTrustedForwarder(msg.sender)) {\\r\\n            return msg.data[0:msg.data.length-20];\\r\\n        } else {\\r\\n            return msg.data;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x6ff10e2f12c8a61f2ae6ff642711976888a210d309d0e03885193162664330cb\"},\"contracts/facets/ERC2771Recipient/_ERC2771Recipient.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// solhint-disable no-inline-assembly\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\n\\r\\n\\r\\nimport { LibERC2771Recipient } from \\\"./LibERC2771Recipient.sol\\\";  \\r\\n/**\\r\\n * @title The ERC-2771 Recipient Base Abstract Class - Implementation\\r\\n *\\r\\n * @notice Note that this contract was called `BaseRelayRecipient` in the previous revision of the GSN.\\r\\n *\\r\\n * @notice A base contract to be inherited by any contract that want to receive relayed transactions.\\r\\n *\\r\\n * @notice A subclass must use `_msgSender()` instead of `msg.sender`.\\r\\n */\\r\\ncontract iERC2771Recipient {\\r\\n \\r\\n    /*\\r\\n     * Forwarder singleton we accept calls from\\r\\n     */\\r\\n     \\r\\n    \\r\\n\\r\\n    function _getTrustedForwarder() internal  view returns (address forwarder){\\r\\n        return LibERC2771Recipient.__getTrustedForwarder();\\r\\n    }\\r\\n\\r\\n    function _setTrustedForwarder(address _forwarder) internal {\\r\\n        LibERC2771Recipient.__setTrustedForwarder(_forwarder); \\r\\n    }\\r\\n  \\r\\n  \\r\\n    function _isTrustedForwarder(address forwarder) internal  view returns(bool) {\\r\\n        return LibERC2771Recipient._isTrustedForwarder(forwarder);\\r\\n    } \\r\\n\\r\\n    \\r\\n    function msgSender() internal  view returns (address ret_) {\\r\\n        ret_ = LibERC2771Recipient._msgSender();\\r\\n    }\\r\\n    \\r\\n    function msgData() internal  view returns (bytes calldata ret_) {\\r\\n        ret_ = LibERC2771Recipient._msgData();\\r\\n    }\\r\\n}\",\"keccak256\":\"0x0a097bedc1831e582bf1b64b8406b71a3441ed6f9d09b12874821b94d3ce9a88\",\"license\":\"MIT\"},\"contracts/facets/ERC2981/ERC2981.sol\":{\"content\":\"pragma solidity ^0.8.28;\\r\\n\\r\\nimport { LibERC2981 } from \\\"./LibERC2981.sol\\\";   \\r\\nimport { iERC2981 } from \\\"./_ERC2981.sol\\\";\\r\\ncontract ERC2981 is iERC2981{\\r\\n    function royaltyInfo(\\r\\n        uint256 tokenId,\\r\\n        uint256 salePrice\\r\\n    ) external  returns (address receiver, uint256 royaltyAmount) {\\r\\n       _royaltyInfo(tokenId, salePrice);\\r\\n    }\\r\\n}\",\"keccak256\":\"0x082896b24c2d290251f22bbcb1a69582b5ed4d0634f97bc42b3bcb5a11433803\"},\"contracts/facets/ERC2981/LibERC2981.sol\":{\"content\":\"pragma solidity ^0.8.28;\\r\\nlibrary LibERC2981 {\\r\\n    \\r\\n    bytes32 constant STORAGE_ERC2981 = \\\"diamond.storage.ERC2981\\\";\\r\\n\\r\\n    struct ERC2981Storage {\\r\\n        mapping(uint256 => uint256) royaltyFee; // tokenId -> royaltyFee\\r\\n    } \\r\\n\\r\\n    function erc2981torage() internal pure returns (ERC2981Storage storage es_) {\\r\\n        bytes32 storagePosition = STORAGE_ERC2981;\\r\\n        assembly {\\r\\n            es_.slot := storagePosition\\r\\n        }\\r\\n    }\\r\\n}\",\"keccak256\":\"0x9aeac4342110d7947428c42e764d278fcc92bea02c19fbad67171ce53374d442\"},\"contracts/facets/ERC2981/_ERC2981.sol\":{\"content\":\"pragma solidity ^0.8.28;\\r\\n\\r\\nimport { LibERC2981 } from \\\"./LibERC2981.sol\\\";   \\r\\nimport { iOwnership } from \\\"../Ownership/_Ownership.sol\\\"; \\r\\nimport { LibERC1155TransferConstraints } from \\\"../Tokens/ERC1155/libraries/LibERC1155TransferConstraints.sol\\\";\\r\\ncontract iERC2981 is iOwnership{\\r\\n    event RoyaltyFeeAccessed( address sender, uint256 tokenId, uint256 salePrice, uint256 royaltyAmount);\\r\\n      // EIP-2981 royalty info\\r\\n    function _royaltyInfo(\\r\\n        uint256 tokenId,\\r\\n        uint256 salePrice\\r\\n    ) internal  returns (address receiver, uint256 royaltyAmount) {\\r\\n        LibERC1155TransferConstraints.ConstraintStorage storage cs = \\r\\n        LibERC1155TransferConstraints.erc1155ConstraintStorage();\\r\\n        \\r\\n        uint256 _royalteFee = cs.royaltyFee[ tokenId ];  \\r\\n   \\r\\n        receiver = _ecosystemOwner();\\r\\n        royaltyAmount = ( salePrice * _royalteFee ) / 100000; // Basis points calculation\\r\\n        \\r\\n        emit RoyaltyFeeAccessed(msgSender(), tokenId, salePrice, royaltyAmount); \\r\\n    }\\r\\n}\",\"keccak256\":\"0x9b9d8222d5572e52286161a7dae45743f2f8aa7ca0fbd7a5206c2ddc55308842\"},\"contracts/facets/MemberLevel/LibMemberLevel.sol\":{\"content\":\"pragma solidity ^0.8.6;\\r\\n\\r\\nimport \\\"../../libraries/utils/Incrementer.sol\\\"; \\r\\n\\r\\n/**\\r\\n    user level history keys are designed to be unique by following the program of\\r\\n    using 8 bytes for the total history length ~1E19 for the highest order 8 bytes \\r\\n    and the lowest order 20 bytes for their address (28 byte total)\\r\\n\\r\\n    Why use a key when can just use uint96 for level history max index?\\r\\n */\\r\\nlibrary LibMemberLevel {\\r\\n    using Incrementer for bytes28;\\r\\n    using Incrementer for bytes8;\\r\\n    bytes32 constant MEMBER_STORAGE_POSITION = keccak256(\\\"diamond.standard.members.storage\\\");\\r\\n    struct MemberLevelStorage {\\r\\n        mapping( address => MemberLevel ) memberLevel; // level history \\r\\n        bytes32 merkleRoot;\\r\\n    }\\r\\n\\r\\n    struct Leaf {\\r\\n        address memberAddress;\\r\\n        uint32 level;\\r\\n        uint32 timestamp;\\r\\n    }\\r\\n\\r\\n    struct MemberLevel{\\r\\n        uint32 timestamp;\\r\\n        uint32 level;\\r\\n    }\\r\\n    \\r\\n    type level is uint32;\\r\\n\\r\\n    function memberLevelStorage() internal pure returns (MemberLevelStorage storage ms_) { \\r\\n        bytes32 position = MEMBER_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ms_.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function permissionedChangeLevel( uint32 _level, address member) internal {\\r\\n        MemberLevelStorage storage ms = memberLevelStorage();\\r\\n        ms.memberLevel[ member ] = MemberLevel( uint32( block.timestamp ), _level ); \\r\\n    }\\r\\n  \\r\\n \\r\\n}\\r\\n\",\"keccak256\":\"0x7cefbdd11110e035371d6352310286b00867ab055242b358edbd9bb7c027ca95\"},\"contracts/facets/Ownership/LibOwnership.sol\":{\"content\":\"pragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n\\r\\nlibrary LibOwnership {\\r\\nbytes32 constant OWNERSHIP_STORAGE_POSITION = keccak256(\\\"diamond.ownership.storage\\\");\\r\\nuint24 constant MIGRATION_TRANSITION_LOCK_TIMESPAN = 259200; // 3 days\\r\\n\\r\\nstruct OwnershipStorage{\\r\\n    address ecosystemOwner;\\r\\n    address registry;\\r\\n    Migration migration;\\r\\n}\\r\\nstruct Migration{\\r\\n    bool isMigrating;\\r\\n    uint32 initiationTimestamp;\\r\\n}\\r\\n\\r\\nfunction ownershipStorage() internal pure returns (OwnershipStorage storage os) {\\r\\n        bytes32 position = OWNERSHIP_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            os.slot := position \\r\\n        }\\r\\n    }\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n        Should never be used outside of iOwnership.sol (exception for the initial diamond constructor)\\r\\n        @notice Sets the owner of this ecosystem\\r\\n        @param _newEcosystemOwner  new ecosystem owner \\r\\n     */\\r\\n    function _setEcosystemOwner(address _newEcosystemOwner) internal {\\r\\n        OwnershipStorage storage os = ownershipStorage();\\r\\n        address previousOwner = os.ecosystemOwner;\\r\\n        os.ecosystemOwner = _newEcosystemOwner;\\r\\n        emit OwnershipTransferred(previousOwner, _newEcosystemOwner);\\r\\n    }\\r\\n\\r\\n    function _ecosystemOwner() internal view returns (address ecosystemOwner_) {\\r\\n        ecosystemOwner_ = ownershipStorage().ecosystemOwner;\\r\\n    }\\r\\n\\r\\n    function _setRegistry(address _registry) internal {\\r\\n        OwnershipStorage storage os = ownershipStorage();\\r\\n        os.registry = _registry;\\r\\n    }\\r\\n    function _getRegistry() internal view returns (address registry_) {\\r\\n        OwnershipStorage storage os = ownershipStorage();\\r\\n        registry_ = os.registry;\\r\\n    }\\r\\n    \\r\\n    \\r\\n} \",\"keccak256\":\"0x424fd62131dbaccfa06ef6f6deb4e1ef1d75db9d9e0908c864faff0e1d52099e\"},\"contracts/facets/Ownership/_Ownership.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {LibOwnership} from \\\"./LibOwnership.sol\\\";\\r\\nimport {iERC2771Recipient} from \\\"../ERC2771Recipient/_ERC2771Recipient.sol\\\";     \\r\\n\\r\\ncontract iOwnership is iERC2771Recipient {\\r\\n    error MigrationAlreadyInitiated();\\r\\n    error MigrationAlreadyCompleted();\\r\\n    error MigrationNotInitiated();\\r\\n\\r\\n    event MigrationInitiated(address initiatior, uint32 timeInitiatied);\\r\\n    event MigrationCancelled(address cancellor, uint32 timeCancelled);\\r\\n    event OwnershipChanged(address oldOwner, address newOwner); \\r\\n    modifier onlyOwner(){\\r\\n        msgSender() == _ecosystemOwner();\\r\\n        _;\\r\\n    }\\r\\n    function _setEcosystemOwner( address _newOwner) internal {\\r\\n        isEcosystemOwnerVerification();\\r\\n        LibOwnership._setEcosystemOwner(_newOwner);\\r\\n    }\\r\\n\\r\\n    function _ecosystemOwner() internal view returns (address owner_) {\\r\\n        owner_ = LibOwnership._ecosystemOwner();\\r\\n    }\\r\\n\\r\\n    function isEcosystemOwnerVerification() internal view {\\r\\n        require( msgSender() == _ecosystemOwner(), \\\"Must be the Ecosystem owner\\\"); \\r\\n    }\\r\\n    \\r\\n\\r\\n    //Migration related methods\\r\\n\\r\\n    /**\\r\\n     * @dev sole purpose is to restrict user from having access to ecosystem modularity\\r\\n     * until they initiate a migration. only modular changes are done via registry until\\r\\n     * then. \\r\\n     */\\r\\n    function isEffectiveOwner() internal view {\\r\\n        LibOwnership.OwnershipStorage storage os = LibOwnership.ownershipStorage();\\r\\n        LibOwnership.Migration storage _migration = os.migration;\\r\\n        if( _migration.isMigrating && isMigrationPeriodOver( _migration.initiationTimestamp ) ){\\r\\n            require( msgSender() == os.ecosystemOwner, \\\"Sender must be the owner.\\\");\\r\\n        }\\r\\n        else{\\r\\n            require(msgSender() == os.registry, \\\"Sender must be from the registry.\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \\r\\n    /**\\r\\n     * @dev start the migration \\r\\n     */\\r\\n    function _initiateMigration() internal {\\r\\n        LibOwnership.OwnershipStorage storage os = LibOwnership.ownershipStorage();\\r\\n        LibOwnership.Migration storage _migration = os.migration;\\r\\n        if( _migration.isMigrating ){\\r\\n            revert MigrationAlreadyInitiated();\\r\\n        }\\r\\n        else{\\r\\n            _migration.isMigrating = true;\\r\\n            _migration.initiationTimestamp = uint32(block.timestamp);\\r\\n            emit MigrationInitiated(msgSender(), uint32(block.timestamp) );\\r\\n        } \\r\\n    }\\r\\n    function _cancelMigration() internal {\\r\\n        LibOwnership.OwnershipStorage storage os = LibOwnership.ownershipStorage();\\r\\n        LibOwnership.Migration storage _migration = os.migration;\\r\\n        uint32 _initiationTimestamp = _migration.initiationTimestamp;\\r\\n        if( _migration.isMigrating  ) {\\r\\n            if(isMigrationPeriodOver( _initiationTimestamp )){\\r\\n                revert MigrationAlreadyCompleted();\\r\\n            }\\r\\n            else{\\r\\n                _migration.isMigrating = false;\\r\\n                emit MigrationCancelled(msgSender(), uint32(block.timestamp));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            revert MigrationNotInitiated();\\r\\n        }\\r\\n        \\r\\n    }\\r\\n    function isMigrationPeriodOver( uint32 _initiationTimestamp ) internal view returns (bool isOver_){\\r\\n        isOver_ = uint32(block.timestamp) + LibOwnership.MIGRATION_TRANSITION_LOCK_TIMESPAN > _initiationTimestamp;\\r\\n    }\\r\\n}\\r\\n \",\"keccak256\":\"0x3fa7c0716afb600bfa154cef5596f51bb7a707b1d394648498ff24e35731f0ba\",\"license\":\"MIT\"},\"contracts/facets/Tokens/ERC1155/libraries/LibERC1155TransferConstraints.sol\":{\"content\":\"pragma solidity ^0.8.9; \\r\\n\\r\\nimport {LibMemberLevel } from \\\"../../../MemberLevel/LibMemberLevel.sol\\\"; \\r\\nlibrary LibERC1155TransferConstraints{\\r\\n    bytes32 constant ERC1155_CONSTRAINT_STORAGE_POSITION = keccak256(\\\"diamond.erc1155constraints\\\");\\r\\n\\r\\nstruct ConstraintStorage{\\r\\n    mapping(uint256 => uint256) tranfserLimit; \\r\\n    mapping(uint256 => uint32) minimumMemberLevel; \\r\\n    mapping(uint256 => uint32) expireTime;\\r\\n    mapping(uint256 => uint24) royaltyFee;\\r\\n    mapping(uint128  => uint128) ticketIntervalNonce;\\r\\n} \\r\\n \\r\\nfunction erc1155ConstraintStorage() internal pure returns (ConstraintStorage storage cs) {\\r\\n        bytes32 position = ERC1155_CONSTRAINT_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            cs.slot := position \\r\\n        }  \\r\\n    }\\r\\n    uint256 constant INTERVAL_SIZE = 2**128; \\r\\n    uint256 constant NUMBER_INTERVALS = 2**128; // max 60 constraints\\r\\n    uint8 constant CURRENT_MAX_INTERVALS = 8;\\r\\n    struct Constraints{\\r\\n        TransferLimit transferLimit;\\r\\n        MemberLevelDependency minimumMembershipLevel;\\r\\n        Expireable expireable;\\r\\n        RoyaltyFee royaltyFee;\\r\\n    }\\r\\n    struct MaxAmount{\\r\\n        uint256 maxAmount;\\r\\n        bool isActive;\\r\\n    }\\r\\n    struct RoyaltyFee{\\r\\n        uint24 fee;\\r\\n        bool isActive;\\r\\n    }\\r\\n    struct TransferLimit{\\r\\n        uint256 maxTransfers;\\r\\n        bool isActive;\\r\\n    }\\r\\n \\r\\n    struct MemberLevelDependency{\\r\\n        uint32 minimumLevel;\\r\\n        bool isActive;\\r\\n    }\\r\\n\\r\\n    //Blacklist contained in MemberRankDependency, rank 0 is blacklist, \\r\\n    //set min rank as 1 or greater\\r\\n    struct Expireable{\\r\\n        uint32 expireTime;\\r\\n        bool isActive;\\r\\n    }\\r\\n\\r\\n    // struct MemberRankTieredDelay{\\r\\n    //     LibMembers.rank minimumRank;\\r\\n    // }\\r\\n}\",\"keccak256\":\"0xfabf69b281e47b53b3a3bb7933315d76746307c9ad7624a363bc2dc7d381bac6\"},\"contracts/libraries/utils/Incrementer.sol\":{\"content\":\"pragma solidity ^0.8.6;\\r\\n\\r\\nlibrary Incrementer {\\r\\n\\r\\n     function decrementKey(bytes28 self) internal pure returns( bytes28 ){\\r\\n        if( bytes8(self)  == bytes8(0) ) {\\r\\n            return self;\\r\\n        }\\r\\n        bytes8 decrementedIndex = bytes8( uint64( bytes8( self ) ) - 1 );\\r\\n        bytes28 decrementedKey = bytes28( abi.encodePacked(decrementedIndex, bytes20( self << 64) ) );\\r\\n        return decrementedKey ;\\r\\n    }\\r\\n    \\r\\n     function incrementKey(bytes28 self) internal pure returns( bytes28 ){\\r\\n        bytes8 decrementedIndex = bytes8( uint64( bytes8( self ) ) + 1 );\\r\\n        bytes28 decrementedKey = bytes28( abi.encodePacked(decrementedIndex, bytes20( self << 64) ) );\\r\\n        return decrementedKey ;\\r\\n    }\\r\\n    function decrementIndex(bytes8 self) internal returns( bytes8 decrementMaxIndex_ ){\\r\\n        decrementMaxIndex_ = bytes8( uint64( self ) - 1 );\\r\\n    }\\r\\n    function incrementIndex(bytes8 self) internal returns( bytes8 incrementMaxIndex_ ){\\r\\n        incrementMaxIndex_ = bytes8( uint64( self ) + 1 );\\r\\n    }\\r\\n}\",\"keccak256\":\"0xfef14fdef8f3de3f0ab8961bc9222df94f51ff451517768109c0cebcd165cd81\"}},\"version\":1}",
  "bytecode": "0x6080604052348015600e575f5ffd5b5061027e8061001c5f395ff3fe608060405234801561000f575f5ffd5b5060043610610029575f3560e01c80632a55205a1461002d575b5f5ffd5b61004061003b3660046101e0565b610063565b604080516001600160a01b03909316835260208301919091520160405180910390f35b5f5f61006f8484610078565b50509250929050565b5f8281527f7a8949a66712f1d1ae515adbd4b0835db540861dfc3638f5ebc928c2d0736d27602052604081205481907f7a8949a66712f1d1ae515adbd4b0835db540861dfc3638f5ebc928c2d0736d249062ffffff166100d6610153565b9350620186a06100e68287610200565b6100f09190610229565b92507f7f77c4eed56195ffbb28b2027ed5ab9327503b3a0bb1e589d1a149d0e2bb33c361011b61018a565b604080516001600160a01b0390921682526020820189905281018790526060810185905260800160405180910390a150509250929050565b5f6101857fd00049dc7109015045860694acecd3dc33338404aaf6e55a1c98a2bf41477b85546001600160a01b031690565b905090565b5f6101855f601436108015906101c957507f413a4c31c13c7c3de0c7da37be5d779b152baf3f21a1cb760fda41eb8ca97776546001600160a01b031633145b156101db575060131936013560601c90565b503390565b5f5f604083850312156101f1575f5ffd5b50508035926020909101359150565b808202811582820484141761022357634e487b7160e01b5f52601160045260245ffd5b92915050565b5f8261024357634e487b7160e01b5f52601260045260245ffd5b50049056fea264697066735822122019cea535de140d162a3ffca009767fdb7853752b63b056dde31f890623a12df764736f6c634300081c0033",
  "deployedBytecode": "0x608060405234801561000f575f5ffd5b5060043610610029575f3560e01c80632a55205a1461002d575b5f5ffd5b61004061003b3660046101e0565b610063565b604080516001600160a01b03909316835260208301919091520160405180910390f35b5f5f61006f8484610078565b50509250929050565b5f8281527f7a8949a66712f1d1ae515adbd4b0835db540861dfc3638f5ebc928c2d0736d27602052604081205481907f7a8949a66712f1d1ae515adbd4b0835db540861dfc3638f5ebc928c2d0736d249062ffffff166100d6610153565b9350620186a06100e68287610200565b6100f09190610229565b92507f7f77c4eed56195ffbb28b2027ed5ab9327503b3a0bb1e589d1a149d0e2bb33c361011b61018a565b604080516001600160a01b0390921682526020820189905281018790526060810185905260800160405180910390a150509250929050565b5f6101857fd00049dc7109015045860694acecd3dc33338404aaf6e55a1c98a2bf41477b85546001600160a01b031690565b905090565b5f6101855f601436108015906101c957507f413a4c31c13c7c3de0c7da37be5d779b152baf3f21a1cb760fda41eb8ca97776546001600160a01b031633145b156101db575060131936013560601c90565b503390565b5f5f604083850312156101f1575f5ffd5b50508035926020909101359150565b808202811582820484141761022357634e487b7160e01b5f52601160045260245ffd5b92915050565b5f8261024357634e487b7160e01b5f52601260045260245ffd5b50049056fea264697066735822122019cea535de140d162a3ffca009767fdb7853752b63b056dde31f890623a12df764736f6c634300081c0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}