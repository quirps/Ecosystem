{
  "address": "0x476aBb8ED04D7091cF8a0F377758f88d49f5fc38",
  "abi": [
    {
      "inputs": [],
      "name": "MigrationAlreadyCompleted",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MigrationAlreadyInitiated",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MigrationNotInitiated",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "ticketId",
          "type": "uint256"
        }
      ],
      "name": "NonTransferableError",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "timestamp",
          "type": "uint32"
        }
      ],
      "name": "MemberBanned",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "memberAddress",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "level",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "timestamp",
              "type": "uint32"
            }
          ],
          "indexed": false,
          "internalType": "struct LibMemberLevel.Leaf",
          "name": "leaf",
          "type": "tuple"
        }
      ],
      "name": "MemberLevelUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "newRoot",
          "type": "bytes32"
        }
      ],
      "name": "MerkleRootUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "cancellor",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "timeCancelled",
          "type": "uint32"
        }
      ],
      "name": "MigrationCancelled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "initiatior",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "timeInitiatied",
          "type": "uint32"
        }
      ],
      "name": "MigrationInitiated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldOwner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "string",
              "name": "title",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "description",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "imageHash",
              "type": "string"
            }
          ],
          "indexed": false,
          "internalType": "struct TicketCreate.TicketMeta",
          "name": "",
          "type": "tuple"
        }
      ],
      "name": "TicketsCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "ids",
          "type": "uint256[]"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "values",
          "type": "uint256[]"
        }
      ],
      "name": "TransferBatch",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "TransferSingle",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "ticketId",
          "type": "uint256"
        }
      ],
      "name": "expireable",
      "outputs": [],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "string",
              "name": "title",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "description",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "imageHash",
              "type": "string"
            }
          ],
          "internalType": "struct TicketCreate.TicketMeta",
          "name": "_ticketMeta",
          "type": "tuple"
        },
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "maxTransfers",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "isActive",
                  "type": "bool"
                }
              ],
              "internalType": "struct LibERC1155TransferConstraints.TransferLimit",
              "name": "transferLimit",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint32",
                  "name": "minimumLevel",
                  "type": "uint32"
                },
                {
                  "internalType": "bool",
                  "name": "isActive",
                  "type": "bool"
                }
              ],
              "internalType": "struct LibERC1155TransferConstraints.MemberLevelDependency",
              "name": "minimumMembershipLevel",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint32",
                  "name": "expireTime",
                  "type": "uint32"
                },
                {
                  "internalType": "bool",
                  "name": "isActive",
                  "type": "bool"
                }
              ],
              "internalType": "struct LibERC1155TransferConstraints.Expireable",
              "name": "expireable",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint24",
                  "name": "fee",
                  "type": "uint24"
                },
                {
                  "internalType": "bool",
                  "name": "isActive",
                  "type": "bool"
                }
              ],
              "internalType": "struct LibERC1155TransferConstraints.RoyaltyFee",
              "name": "royaltyFee",
              "type": "tuple"
            }
          ],
          "internalType": "struct LibERC1155TransferConstraints.Constraints",
          "name": "_constraints",
          "type": "tuple"
        }
      ],
      "name": "ticketCreate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "_amount",
          "type": "uint256[]"
        },
        {
          "components": [
            {
              "internalType": "string",
              "name": "title",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "description",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "imageHash",
              "type": "string"
            }
          ],
          "internalType": "struct TicketCreate.TicketMeta[]",
          "name": "_ticketMeta",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "maxTransfers",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "isActive",
                  "type": "bool"
                }
              ],
              "internalType": "struct LibERC1155TransferConstraints.TransferLimit",
              "name": "transferLimit",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint32",
                  "name": "minimumLevel",
                  "type": "uint32"
                },
                {
                  "internalType": "bool",
                  "name": "isActive",
                  "type": "bool"
                }
              ],
              "internalType": "struct LibERC1155TransferConstraints.MemberLevelDependency",
              "name": "minimumMembershipLevel",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint32",
                  "name": "expireTime",
                  "type": "uint32"
                },
                {
                  "internalType": "bool",
                  "name": "isActive",
                  "type": "bool"
                }
              ],
              "internalType": "struct LibERC1155TransferConstraints.Expireable",
              "name": "expireable",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint24",
                  "name": "fee",
                  "type": "uint24"
                },
                {
                  "internalType": "bool",
                  "name": "isActive",
                  "type": "bool"
                }
              ],
              "internalType": "struct LibERC1155TransferConstraints.RoyaltyFee",
              "name": "royaltyFee",
              "type": "tuple"
            }
          ],
          "internalType": "struct LibERC1155TransferConstraints.Constraints[]",
          "name": "_constraints",
          "type": "tuple[]"
        }
      ],
      "name": "ticketCreateBatch",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xc5411034ad357f1a12a741f310c1672c8a6aded6580f9b46135ef7dab791f9b6",
  "receipt": {
    "to": null,
    "from": "0x1a47C1D6d5B47048536f1111C854e48fA9D76fdF",
    "contractAddress": "0x476aBb8ED04D7091cF8a0F377758f88d49f5fc38",
    "transactionIndex": 0,
    "gasUsed": "944399",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xa50e1ef9196715a2e10577eca6e2b7bc30322302f0c543f40f941f044db4af9b",
    "transactionHash": "0xc5411034ad357f1a12a741f310c1672c8a6aded6580f9b46135ef7dab791f9b6",
    "logs": [],
    "blockNumber": 33,
    "cumulativeGasUsed": "944399",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "54a7063fbd1377e55e2032f74c4aa199",
  "metadata": "{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"MigrationAlreadyCompleted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MigrationAlreadyInitiated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MigrationNotInitiated\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ticketId\",\"type\":\"uint256\"}],\"name\":\"NonTransferableError\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"name\":\"MemberBanned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"level\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"indexed\":false,\"internalType\":\"struct LibMemberLevel.Leaf\",\"name\":\"leaf\",\"type\":\"tuple\"}],\"name\":\"MemberLevelUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"newRoot\",\"type\":\"bytes32\"}],\"name\":\"MerkleRootUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cancellor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"timeCancelled\",\"type\":\"uint32\"}],\"name\":\"MigrationCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"initiatior\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"timeInitiatied\",\"type\":\"uint32\"}],\"name\":\"MigrationInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"title\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"imageHash\",\"type\":\"string\"}],\"indexed\":false,\"internalType\":\"struct TicketCreate.TicketMeta\",\"name\":\"\",\"type\":\"tuple\"}],\"name\":\"TicketsCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ticketId\",\"type\":\"uint256\"}],\"name\":\"expireable\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"title\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"imageHash\",\"type\":\"string\"}],\"internalType\":\"struct TicketCreate.TicketMeta\",\"name\":\"_ticketMeta\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"maxTransfers\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"internalType\":\"struct LibERC1155TransferConstraints.TransferLimit\",\"name\":\"transferLimit\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"minimumLevel\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"internalType\":\"struct LibERC1155TransferConstraints.MemberLevelDependency\",\"name\":\"minimumMembershipLevel\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"expireTime\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"internalType\":\"struct LibERC1155TransferConstraints.Expireable\",\"name\":\"expireable\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"internalType\":\"struct LibERC1155TransferConstraints.RoyaltyFee\",\"name\":\"royaltyFee\",\"type\":\"tuple\"}],\"internalType\":\"struct LibERC1155TransferConstraints.Constraints\",\"name\":\"_constraints\",\"type\":\"tuple\"}],\"name\":\"ticketCreate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_amount\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"title\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"imageHash\",\"type\":\"string\"}],\"internalType\":\"struct TicketCreate.TicketMeta[]\",\"name\":\"_ticketMeta\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"maxTransfers\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"internalType\":\"struct LibERC1155TransferConstraints.TransferLimit\",\"name\":\"transferLimit\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"minimumLevel\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"internalType\":\"struct LibERC1155TransferConstraints.MemberLevelDependency\",\"name\":\"minimumMembershipLevel\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"expireTime\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"internalType\":\"struct LibERC1155TransferConstraints.Expireable\",\"name\":\"expireable\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"internalType\":\"struct LibERC1155TransferConstraints.RoyaltyFee\",\"name\":\"royaltyFee\",\"type\":\"tuple\"}],\"internalType\":\"struct LibERC1155TransferConstraints.Constraints[]\",\"name\":\"_constraints\",\"type\":\"tuple[]\"}],\"name\":\"ticketCreateBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"TransferBatch(address,address,address,uint256[],uint256[])\":{\"details\":\"Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all transfers.\"},\"TransferSingle(address,address,address,uint256,uint256)\":{\"details\":\"Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\"}},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"ticketCreateBatch(uint256[],(string,string,string)[],((uint256,bool),(uint32,bool),(uint32,bool),(uint24,bool))[])\":{\"notice\":\"Owner verification at ticketCreate\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/facets/TicketCreator/TicketCreate.sol\":\"TicketCreate\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/facets/ERC2771Recipient/LibERC2771Recipient.sol\":{\"content\":\"// LibEventStorage.sol\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n\\r\\nlibrary LibERC2771Recipient {\\r\\n    bytes32 constant STORAGE_POSITION = keccak256(\\\"diamond.storage.ERC2771Recipient\\\");\\r\\n\\r\\n   \\r\\n    struct ERC2771RecipientStorage {\\r\\n        address trustedForwarder;\\r\\n    }\\r\\n\\r\\n    function erc2771RecipientStorage() internal pure returns ( ERC2771RecipientStorage storage es) {\\r\\n        bytes32 position = STORAGE_POSITION;\\r\\n        assembly {\\r\\n            es.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n   function __getTrustedForwarder() internal  view returns (address trustedForwarder_){\\r\\n       ERC2771RecipientStorage storage es =  erc2771RecipientStorage();\\r\\n        trustedForwarder_ =  es.trustedForwarder;\\r\\n    }\\r\\n\\r\\n    function __setTrustedForwarder(address _forwarder) internal {\\r\\n        ERC2771RecipientStorage storage es =  erc2771RecipientStorage();\\r\\n        es.trustedForwarder = _forwarder; \\r\\n    }\\r\\n \\r\\n  \\r\\n    function _isTrustedForwarder(address forwarder) public  view returns(bool) {\\r\\n        ERC2771RecipientStorage storage es =  erc2771RecipientStorage();\\r\\n        return forwarder == es.trustedForwarder;\\r\\n    }\\r\\n \\r\\n    \\r\\n    function _msgSender() internal  view returns (address ret) {\\r\\n        if (msg.data.length >= 20 && _isTrustedForwarder(msg.sender)) {\\r\\n            // At this point we know that the sender is a trusted forwarder,\\r\\n            // so we trust that the last bytes of msg.data are the verified sender address.\\r\\n            // extract sender address from the end of msg.data\\r\\n            assembly {\\r\\n                ret := shr(96,calldataload(sub(calldatasize(),20)))\\r\\n            }\\r\\n        } else {\\r\\n            ret = msg.sender;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \\r\\n    function _msgData() internal  view returns (bytes calldata ret) {\\r\\n        if (msg.data.length >= 20 && _isTrustedForwarder(msg.sender)) {\\r\\n            return msg.data[0:msg.data.length-20];\\r\\n        } else {\\r\\n            return msg.data;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x6ff10e2f12c8a61f2ae6ff642711976888a210d309d0e03885193162664330cb\"},\"contracts/facets/ERC2771Recipient/_ERC2771Recipient.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// solhint-disable no-inline-assembly\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\n\\r\\n\\r\\nimport { LibERC2771Recipient } from \\\"./LibERC2771Recipient.sol\\\";  \\r\\n/**\\r\\n * @title The ERC-2771 Recipient Base Abstract Class - Implementation\\r\\n *\\r\\n * @notice Note that this contract was called `BaseRelayRecipient` in the previous revision of the GSN.\\r\\n *\\r\\n * @notice A base contract to be inherited by any contract that want to receive relayed transactions.\\r\\n *\\r\\n * @notice A subclass must use `_msgSender()` instead of `msg.sender`.\\r\\n */\\r\\ncontract iERC2771Recipient {\\r\\n \\r\\n    /*\\r\\n     * Forwarder singleton we accept calls from\\r\\n     */\\r\\n     \\r\\n    \\r\\n\\r\\n    function _getTrustedForwarder() internal  view returns (address forwarder){\\r\\n        return LibERC2771Recipient.__getTrustedForwarder();\\r\\n    }\\r\\n\\r\\n    function _setTrustedForwarder(address _forwarder) internal {\\r\\n        LibERC2771Recipient.__setTrustedForwarder(_forwarder); \\r\\n    }\\r\\n  \\r\\n  \\r\\n    function _isTrustedForwarder(address forwarder) internal  view returns(bool) {\\r\\n        return LibERC2771Recipient._isTrustedForwarder(forwarder);\\r\\n    } \\r\\n\\r\\n    \\r\\n    function msgSender() internal  view returns (address ret_) {\\r\\n        ret_ = LibERC2771Recipient._msgSender();\\r\\n    }\\r\\n    \\r\\n    function msgData() internal  view returns (bytes calldata ret_) {\\r\\n        ret_ = LibERC2771Recipient._msgData();\\r\\n    }\\r\\n}\",\"keccak256\":\"0x0a097bedc1831e582bf1b64b8406b71a3441ed6f9d09b12874821b94d3ce9a88\",\"license\":\"MIT\"},\"contracts/facets/MemberLevel/LibMemberLevel.sol\":{\"content\":\"pragma solidity ^0.8.6;\\r\\n\\r\\nimport \\\"../../libraries/utils/Incrementer.sol\\\"; \\r\\n\\r\\n/**\\r\\n    user level history keys are designed to be unique by following the program of\\r\\n    using 8 bytes for the total history length ~1E19 for the highest order 8 bytes \\r\\n    and the lowest order 20 bytes for their address (28 byte total)\\r\\n\\r\\n    Why use a key when can just use uint96 for level history max index?\\r\\n */\\r\\nlibrary LibMemberLevel {\\r\\n    using Incrementer for bytes28;\\r\\n    using Incrementer for bytes8;\\r\\n    bytes32 constant MEMBER_STORAGE_POSITION = keccak256(\\\"diamond.standard.members.storage\\\");\\r\\n    struct MemberLevelStorage {\\r\\n        mapping( address => MemberLevel ) memberLevel; // level history \\r\\n        bytes32 merkleRoot;\\r\\n    }\\r\\n\\r\\n    struct Leaf {\\r\\n        address memberAddress;\\r\\n        uint32 level;\\r\\n        uint32 timestamp;\\r\\n    }\\r\\n\\r\\n    struct MemberLevel{\\r\\n        uint32 timestamp;\\r\\n        uint32 level;\\r\\n    }\\r\\n    \\r\\n    type level is uint32;\\r\\n\\r\\n    function memberLevelStorage() internal pure returns (MemberLevelStorage storage ms_) { \\r\\n        bytes32 position = MEMBER_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ms_.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function permissionedChangeLevel( uint32 _level, address member) internal {\\r\\n        MemberLevelStorage storage ms = memberLevelStorage();\\r\\n        ms.memberLevel[ member ] = MemberLevel( uint32( block.timestamp ), _level ); \\r\\n    }\\r\\n  \\r\\n \\r\\n}\\r\\n\",\"keccak256\":\"0x7cefbdd11110e035371d6352310286b00867ab055242b358edbd9bb7c027ca95\"},\"contracts/facets/MemberLevel/_Members.sol\":{\"content\":\"pragma solidity ^0.8.9;\\r\\n \\r\\n   \\r\\nimport \\\"./LibMemberLevel.sol\\\";  \\r\\nimport \\\"../../libraries/utils/Incrementer.sol\\\"; \\r\\nimport \\\"../Moderator/LibModerator.sol\\\";  \\r\\nimport \\\"../Moderator/ModeratorModifiers.sol\\\";   \\r\\nimport {iOwnership} from \\\"../Ownership/_Ownership.sol\\\"; \\r\\nimport { LibMemberLevel} from \\\"./LibMemberLevel.sol\\\"; \\r\\n  \\r\\ncontract iMembers is iOwnership {   \\r\\n    event MerkleRootUpdated(bytes32 newRoot);\\r\\n    event MemberLevelUpdated(LibMemberLevel.Leaf leaf);\\r\\n    event MemberBanned(address indexed user, uint32 timestamp); \\r\\n      /**  \\r\\n     * @dev Updates the Merkle root\\r\\n     * @param _merkleRoot New Merkle root to be stored\\r\\n     */\\r\\n     function updateMemberMerkleRoot(bytes32 _merkleRoot) internal  {\\r\\n        isEcosystemOwnerVerification();\\r\\n        LibMemberLevel.MemberLevelStorage storage mrs = LibMemberLevel.memberLevelStorage();\\r\\n        mrs.merkleRoot = _merkleRoot; \\r\\n        emit MerkleRootUpdated(_merkleRoot);\\r\\n    }\\r\\n        /**\\r\\n     * @dev Verifies Merkle proof and sets user's level\\r\\n     * @param _leaf Level to assign to the user\\r\\n     * @param _merkleProof Array of hashed data to verify proof\\r\\n     */ \\r\\n    function _verifyAndSetLevel(LibMemberLevel.Leaf memory _leaf, bytes32[] calldata _merkleProof) internal {\\r\\n        // Create leaf from msg.sender and level\\r\\n        LibMemberLevel.MemberLevelStorage storage mrs = LibMemberLevel.memberLevelStorage();\\r\\n\\r\\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, _leaf.level, _leaf.timestamp));\\r\\n        \\r\\n        require(_verifyMerkleProof(_merkleProof, mrs.merkleRoot, leaf), \\\"Invalid Merkle proof\\\");\\r\\n          \\r\\n        // Set the member level\\r\\n        mrs.memberLevel[msg.sender] = LibMemberLevel.MemberLevel({\\r\\n            level: _leaf.level,\\r\\n            timestamp: _leaf.timestamp\\r\\n        });\\r\\n        \\r\\n        emit MemberLevelUpdated(_leaf);  \\r\\n    }\\r\\n\\r\\n       /**\\r\\n     * @dev Helper function to verify Merkle proofs\\r\\n     */\\r\\n    function _verifyMerkleProof(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\r\\n        bytes32 computedHash = leaf;\\r\\n        \\r\\n        for (uint256 i = 0; i < proof.length; i++) {\\r\\n            bytes32 proofElement = proof[i];\\r\\n            \\r\\n            if (computedHash <= proofElement) {\\r\\n                // Hash(current computed hash + current element of the proof)\\r\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\r\\n            } else {\\r\\n                // Hash(current element of the proof + current computed hash)\\r\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        // Check if the computed hash equals the root of the Merkle tree\\r\\n        return computedHash == root;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Batch set levels for multiple addresses (permissioned function)\\r\\n     * @param _leaves user resource denoting their membership status\\r\\n     *   \\r\\n     */\\r\\n    function _batchSetLevels( LibMemberLevel.Leaf[] calldata _leaves) internal {\\r\\n        isEcosystemOwnerVerification();\\r\\n        LibMemberLevel.MemberLevelStorage storage mrs = LibMemberLevel.memberLevelStorage();\\r\\n        \\r\\n        for (uint256 i = 0; i < _leaves.length; i++) {\\r\\n            LibMemberLevel.Leaf memory _leaf = _leaves[ i ]; \\r\\n            mrs.memberLevel[ _leaf.memberAddress ] = LibMemberLevel.MemberLevel({\\r\\n                level: _leaf.level,\\r\\n                timestamp: _leaf.timestamp\\r\\n            });\\r\\n            \\r\\n            emit MemberLevelUpdated(_leaf);    \\r\\n        }\\r\\n    }\\r\\n\\r\\n     /**\\r\\n     * @dev Returns the level info for a given address\\r\\n     * @param _user Address to query\\r\\n     * @return level and timestamp of the user\\r\\n     */\\r\\n    function _getMemberLevelStruct(address _user) internal view returns (uint32 level, uint32 timestamp) {\\r\\n        LibMemberLevel.MemberLevelStorage storage mrs = LibMemberLevel.memberLevelStorage();\\r\\n        LibMemberLevel.MemberLevel storage memberLevelStruct = mrs.memberLevel[ _user ];\\r\\n        return (memberLevelStruct.level, memberLevelStruct.timestamp);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the level info for a given address\\r\\n     * @param _user Address to query \\r\\n     */\\r\\n    function _getMemberLevel(address _user) internal view returns (uint32 memberLevel_) {\\r\\n        LibMemberLevel.MemberLevelStorage storage mrs = LibMemberLevel.memberLevelStorage();\\r\\n        memberLevel_ = mrs.memberLevel[ _user ].level;  \\r\\n    }\\r\\n    \\r\\n\\r\\n    /**\\r\\n     * @dev Bans a user by setting their level to 0\\r\\n     * @param _user Address of the user to ban\\r\\n     */\\r\\n    function _banMember(address _user) internal onlyOwner {\\r\\n        LibMemberLevel.MemberLevelStorage storage mrs = LibMemberLevel.memberLevelStorage();\\r\\n        uint32 currentTimestamp = uint32(block.timestamp);\\r\\n        \\r\\n        mrs.memberLevel[_user] = LibMemberLevel.MemberLevel({\\r\\n            level: 0,\\r\\n            timestamp: currentTimestamp\\r\\n        });\\r\\n        \\r\\n        emit MemberBanned(_user, currentTimestamp);\\r\\n    }\\r\\n}\\r\\n\\r\\n\",\"keccak256\":\"0x07b9e69ea7f3a83cb7c184802223dac94e1f9ea8631600e15bb0e771bdac7086\"},\"contracts/facets/Moderator/LibModerator.sol\":{\"content\":\"pragma solidity ^0.8.6;\\r\\n\\r\\nlibrary LibModerator{\\r\\n    bytes32 constant MODERATOR_STORAGE_POSITION = keccak256(\\\"diamond.standard.Moderator.storage\\\");\\r\\n    struct Moderator_Storage{\\r\\n        mapping( address => uint8 ) moderatorRank;\\r\\n    }\\r\\n\\r\\n    function moderatorStorage() internal pure returns (Moderator_Storage storage es){\\r\\n        bytes32 Moderator_STORAGE_POSITION = MODERATOR_STORAGE_POSITION;\\r\\n        assembly{\\r\\n            es.slot := Moderator_STORAGE_POSITION\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setModeratorRank(address _moderator, uint8 rank) internal {\\r\\n        moderatorStorage().moderatorRank[ _moderator ] = rank;\\r\\n    }\\r\\n    function getModeratorRank(address _moderator) internal view returns (uint8 rank_) {\\r\\n        rank_ = moderatorStorage().moderatorRank[ _moderator ];\\r\\n    }\\r\\n}\",\"keccak256\":\"0xf25a2532479212be318e406d567a6c55854139cf6b3eee3142ef15375514ef4b\"},\"contracts/facets/Moderator/ModeratorModifiers.sol\":{\"content\":\"pragma solidity ^0.8.9;\\r\\n\\r\\nimport {iERC2771Recipient} from \\\"../ERC2771Recipient/_ERC2771Recipient.sol\\\";    \\r\\nimport \\\"./ModeratorRankConstants.sol\\\";\\r\\nimport \\\"./LibModerator.sol\\\"; \\r\\n\\r\\ncontract ModeratorModifiers is ModeratorRankConstants, iERC2771Recipient {\\r\\n    modifier moderatorMemberPermission(){\\r\\n        require( LibModerator.getModeratorRank( msgSender() ) \\r\\n                 >= MODERATOR_MEMBER_PERMISSIONED ,\\\"MS - Insufficient Priveleges.\\\");\\r\\n        _;\\r\\n    }\\r\\n}\",\"keccak256\":\"0x882815af7f8f780d8ff9839554eaac6d419009daaf3eb5eb0093d61eca9d2332\"},\"contracts/facets/Moderator/ModeratorRankConstants.sol\":{\"content\":\"pragma solidity ^0.8.9;\\r\\n\\r\\ncontract ModeratorRankConstants {\\r\\n    uint8 constant MODERATOR_MEMBER_PERMISSIONED = 200;\\r\\n}\",\"keccak256\":\"0xb901e110b796cbf22309409abb5e9c9b67fd71f39ce98e5d1bdb85f66c03e281\"},\"contracts/facets/Ownership/LibOwnership.sol\":{\"content\":\"pragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n\\r\\nlibrary LibOwnership {\\r\\nbytes32 constant OWNERSHIP_STORAGE_POSITION = keccak256(\\\"diamond.ownership.storage\\\");\\r\\nuint24 constant MIGRATION_TRANSITION_LOCK_TIMESPAN = 259200; // 3 days\\r\\n\\r\\nstruct OwnershipStorage{\\r\\n    address ecosystemOwner;\\r\\n    address registry;\\r\\n    Migration migration;\\r\\n}\\r\\nstruct Migration{\\r\\n    bool isMigrating;\\r\\n    uint32 initiationTimestamp;\\r\\n}\\r\\n\\r\\nfunction ownershipStorage() internal pure returns (OwnershipStorage storage os) {\\r\\n        bytes32 position = OWNERSHIP_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            os.slot := position \\r\\n        }\\r\\n    }\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n        Should never be used outside of iOwnership.sol (exception for the initial diamond constructor)\\r\\n        @notice Sets the owner of this ecosystem\\r\\n        @param _newEcosystemOwner  new ecosystem owner \\r\\n     */\\r\\n    function _setEcosystemOwner(address _newEcosystemOwner) internal {\\r\\n        OwnershipStorage storage os = ownershipStorage();\\r\\n        address previousOwner = os.ecosystemOwner;\\r\\n        os.ecosystemOwner = _newEcosystemOwner;\\r\\n        emit OwnershipTransferred(previousOwner, _newEcosystemOwner);\\r\\n    }\\r\\n\\r\\n    function _ecosystemOwner() internal view returns (address ecosystemOwner_) {\\r\\n        ecosystemOwner_ = ownershipStorage().ecosystemOwner;\\r\\n    }\\r\\n\\r\\n    function _setRegistry(address _registry) internal {\\r\\n        OwnershipStorage storage os = ownershipStorage();\\r\\n        os.registry = _registry;\\r\\n    }\\r\\n    function _getRegistry() internal view returns (address registry_) {\\r\\n        OwnershipStorage storage os = ownershipStorage();\\r\\n        registry_ = os.registry;\\r\\n    }\\r\\n    \\r\\n    \\r\\n} \",\"keccak256\":\"0x424fd62131dbaccfa06ef6f6deb4e1ef1d75db9d9e0908c864faff0e1d52099e\"},\"contracts/facets/Ownership/_Ownership.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {LibOwnership} from \\\"./LibOwnership.sol\\\";\\r\\nimport {iERC2771Recipient} from \\\"../ERC2771Recipient/_ERC2771Recipient.sol\\\";     \\r\\n\\r\\ncontract iOwnership is iERC2771Recipient {\\r\\n    error MigrationAlreadyInitiated();\\r\\n    error MigrationAlreadyCompleted();\\r\\n    error MigrationNotInitiated();\\r\\n\\r\\n    event MigrationInitiated(address initiatior, uint32 timeInitiatied);\\r\\n    event MigrationCancelled(address cancellor, uint32 timeCancelled);\\r\\n    event OwnershipChanged(address oldOwner, address newOwner); \\r\\n    modifier onlyOwner(){\\r\\n        msgSender() == _ecosystemOwner();\\r\\n        _;\\r\\n    }\\r\\n    function _setEcosystemOwner( address _newOwner) internal {\\r\\n        isEcosystemOwnerVerification();\\r\\n        LibOwnership._setEcosystemOwner(_newOwner);\\r\\n    }\\r\\n\\r\\n    function _ecosystemOwner() internal view returns (address owner_) {\\r\\n        owner_ = LibOwnership._ecosystemOwner();\\r\\n    }\\r\\n\\r\\n    function isEcosystemOwnerVerification() internal view {\\r\\n        require( msgSender() == _ecosystemOwner(), \\\"Must be the Ecosystem owner\\\"); \\r\\n    }\\r\\n    \\r\\n\\r\\n    //Migration related methods\\r\\n\\r\\n    /**\\r\\n     * @dev sole purpose is to restrict user from having access to ecosystem modularity\\r\\n     * until they initiate a migration. only modular changes are done via registry until\\r\\n     * then. \\r\\n     */\\r\\n    function isEffectiveOwner() internal view {\\r\\n        LibOwnership.OwnershipStorage storage os = LibOwnership.ownershipStorage();\\r\\n        LibOwnership.Migration storage _migration = os.migration;\\r\\n        if( _migration.isMigrating && isMigrationPeriodOver( _migration.initiationTimestamp ) ){\\r\\n            require( msgSender() == os.ecosystemOwner, \\\"Sender must be the owner.\\\");\\r\\n        }\\r\\n        else{\\r\\n            require(msgSender() == os.registry, \\\"Sender must be from the registry.\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \\r\\n    /**\\r\\n     * @dev start the migration \\r\\n     */\\r\\n    function _initiateMigration() internal {\\r\\n        LibOwnership.OwnershipStorage storage os = LibOwnership.ownershipStorage();\\r\\n        LibOwnership.Migration storage _migration = os.migration;\\r\\n        if( _migration.isMigrating ){\\r\\n            revert MigrationAlreadyInitiated();\\r\\n        }\\r\\n        else{\\r\\n            _migration.isMigrating = true;\\r\\n            _migration.initiationTimestamp = uint32(block.timestamp);\\r\\n            emit MigrationInitiated(msgSender(), uint32(block.timestamp) );\\r\\n        } \\r\\n    }\\r\\n    function _cancelMigration() internal {\\r\\n        LibOwnership.OwnershipStorage storage os = LibOwnership.ownershipStorage();\\r\\n        LibOwnership.Migration storage _migration = os.migration;\\r\\n        uint32 _initiationTimestamp = _migration.initiationTimestamp;\\r\\n        if( _migration.isMigrating  ) {\\r\\n            if(isMigrationPeriodOver( _initiationTimestamp )){\\r\\n                revert MigrationAlreadyCompleted();\\r\\n            }\\r\\n            else{\\r\\n                _migration.isMigrating = false;\\r\\n                emit MigrationCancelled(msgSender(), uint32(block.timestamp));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            revert MigrationNotInitiated();\\r\\n        }\\r\\n        \\r\\n    }\\r\\n    function isMigrationPeriodOver( uint32 _initiationTimestamp ) internal view returns (bool isOver_){\\r\\n        isOver_ = uint32(block.timestamp) + LibOwnership.MIGRATION_TRANSITION_LOCK_TIMESPAN > _initiationTimestamp;\\r\\n    }\\r\\n}\\r\\n \",\"keccak256\":\"0x3fa7c0716afb600bfa154cef5596f51bb7a707b1d394648498ff24e35731f0ba\",\"license\":\"MIT\"},\"contracts/facets/TicketCreator/TicketCreate.sol\":{\"content\":\"pragma solidity ^0.8.9;\\r\\n\\r\\nimport {LibERC1155TransferConstraints} from \\\"../Tokens/ERC1155/libraries/LibERC1155TransferConstraints.sol\\\";\\r\\nimport { iERC1155 } from \\\"../Tokens/ERC1155/internals/iERC1155.sol\\\";\\r\\nimport { iTransferSetConstraints} from \\\"../Tokens/ERC1155/internals/iTransferSetConstraints.sol\\\";\\r\\nimport {iOwnership} from \\\"../Ownership/_Ownership.sol\\\";\\r\\ncontract TicketCreate is iTransferSetConstraints,  iERC1155 {\\r\\n\\r\\n    struct TicketMeta{\\r\\n        string title;\\r\\n        string description; \\r\\n        string imageHash;\\r\\n    } \\r\\n\\r\\n    event TicketsCreated(uint256, uint256, TicketMeta);\\r\\n    /**\\r\\n        Owner verification at ticketCreate\\r\\n     */\\r\\n    function ticketCreateBatch(uint256[] memory _amount, TicketMeta[] memory _ticketMeta, LibERC1155TransferConstraints.Constraints[] memory  _constraints) external {\\r\\n        //check equal lengths\\r\\n        for( uint256 _constraintIndex; _constraintIndex < _constraints.length; _constraintIndex++){\\r\\n            ticketCreate( _amount[_constraintIndex],  _ticketMeta[ _constraintIndex ], _constraints[ _constraintIndex ] );\\r\\n        }\\r\\n    }\\r\\n \\r\\n    //The order of the Constraint struct matches the order of the if statements\\r\\n    //and correspond to the constraint bitmap in ascending order. \\r\\n    function ticketCreate(uint256 _amount, TicketMeta memory _ticketMeta, LibERC1155TransferConstraints.Constraints memory _constraints) public {\\r\\n        isEcosystemOwnerVerification(); \\r\\n        \\r\\n        uint256 ticketId = ticketConstraintHandler(_constraints);\\r\\n\\r\\n        _mint(msgSender(), ticketId, _amount, \\\"\\\");\\r\\n\\r\\n        emit TicketsCreated(ticketId, _amount, _ticketMeta);\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n    So we need to create ids for each ticket. These ids must be in the appropriate range. This range is determined by the ticket type\\r\\n    which is defined by iTicketConstraints\\r\\n */\",\"keccak256\":\"0xdb620ecc4057cf313138d9c9c144832099b33c8c9c96fe6ab4a4b5d375ec30cc\"},\"contracts/facets/Tokens/ERC1155/interfaces/IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev _Available since v3.1._\\r\\n */\\r\\ninterface IERC1155Receiver  {\\r\\n    /**\\r\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\r\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\r\\n     *\\r\\n     * NOTE: To accept the transfer, this must return\\r\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\r\\n     * (i.e. 0xf23a6e61, or its own function selector).\\r\\n     *\\r\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\r\\n     * @param from The address which previously owned the token\\r\\n     * @param id The ID of the token being transferred\\r\\n     * @param value The amount of tokens being transferred\\r\\n     * @param data Additional data with no specified format\\r\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\r\\n     */\\r\\n    function onERC1155Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 id,\\r\\n        uint256 value,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n\\r\\n    /**\\r\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\r\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\r\\n     * been updated.\\r\\n     *\\r\\n     * NOTE: To accept the transfer(s), this must return\\r\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\r\\n     * (i.e. 0xbc197c81, or its own function selector).\\r\\n     *\\r\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\r\\n     * @param from The address which previously owned the token\\r\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\r\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\r\\n     * @param data Additional data with no specified format\\r\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\r\\n     */\\r\\n    function onERC1155BatchReceived(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata values,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n}\\r\\n\",\"keccak256\":\"0x903479627911c42b944018e3af01eecab68fbc134c6002f8fdc21d1626abf762\",\"license\":\"MIT\"},\"contracts/facets/Tokens/ERC1155/interfaces/IERC1155Transfer.sol\":{\"content\":\"pragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\ninterface IERC1155Transfer{\\r\\n\\r\\n\\r\\n /**\\r\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\r\\n     *\\r\\n     * Emits a {TransferSingle} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\r\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\r\\n    \\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\r\\n     *\\r\\n     * Emits a {TransferBatch} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `ids` and `amounts` must have the same length.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata amounts,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n      /**\\r\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `operator` cannot be the caller.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\r\\n     *\\r\\n     * See {setApprovalForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\r\\n\\r\\n}\",\"keccak256\":\"0x1fba6f123b029993faac5769a036f58dd1ea79ce27136031aa2f366e982b0737\"},\"contracts/facets/Tokens/ERC1155/internals/iERC1155.sol\":{\"content\":\"pragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../libraries/LibERC1155.sol\\\";\\r\\nimport \\\"./iERC1155ContractTransfer.sol\\\";\\r\\nimport \\\"../interfaces/IERC1155Transfer.sol\\\";\\r\\nimport \\\"../interfaces/IERC1155Receiver.sol\\\";\\r\\nimport \\\"../../../../libraries/utils/Address.sol\\\";\\r\\n\\r\\nimport {iOwnership} from \\\"../../../Ownership/_Ownership.sol\\\";\\r\\n\\r\\n\\r\\ncontract iERC1155 is iERC1155ContractTransfer, iOwnership {\\r\\n    using Address for address;\\r\\n\\r\\n    /**\\r\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\r\\n     * substitution mechanism\\r\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\r\\n     *\\r\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\r\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\r\\n     * clients with the token type ID.\\r\\n     *\\r\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\r\\n     * interpreted by clients as\\r\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\r\\n     * for token type ID 0x4cce0.\\r\\n     *\\r\\n     * See {uri}.\\r\\n     *\\r\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\r\\n     * this function emits no events.\\r\\n     */\\r\\n    function _setURI(string memory newuri) internal {\\r\\n        LibERC1155.ERC1155Storage storage es = LibERC1155.erc1155Storage();\\r\\n        es.uri = newuri;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\\r\\n     *\\r\\n     * Emits a {TransferSingle} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal {\\r\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\r\\n\\r\\n        LibERC1155.ERC1155Storage storage es = LibERC1155.erc1155Storage();\\r\\n        address operator = msgSender();\\r\\n        uint256[] memory ids = LibERC1155._asSingletonArray(id);\\r\\n        uint256[] memory amounts = LibERC1155._asSingletonArray(amount);\\r\\n\\r\\n        es.balance[id][to] += amount;\\r\\n        es.totalSupply += amount;\\r\\n        emit TransferSingle(operator, address(0), to, id, amount);\\r\\n\\r\\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\r\\n     *\\r\\n     * Emits a {TransferBatch} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `ids` and `amounts` must have the same length.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal {\\r\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\r\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\r\\n        uint256 _totalSupply;\\r\\n        LibERC1155.ERC1155Storage storage es = LibERC1155.erc1155Storage();\\r\\n\\r\\n        address operator = msgSender();\\r\\n\\r\\n        for (uint256 i = 0; i < ids.length; i++) {\\r\\n            es.balance[ids[i]][to] += amounts[i];\\r\\n            _totalSupply += amounts[i];\\r\\n        }\\r\\n        es.totalSupply = _totalSupply;\\r\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\r\\n\\r\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens of token type `id` from `from`\\r\\n     *\\r\\n     * Emits a {TransferSingle} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `from` must have at least `amount` tokens of token type `id`.\\r\\n     */\\r\\n    function _burn(address from, uint256 id, uint256 amount) internal {\\r\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\r\\n\\r\\n        LibERC1155.ERC1155Storage storage es = LibERC1155.erc1155Storage();\\r\\n\\r\\n        address operator = msgSender();\\r\\n        uint256[] memory ids = LibERC1155._asSingletonArray(id);\\r\\n        uint256[] memory amounts = LibERC1155._asSingletonArray(amount);\\r\\n\\r\\n        uint256 fromBalance = es.balance[id][from];\\r\\n        require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\r\\n        require(es.totalSupply >= amount, \\\"Exceeds total supply.\\\");\\r\\n        unchecked {\\r\\n            es.balance[id][from] = fromBalance - amount;\\r\\n            es.totalSupply -= amount;\\r\\n        }\\r\\n\\r\\n        emit TransferSingle(operator, from, address(0), id, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\r\\n     *\\r\\n     * Emits a {TransferBatch} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `ids` and `amounts` must have the same length.\\r\\n     */\\r\\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory amounts) internal {\\r\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\r\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\r\\n\\r\\n        LibERC1155.ERC1155Storage storage es = LibERC1155.erc1155Storage();\\r\\n        address operator = msgSender();\\r\\n\\r\\n        uint256 _totalAmount;\\r\\n        for (uint256 i = 0; i < ids.length; i++) {\\r\\n            uint256 id = ids[i];\\r\\n            uint256 amount = amounts[i];\\r\\n            _totalAmount += amount;\\r\\n\\r\\n            uint256 fromBalance = es.balance[id][from];\\r\\n            require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\r\\n            require(es.totalSupply >= _totalAmount, \\\"Exceeds total supply.\\\");\\r\\n            unchecked {\\r\\n                es.balance[id][from] = fromBalance - amount;\\r\\n            }\\r\\n        }\\r\\n        es.totalSupply -= _totalAmount;\\r\\n\\r\\n        emit TransferBatch(operator, from, address(0), ids, amounts);\\r\\n    }\\r\\n\\r\\n    \\r\\n}\\r\\n\",\"keccak256\":\"0x309447f5d09a0118c953a9cf2089978e7d3d915b343fa106799986933a5bb5bf\"},\"contracts/facets/Tokens/ERC1155/internals/iERC1155ContractTransfer.sol\":{\"content\":\"pragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../interfaces/IERC1155Receiver.sol\\\";\\r\\nimport \\\"../../../../libraries/utils/Address.sol\\\";\\r\\nimport \\\"./iERC1155Receiver.sol\\\";\\r\\n\\r\\n//Safety check for transfers to contracts\\r\\ncontract iERC1155ContractTransfer is iERC1155Receiver {\\r\\n    \\r\\n    using Address for address;\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\r\\n     */\\r\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\r\\n     * transfers.\\r\\n     */\\r\\n   /**\\r\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\r\\n     * transfers.\\r\\n     */\\r\\n    event TransferBatch(\\r\\n        address indexed operator,\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256[] ids,\\r\\n        uint256[] values\\r\\n    );\\r\\n\\r\\n     function _doSafeTransferAcceptanceCheck(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    ) internal {\\r\\n        if (to.isContract()) {\\r\\n            if( to == address(this)){\\r\\n               return;\\r\\n            }\\r\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\r\\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\\r\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\r\\n                }\\r\\n            } catch Error(string memory reason) {\\r\\n                revert(reason);\\r\\n            } catch {\\r\\n                revert(\\\"ERC1155: transfer to non-ERC1155Receiver implementer\\\");\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _doSafeBatchTransferAcceptanceCheck(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) internal {\\r\\n        if (to.isContract()) {\\r\\n            if( to == address(this)){\\r\\n               return;\\r\\n            }\\r\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\r\\n                bytes4 response\\r\\n            ) {\\r\\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\\r\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\r\\n                }\\r\\n            } catch Error(string memory reason) {\\r\\n                revert(reason);\\r\\n            } catch {\\r\\n                revert(\\\"ERC1155: transfer to non-ERC1155Receiver implementer\\\");\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n}\",\"keccak256\":\"0x929836d5a0c4a3961eb6d8c0dbc85213a50dff7fca377dd4df6e5e92832ab352\"},\"contracts/facets/Tokens/ERC1155/internals/iERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev _Available since v3.1._\\r\\n */\\r\\ncontract iERC1155Receiver   {\\r\\n\\r\\n    function _onERC1155Received(\\r\\n    ) internal pure returns (bytes4){\\r\\n        return 0xf23a6e61;\\r\\n    }\\r\\n    function _onERC1155BatchReceived(\\r\\n    ) internal pure returns (bytes4){\\r\\n        return 0xbc197c81;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xbeaf6ce27c1d8a0f9e54061b5cd887071a88a229e9ce742ad51d01e915b5b459\",\"license\":\"MIT\"},\"contracts/facets/Tokens/ERC1155/internals/iTransferSetConstraints.sol\":{\"content\":\"pragma solidity ^0.8.9;\\r\\n\\r\\nimport {LibERC1155TransferConstraints} from \\\"../libraries/LibERC1155TransferConstraints.sol\\\";\\r\\nimport { iOwnership } from \\\"../../../Ownership/_Ownership.sol\\\";\\r\\nimport { iMembers } from \\\"../../../MemberLevel/_Members.sol\\\" ;   \\r\\n/**\\r\\n * @title  \\r\\n * @author \\r\\n * @notice Future update will enable these constraints to have different addresess other than owner \\r\\n */\\r\\ncontract  iTransferSetConstraints is iOwnership, iMembers {\\r\\n    error NonTransferableError(address from, address to, uint256 ticketId);\\r\\n    //Transfer limit only applies to when from is non-zero and not creator and to is not the consumer address\\r\\n    function nonTransferable( address from, address to, uint256 ticketId) internal view {\\r\\n        address _ecosystemOwner = _ecosystemOwner();\\r\\n        if( from == address(0) || from == _ecosystemOwner ){\\r\\n            //pass\\r\\n        }\\r\\n        else if( to == _ecosystemOwner ){  \\r\\n            //pass\\r\\n        }\\r\\n        else{\\r\\n            revert NonTransferableError(from, to, ticketId);    \\r\\n        }\\r\\n        \\r\\n    }\\r\\n    function minimumMembershipLevel(uint256 ticketId, address to) internal view {\\r\\n        LibERC1155TransferConstraints.ConstraintStorage storage cs = \\r\\n        LibERC1155TransferConstraints.erc1155ConstraintStorage();\\r\\n        uint32 _memberLevel = _getMemberLevel( to ); \\r\\n \\r\\n        if( cs.minimumMemberLevel[ ticketId ] > _memberLevel){   \\r\\n            revert(\\\"Member level not sufficient enough for transfer.\\\");\\r\\n        }\\r\\n        return; \\r\\n    }\\r\\n    function expireable(uint256 ticketId) external view{\\r\\n        LibERC1155TransferConstraints.ConstraintStorage storage cs = \\r\\n        LibERC1155TransferConstraints.erc1155ConstraintStorage();\\r\\n        uint32 _expireTime = cs.expireTime[ ticketId ];\\r\\n        require(block.timestamp > _expireTime, \\\"Expired: Deadline for ticket consumption has passed.\\\");\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n   function constraintsEnforce(address from, address to, uint256 _tokenId) internal view {\\r\\n    // Decode bitMap and nonce from tokenId\\r\\n    uint128 bitMap = uint128(_tokenId >> 128);\\r\\n    // uint192 nonce = uint192(_tokenId & type(uint192).max); // Not needed unless used elsewhere\\r\\n\\r\\n    LibERC1155TransferConstraints.ConstraintStorage storage cs = \\r\\n        LibERC1155TransferConstraints.erc1155ConstraintStorage();\\r\\n\\r\\n    // Check Transfer Limit (bit 0)\\r\\n    if ((bitMap & (1 << 0)) != 0) {\\r\\n        uint256 maxTransfers = cs.tranfserLimit[_tokenId]; // Fix typo: tranfserLimit \\u2192 transferLimit\\r\\n        nonTransferable(from, to, _tokenId); // Implement this \\r\\n    }\\r\\n \\r\\n    // Check Minimum Membership Level (bit 1)\\r\\n    if ((bitMap & (1 << 1)) != 0) {\\r\\n        uint256 minRank = cs.minimumMemberLevel[_tokenId];\\r\\n        uint256 senderRank = _getMemberLevel( msgSender() ); // Implement this \\r\\n        require(senderRank >= minRank, \\\"Insufficient membership level\\\");\\r\\n    }\\r\\n\\r\\n    // Check Expiration Time (bit 2)\\r\\n    if ((bitMap & (1 << 2)) != 0) {\\r\\n        uint256 expireTime = cs.expireTime[_tokenId];\\r\\n        require(block.timestamp < expireTime, \\\"Token expired\\\");\\r\\n    }\\r\\n\\r\\n   \\r\\n}\\r\\n/**\\r\\nWould like to clean this function up at some point.\\r\\n */\\r\\n    function ticketConstraintHandler(LibERC1155TransferConstraints.Constraints memory _constraints) internal returns (uint256){\\r\\n        LibERC1155TransferConstraints.ConstraintStorage storage cs = LibERC1155TransferConstraints.erc1155ConstraintStorage();\\r\\n        //check isActive to determine which ticketId interval it's in \\r\\n        uint128 bitMap; \\r\\n        uint128 nonce;\\r\\n        uint128 incrementedNonce;\\r\\n        uint256 ticketId;\\r\\n        if(_constraints.transferLimit.isActive){\\r\\n            //transferLimitConditions set\\r\\n            bitMap ^= (1 << 1);\\r\\n        }\\r\\n        if(_constraints.minimumMembershipLevel.isActive){\\r\\n            //memberRankDependency set\\r\\n            bitMap ^= (1 << 2); \\r\\n        } \\r\\n        if(_constraints.expireable.isActive){ \\r\\n            //expireable set\\r\\n            bitMap ^= (1 << 3);\\r\\n        }\\r\\n        if(_constraints.royaltyFee.isActive){ \\r\\n            //expireable set\\r\\n            bitMap ^= (1 << 4);\\r\\n        }\\r\\n      \\r\\n        \\r\\n        //get nonce\\r\\n        nonce = cs.ticketIntervalNonce[ bitMap ];  \\r\\n        incrementedNonce = nonce + 1;\\r\\n        \\r\\n        //generate ticket id \\r\\n        ticketId = ( nonce ) +  bitMap * LibERC1155TransferConstraints.INTERVAL_SIZE;\\r\\n         \\r\\n       \\r\\n        cs.ticketIntervalNonce[bitMap] = incrementedNonce;\\r\\n        \\r\\n\\r\\n        //store ticket constraints\\r\\n        if(_constraints.transferLimit.isActive){\\r\\n            cs.tranfserLimit[ticketId] = _constraints.transferLimit.maxTransfers;\\r\\n        }\\r\\n        if(_constraints.minimumMembershipLevel.isActive){ \\r\\n            cs.minimumMemberLevel[ticketId] = _constraints.minimumMembershipLevel.minimumLevel;\\r\\n        }   \\r\\n        if(_constraints.expireable.isActive){   \\r\\n            cs.expireTime[ticketId] = _constraints.expireable.expireTime;\\r\\n        } \\r\\n        if(_constraints.expireable.isActive){   \\r\\n            cs.royaltyFee[ticketId] = _constraints.royaltyFee.fee;\\r\\n        } \\r\\n        \\r\\n\\r\\n        return ticketId;\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n */\",\"keccak256\":\"0x494385881fc5a533385e530a2425cad9ef5412fd5697fea806845ddffd066eae\"},\"contracts/facets/Tokens/ERC1155/libraries/LibERC1155.sol\":{\"content\":\"pragma solidity ^0.8.0;\\r\\n\\r\\nlibrary LibERC1155 {\\r\\n    bytes32 constant STORAGE_ERC1155 = \\\"diamond.storage.erc1155\\\";\\r\\n\\r\\n    struct ERC1155Storage {\\r\\n        // Mapping from token ID to account balances\\r\\n        mapping(uint256 => mapping(address => uint256)) balance;\\r\\n        // Mapping from account to operator approvals\\r\\n        mapping(address => mapping(address => bool)) operatorApprovals;\\r\\n        // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\r\\n        string uri;\\r\\n        uint256 totalSupply;\\r\\n    }\\r\\n\\r\\n    function erc1155Storage() internal pure returns (ERC1155Storage storage es_) {\\r\\n        bytes32 erc1155_key = STORAGE_ERC1155;\\r\\n        assembly {\\r\\n            es_.slot := erc1155_key\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getBalance(uint256 tokenId, address user) internal view returns (uint256 balance_) {\\r\\n        ERC1155Storage storage es = erc1155Storage();\\r\\n        balance_ = es.balance[tokenId][user];\\r\\n    }\\r\\n\\r\\n    function getOperatorApproval(address user, address operator) internal view returns (bool approved_) {\\r\\n        ERC1155Storage storage es = erc1155Storage();\\r\\n        approved_ = es.operatorApprovals[user][operator];\\r\\n    }\\r\\n    function _asSingletonArray(uint256 element) internal pure  returns (uint256[] memory) {\\r\\n        uint256[] memory array = new uint256[](1);\\r\\n        array[0] = element;\\r\\n\\r\\n        return array;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x2b0592f9db824744321e8eb08cfed2fb6f7ee07e0acd5d5daf3fc3e4c3318779\"},\"contracts/facets/Tokens/ERC1155/libraries/LibERC1155TransferConstraints.sol\":{\"content\":\"pragma solidity ^0.8.9; \\r\\n\\r\\nimport {LibMemberLevel } from \\\"../../../MemberLevel/LibMemberLevel.sol\\\"; \\r\\nlibrary LibERC1155TransferConstraints{\\r\\n    bytes32 constant ERC1155_CONSTRAINT_STORAGE_POSITION = keccak256(\\\"diamond.erc1155constraints\\\");\\r\\n\\r\\nstruct ConstraintStorage{\\r\\n    mapping(uint256 => uint256) tranfserLimit; \\r\\n    mapping(uint256 => uint32) minimumMemberLevel; \\r\\n    mapping(uint256 => uint32) expireTime;\\r\\n    mapping(uint256 => uint24) royaltyFee;\\r\\n    mapping(uint128  => uint128) ticketIntervalNonce;\\r\\n} \\r\\n \\r\\nfunction erc1155ConstraintStorage() internal pure returns (ConstraintStorage storage cs) {\\r\\n        bytes32 position = ERC1155_CONSTRAINT_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            cs.slot := position \\r\\n        }  \\r\\n    }\\r\\n    uint256 constant INTERVAL_SIZE = 2**128; \\r\\n    uint256 constant NUMBER_INTERVALS = 2**128; // max 60 constraints\\r\\n    uint8 constant CURRENT_MAX_INTERVALS = 8;\\r\\n    struct Constraints{\\r\\n        TransferLimit transferLimit;\\r\\n        MemberLevelDependency minimumMembershipLevel;\\r\\n        Expireable expireable;\\r\\n        RoyaltyFee royaltyFee;\\r\\n    }\\r\\n    struct MaxAmount{\\r\\n        uint256 maxAmount;\\r\\n        bool isActive;\\r\\n    }\\r\\n    struct RoyaltyFee{\\r\\n        uint24 fee;\\r\\n        bool isActive;\\r\\n    }\\r\\n    struct TransferLimit{\\r\\n        uint256 maxTransfers;\\r\\n        bool isActive;\\r\\n    }\\r\\n \\r\\n    struct MemberLevelDependency{\\r\\n        uint32 minimumLevel;\\r\\n        bool isActive;\\r\\n    }\\r\\n\\r\\n    //Blacklist contained in MemberRankDependency, rank 0 is blacklist, \\r\\n    //set min rank as 1 or greater\\r\\n    struct Expireable{\\r\\n        uint32 expireTime;\\r\\n        bool isActive;\\r\\n    }\\r\\n\\r\\n    // struct MemberRankTieredDelay{\\r\\n    //     LibMembers.rank minimumRank;\\r\\n    // }\\r\\n}\",\"keccak256\":\"0xfabf69b281e47b53b3a3bb7933315d76746307c9ad7624a363bc2dc7d381bac6\"},\"contracts/libraries/utils/Address.sol\":{\"content\":\"library Address {\\r\\n\\r\\n    /**\\r\\n     * Returns whether the target address is a contract\\r\\n     * @dev This function will return false if invoked during the constructor of a contract,\\r\\n     * as the code is not actually created until after the constructor finishes.\\r\\n     * @param account address of the account to check\\r\\n     * @return whether the target address is a contract\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        uint256 size;\\r\\n        // XXX Currently there is no better way to check if there is a contract in an address\\r\\n        // than to check the size of the code at that address.\\r\\n        // See https://ethereum.stackexchange.com/a/14016/36603\\r\\n        // for more details about how this works.\\r\\n        // TODO Check this again before the Serenity release, because all addresses will be\\r\\n        // contracts then.\\r\\n        // solium-disable-next-line security/no-inline-assembly\\r\\n        assembly { size := extcodesize(account) }\\r\\n        return size > 0;\\r\\n    }\\r\\n\\r\\n}\",\"keccak256\":\"0x332f7fa5b7e5de602575ce60b90e9f003ef7b6c5f6440064deb33ecca39c04d0\"},\"contracts/libraries/utils/Incrementer.sol\":{\"content\":\"pragma solidity ^0.8.6;\\r\\n\\r\\nlibrary Incrementer {\\r\\n\\r\\n     function decrementKey(bytes28 self) internal pure returns( bytes28 ){\\r\\n        if( bytes8(self)  == bytes8(0) ) {\\r\\n            return self;\\r\\n        }\\r\\n        bytes8 decrementedIndex = bytes8( uint64( bytes8( self ) ) - 1 );\\r\\n        bytes28 decrementedKey = bytes28( abi.encodePacked(decrementedIndex, bytes20( self << 64) ) );\\r\\n        return decrementedKey ;\\r\\n    }\\r\\n    \\r\\n     function incrementKey(bytes28 self) internal pure returns( bytes28 ){\\r\\n        bytes8 decrementedIndex = bytes8( uint64( bytes8( self ) ) + 1 );\\r\\n        bytes28 decrementedKey = bytes28( abi.encodePacked(decrementedIndex, bytes20( self << 64) ) );\\r\\n        return decrementedKey ;\\r\\n    }\\r\\n    function decrementIndex(bytes8 self) internal returns( bytes8 decrementMaxIndex_ ){\\r\\n        decrementMaxIndex_ = bytes8( uint64( self ) - 1 );\\r\\n    }\\r\\n    function incrementIndex(bytes8 self) internal returns( bytes8 incrementMaxIndex_ ){\\r\\n        incrementMaxIndex_ = bytes8( uint64( self ) + 1 );\\r\\n    }\\r\\n}\",\"keccak256\":\"0xfef14fdef8f3de3f0ab8961bc9222df94f51ff451517768109c0cebcd165cd81\"}},\"version\":1}",
  "bytecode": "0x6080604052348015600e575f5ffd5b5061101a8061001c5f395ff3fe608060405234801561000f575f5ffd5b506004361061003f575f3560e01c80632a827fa51461004357806345b5fd721461005857806353930ef51461006b575b5f5ffd5b610056610051366004610c67565b61007e565b005b610056610066366004610d55565b6100ed565b610056610079366004610d6c565b6101b8565b5f5b81518110156100e7576100df84828151811061009e5761009e610dc0565b60200260200101518483815181106100b8576100b8610dc0565b60200260200101518484815181106100d2576100d2610dc0565b60200260200101516101b8565b600101610080565b50505050565b5f8181527f7a8949a66712f1d1ae515adbd4b0835db540861dfc3638f5ebc928c2d0736d2660205260409020547f7a8949a66712f1d1ae515adbd4b0835db540861dfc3638f5ebc928c2d0736d249063ffffffff164281106101b35760405162461bcd60e51b815260206004820152603460248201527f457870697265643a20446561646c696e6520666f72207469636b657420636f6e60448201527339bab6b83a34b7b7103430b9903830b9b9b2b21760611b60648201526084015b60405180910390fd5b505050565b6101c061022e565b5f6101ca8261029f565b90506101ed6101d7610486565b828660405180602001604052805f815250610494565b7fc0d624564782b3ce0a9e225d9beb02c78ffc996dde3bb989385f98da06420e4181858560405161022093929190610e02565b60405180910390a150505050565b6102366105ec565b6001600160a01b0316610247610486565b6001600160a01b03161461029d5760405162461bcd60e51b815260206004820152601b60248201527f4d757374206265207468652045636f73797374656d206f776e6572000000000060448201526064016101aa565b565b5f807f7a8949a66712f1d1ae515adbd4b0835db540861dfc3638f5ebc928c2d0736d2490505f5f5f5f865f015160200151156102dc576002841893505b866020015160200151156102f1576004841893505b86604001516020015115610306576008841893505b8660600151602001511561031b576010841893505b6001600160801b038085165f908152600487016020526040902054169250610344836001610e82565b915061035d600160801b6001600160801b038616610ea7565b610370906001600160801b038516610ebe565b6001600160801b038581165f908152600488016020908152604090912080546fffffffffffffffffffffffffffffffff19169286169290921790915588510151909150156103ca578651515f828152602087905260409020555b8660200151602001511561040757602087810151515f838152600188019092526040909120805463ffffffff191663ffffffff9092169190911790555b8660400151602001511561044357604087810151515f8381526002880160205291909120805463ffffffff191663ffffffff9092169190911790555b8660400151602001511561047c576060870151515f8281526003870160205260409020805462ffffff191662ffffff9092169190911790555b9695505050505050565b5f61048f61061e565b905090565b6001600160a01b0384166104f45760405162461bcd60e51b815260206004820152602160248201527f455243313135353a206d696e7420746f20746865207a65726f206164647265736044820152607360f81b60648201526084016101aa565b7f6469616d6f6e642e73746f726167652e657263313135350000000000000000005f61051e610486565b90505f61052a86610671565b90505f61053686610671565b5f888152602086815260408083206001600160a01b038d16845290915281208054929350889290919061056a908490610ebe565b9250508190555085846003015f8282546105849190610ebe565b909155505060408051888152602081018890526001600160a01b03808b16925f92918716917fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62910160405180910390a46105e2835f8a8a8a8a6106ba565b5050505050505050565b5f61048f7fd00049dc7109015045860694acecd3dc33338404aaf6e55a1c98a2bf41477b85546001600160a01b031690565b5f6014361080159061065957507f413a4c31c13c7c3de0c7da37be5d779b152baf3f21a1cb760fda41eb8ca97776546001600160a01b031633145b1561066b575060131936013560601c90565b50335b90565b6040805160018082528183019092526060915f91906020808301908036833701905050905082815f815181106106a9576106a9610dc0565b602090810291909101015292915050565b6001600160a01b0384163b15610867576001600160a01b03841630146108675760405163f23a6e6160e01b81526001600160a01b0385169063f23a6e619061070e9089908990889088908890600401610ed1565b6020604051808303815f875af1925050508015610748575060408051601f3d908101601f1916820190925261074591810190610f0a565b60015b6107f457610754610f38565b806308c379a00361078d5750610768610f50565b80610773575061078f565b8060405162461bcd60e51b81526004016101aa9190610fd2565b505b60405162461bcd60e51b815260206004820152603460248201527f455243313135353a207472616e7366657220746f206e6f6e2d455243313135356044820152732932b1b2b4bb32b91034b6b83632b6b2b73a32b960611b60648201526084016101aa565b6001600160e01b0319811663f23a6e6160e01b146108655760405162461bcd60e51b815260206004820152602860248201527f455243313135353a204552433131353552656365697665722072656a656374656044820152676420746f6b656e7360c01b60648201526084016101aa565b505b505050505050565b634e487b7160e01b5f52604160045260245ffd5b604081018181106001600160401b03821117156108a2576108a261086f565b60405250565b608081018181106001600160401b03821117156108a2576108a261086f565b601f8201601f191681016001600160401b03811182821017156108ec576108ec61086f565b6040525050565b5f6001600160401b0382111561090b5761090b61086f565b5060051b60200190565b5f82601f830112610924575f5ffd5b81356001600160401b0381111561093d5761093d61086f565b604051610954601f8301601f1916602001826108c7565b818152846020838601011115610968575f5ffd5b816020850160208301375f918101602001919091529392505050565b5f60608284031215610994575f5ffd5b604051606081018181106001600160401b03821117156109b6576109b661086f565b60405290508082356001600160401b038111156109d1575f5ffd5b6109dd85828601610915565b82525060208301356001600160401b038111156109f8575f5ffd5b610a0485828601610915565b60208301525060408301356001600160401b03811115610a22575f5ffd5b610a2e85828601610915565b6040830152505092915050565b5f82601f830112610a4a575f5ffd5b8135610a55816108f3565b604051610a6282826108c7565b80915082815260208101915060208360051b860101925085831115610a85575f5ffd5b602085015b83811015610ac55780356001600160401b03811115610aa7575f5ffd5b610ab6886020838a0101610984565b84525060209283019201610a8a565b5095945050505050565b80358015158114610ade575f5ffd5b919050565b5f60408284031215610af3575f5ffd5b604051610aff81610883565b809150823563ffffffff81168114610b15575f5ffd5b8152610b2360208401610acf565b60208201525092915050565b5f818303610100811215610b41575f5ffd5b604051610b4d816108a8565b8092506040821215610b5d575f5ffd5b604051610b6981610883565b84358152610b7960208601610acf565b60208201528152610b8d8560408601610ae3565b6020820152610b9f8560808601610ae3565b6040820152604060bf1983011215610bb5575f5ffd5b6040519150610bc382610883565b60c084013562ffffff81168114610bd8575f5ffd5b8252610be660e08501610acf565b60208301526060015292915050565b5f82601f830112610c04575f5ffd5b8135610c0f816108f3565b604051610c1c82826108c7565b80915082815260208101915060208360081b860101925085831115610c3f575f5ffd5b602085015b83811015610ac557610c568782610b2f565b835260209092019161010001610c44565b5f5f5f60608486031215610c79575f5ffd5b83356001600160401b03811115610c8e575f5ffd5b8401601f81018613610c9e575f5ffd5b8035610ca9816108f3565b604051610cb682826108c7565b80915082815260208101915060208360051b850101925088831115610cd9575f5ffd5b6020840193505b82841015610cfb578335825260209384019390910190610ce0565b955050505060208401356001600160401b03811115610d18575f5ffd5b610d2486828701610a3b565b92505060408401356001600160401b03811115610d3f575f5ffd5b610d4b86828701610bf5565b9150509250925092565b5f60208284031215610d65575f5ffd5b5035919050565b5f5f5f6101408486031215610d7f575f5ffd5b8335925060208401356001600160401b03811115610d9b575f5ffd5b610da786828701610984565b925050610db78560408601610b2f565b90509250925092565b634e487b7160e01b5f52603260045260245ffd5b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b838152826020820152606060408201525f8251606080840152610e2860c0840182610dd4565b90506020840151605f19848303016080850152610e458282610dd4565b9150506040840151605f198483030160a0850152610e638282610dd4565b979650505050505050565b634e487b7160e01b5f52601160045260245ffd5b6001600160801b038181168382160190811115610ea157610ea1610e6e565b92915050565b8082028115828204841417610ea157610ea1610e6e565b80820180821115610ea157610ea1610e6e565b6001600160a01b03868116825285166020820152604081018490526060810183905260a0608082018190525f90610e6390830184610dd4565b5f60208284031215610f1a575f5ffd5b81516001600160e01b031981168114610f31575f5ffd5b9392505050565b5f60033d111561066e5760045f5f3e505f5160e01c90565b5f60443d1015610f5d5790565b6040513d600319016004823e80513d60248201116001600160401b0382111715610f8657505090565b80820180516001600160401b03811115610fa1575050505090565b3d8401600319018282016020011115610fbb575050505090565b610fca602082850101856108c7565b509392505050565b602081525f610f316020830184610dd456fea2646970667358221220723f2d3220e596f516eae65f1f47d9b62f79b8fe0505a47e7e028f3cc4ed6a9664736f6c634300081c0033",
  "deployedBytecode": "0x608060405234801561000f575f5ffd5b506004361061003f575f3560e01c80632a827fa51461004357806345b5fd721461005857806353930ef51461006b575b5f5ffd5b610056610051366004610c67565b61007e565b005b610056610066366004610d55565b6100ed565b610056610079366004610d6c565b6101b8565b5f5b81518110156100e7576100df84828151811061009e5761009e610dc0565b60200260200101518483815181106100b8576100b8610dc0565b60200260200101518484815181106100d2576100d2610dc0565b60200260200101516101b8565b600101610080565b50505050565b5f8181527f7a8949a66712f1d1ae515adbd4b0835db540861dfc3638f5ebc928c2d0736d2660205260409020547f7a8949a66712f1d1ae515adbd4b0835db540861dfc3638f5ebc928c2d0736d249063ffffffff164281106101b35760405162461bcd60e51b815260206004820152603460248201527f457870697265643a20446561646c696e6520666f72207469636b657420636f6e60448201527339bab6b83a34b7b7103430b9903830b9b9b2b21760611b60648201526084015b60405180910390fd5b505050565b6101c061022e565b5f6101ca8261029f565b90506101ed6101d7610486565b828660405180602001604052805f815250610494565b7fc0d624564782b3ce0a9e225d9beb02c78ffc996dde3bb989385f98da06420e4181858560405161022093929190610e02565b60405180910390a150505050565b6102366105ec565b6001600160a01b0316610247610486565b6001600160a01b03161461029d5760405162461bcd60e51b815260206004820152601b60248201527f4d757374206265207468652045636f73797374656d206f776e6572000000000060448201526064016101aa565b565b5f807f7a8949a66712f1d1ae515adbd4b0835db540861dfc3638f5ebc928c2d0736d2490505f5f5f5f865f015160200151156102dc576002841893505b866020015160200151156102f1576004841893505b86604001516020015115610306576008841893505b8660600151602001511561031b576010841893505b6001600160801b038085165f908152600487016020526040902054169250610344836001610e82565b915061035d600160801b6001600160801b038616610ea7565b610370906001600160801b038516610ebe565b6001600160801b038581165f908152600488016020908152604090912080546fffffffffffffffffffffffffffffffff19169286169290921790915588510151909150156103ca578651515f828152602087905260409020555b8660200151602001511561040757602087810151515f838152600188019092526040909120805463ffffffff191663ffffffff9092169190911790555b8660400151602001511561044357604087810151515f8381526002880160205291909120805463ffffffff191663ffffffff9092169190911790555b8660400151602001511561047c576060870151515f8281526003870160205260409020805462ffffff191662ffffff9092169190911790555b9695505050505050565b5f61048f61061e565b905090565b6001600160a01b0384166104f45760405162461bcd60e51b815260206004820152602160248201527f455243313135353a206d696e7420746f20746865207a65726f206164647265736044820152607360f81b60648201526084016101aa565b7f6469616d6f6e642e73746f726167652e657263313135350000000000000000005f61051e610486565b90505f61052a86610671565b90505f61053686610671565b5f888152602086815260408083206001600160a01b038d16845290915281208054929350889290919061056a908490610ebe565b9250508190555085846003015f8282546105849190610ebe565b909155505060408051888152602081018890526001600160a01b03808b16925f92918716917fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62910160405180910390a46105e2835f8a8a8a8a6106ba565b5050505050505050565b5f61048f7fd00049dc7109015045860694acecd3dc33338404aaf6e55a1c98a2bf41477b85546001600160a01b031690565b5f6014361080159061065957507f413a4c31c13c7c3de0c7da37be5d779b152baf3f21a1cb760fda41eb8ca97776546001600160a01b031633145b1561066b575060131936013560601c90565b50335b90565b6040805160018082528183019092526060915f91906020808301908036833701905050905082815f815181106106a9576106a9610dc0565b602090810291909101015292915050565b6001600160a01b0384163b15610867576001600160a01b03841630146108675760405163f23a6e6160e01b81526001600160a01b0385169063f23a6e619061070e9089908990889088908890600401610ed1565b6020604051808303815f875af1925050508015610748575060408051601f3d908101601f1916820190925261074591810190610f0a565b60015b6107f457610754610f38565b806308c379a00361078d5750610768610f50565b80610773575061078f565b8060405162461bcd60e51b81526004016101aa9190610fd2565b505b60405162461bcd60e51b815260206004820152603460248201527f455243313135353a207472616e7366657220746f206e6f6e2d455243313135356044820152732932b1b2b4bb32b91034b6b83632b6b2b73a32b960611b60648201526084016101aa565b6001600160e01b0319811663f23a6e6160e01b146108655760405162461bcd60e51b815260206004820152602860248201527f455243313135353a204552433131353552656365697665722072656a656374656044820152676420746f6b656e7360c01b60648201526084016101aa565b505b505050505050565b634e487b7160e01b5f52604160045260245ffd5b604081018181106001600160401b03821117156108a2576108a261086f565b60405250565b608081018181106001600160401b03821117156108a2576108a261086f565b601f8201601f191681016001600160401b03811182821017156108ec576108ec61086f565b6040525050565b5f6001600160401b0382111561090b5761090b61086f565b5060051b60200190565b5f82601f830112610924575f5ffd5b81356001600160401b0381111561093d5761093d61086f565b604051610954601f8301601f1916602001826108c7565b818152846020838601011115610968575f5ffd5b816020850160208301375f918101602001919091529392505050565b5f60608284031215610994575f5ffd5b604051606081018181106001600160401b03821117156109b6576109b661086f565b60405290508082356001600160401b038111156109d1575f5ffd5b6109dd85828601610915565b82525060208301356001600160401b038111156109f8575f5ffd5b610a0485828601610915565b60208301525060408301356001600160401b03811115610a22575f5ffd5b610a2e85828601610915565b6040830152505092915050565b5f82601f830112610a4a575f5ffd5b8135610a55816108f3565b604051610a6282826108c7565b80915082815260208101915060208360051b860101925085831115610a85575f5ffd5b602085015b83811015610ac55780356001600160401b03811115610aa7575f5ffd5b610ab6886020838a0101610984565b84525060209283019201610a8a565b5095945050505050565b80358015158114610ade575f5ffd5b919050565b5f60408284031215610af3575f5ffd5b604051610aff81610883565b809150823563ffffffff81168114610b15575f5ffd5b8152610b2360208401610acf565b60208201525092915050565b5f818303610100811215610b41575f5ffd5b604051610b4d816108a8565b8092506040821215610b5d575f5ffd5b604051610b6981610883565b84358152610b7960208601610acf565b60208201528152610b8d8560408601610ae3565b6020820152610b9f8560808601610ae3565b6040820152604060bf1983011215610bb5575f5ffd5b6040519150610bc382610883565b60c084013562ffffff81168114610bd8575f5ffd5b8252610be660e08501610acf565b60208301526060015292915050565b5f82601f830112610c04575f5ffd5b8135610c0f816108f3565b604051610c1c82826108c7565b80915082815260208101915060208360081b860101925085831115610c3f575f5ffd5b602085015b83811015610ac557610c568782610b2f565b835260209092019161010001610c44565b5f5f5f60608486031215610c79575f5ffd5b83356001600160401b03811115610c8e575f5ffd5b8401601f81018613610c9e575f5ffd5b8035610ca9816108f3565b604051610cb682826108c7565b80915082815260208101915060208360051b850101925088831115610cd9575f5ffd5b6020840193505b82841015610cfb578335825260209384019390910190610ce0565b955050505060208401356001600160401b03811115610d18575f5ffd5b610d2486828701610a3b565b92505060408401356001600160401b03811115610d3f575f5ffd5b610d4b86828701610bf5565b9150509250925092565b5f60208284031215610d65575f5ffd5b5035919050565b5f5f5f6101408486031215610d7f575f5ffd5b8335925060208401356001600160401b03811115610d9b575f5ffd5b610da786828701610984565b925050610db78560408601610b2f565b90509250925092565b634e487b7160e01b5f52603260045260245ffd5b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b838152826020820152606060408201525f8251606080840152610e2860c0840182610dd4565b90506020840151605f19848303016080850152610e458282610dd4565b9150506040840151605f198483030160a0850152610e638282610dd4565b979650505050505050565b634e487b7160e01b5f52601160045260245ffd5b6001600160801b038181168382160190811115610ea157610ea1610e6e565b92915050565b8082028115828204841417610ea157610ea1610e6e565b80820180821115610ea157610ea1610e6e565b6001600160a01b03868116825285166020820152604081018490526060810183905260a0608082018190525f90610e6390830184610dd4565b5f60208284031215610f1a575f5ffd5b81516001600160e01b031981168114610f31575f5ffd5b9392505050565b5f60033d111561066e5760045f5f3e505f5160e01c90565b5f60443d1015610f5d5790565b6040513d600319016004823e80513d60248201116001600160401b0382111715610f8657505090565b80820180516001600160401b03811115610fa1575050505090565b3d8401600319018282016020011115610fbb575050505090565b610fca602082850101856108c7565b509392505050565b602081525f610f316020830184610dd456fea2646970667358221220723f2d3220e596f516eae65f1f47d9b62f79b8fe0505a47e7e028f3cc4ed6a9664736f6c634300081c0033",
  "devdoc": {
    "events": {
      "TransferBatch(address,address,address,uint256[],uint256[])": {
        "details": "Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all transfers."
      },
      "TransferSingle(address,address,address,uint256,uint256)": {
        "details": "Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`."
      }
    },
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "ticketCreateBatch(uint256[],(string,string,string)[],((uint256,bool),(uint32,bool),(uint32,bool),(uint24,bool))[])": {
        "notice": "Owner verification at ticketCreate"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}