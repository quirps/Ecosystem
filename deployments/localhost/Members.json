{
  "address": "0x49138DF5A9Ad73d868EFDfF7fA6995af9211927D",
  "abi": [
    {
      "inputs": [],
      "name": "MigrationAlreadyCompleted",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MigrationAlreadyInitiated",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MigrationNotInitiated",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "timestamp",
          "type": "uint32"
        }
      ],
      "name": "MemberBanned",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "memberAddress",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "level",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "timestamp",
              "type": "uint32"
            }
          ],
          "indexed": false,
          "internalType": "struct LibMemberLevel.Leaf",
          "name": "leaf",
          "type": "tuple"
        }
      ],
      "name": "MemberLevelUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "newRoot",
          "type": "bytes32"
        }
      ],
      "name": "MerkleRootUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "cancellor",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "timeCancelled",
          "type": "uint32"
        }
      ],
      "name": "MigrationCancelled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "initiatior",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "timeInitiatied",
          "type": "uint32"
        }
      ],
      "name": "MigrationInitiated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldOwner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipChanged",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_user",
          "type": "address"
        }
      ],
      "name": "banMember",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "memberAddress",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "level",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "timestamp",
              "type": "uint32"
            }
          ],
          "internalType": "struct LibMemberLevel.Leaf[]",
          "name": "_leaves",
          "type": "tuple[]"
        }
      ],
      "name": "batchSetLevels",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_user",
          "type": "address"
        }
      ],
      "name": "getMemberLevel",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "memberLevel_",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_user",
          "type": "address"
        }
      ],
      "name": "getMemberLevelStruct",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "level",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "timestamp",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "memberAddress",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "level",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "timestamp",
              "type": "uint32"
            }
          ],
          "internalType": "struct LibMemberLevel.Leaf",
          "name": "_leaf",
          "type": "tuple"
        },
        {
          "internalType": "bytes32[]",
          "name": "_merkleProof",
          "type": "bytes32[]"
        }
      ],
      "name": "verifyAndSetLevel",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x0c2414fd1d03dd804910255a4ca9c6f1af213d142d4574eff42fd0fce48429c3",
  "receipt": {
    "to": null,
    "from": "0x1a47C1D6d5B47048536f1111C854e48fA9D76fdF",
    "contractAddress": "0x49138DF5A9Ad73d868EFDfF7fA6995af9211927D",
    "transactionIndex": 0,
    "gasUsed": "541720",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x4df18066e47e1a6589a2893f854072fa34fde7a575406d242d3dd5b0b138babd",
    "transactionHash": "0x0c2414fd1d03dd804910255a4ca9c6f1af213d142d4574eff42fd0fce48429c3",
    "logs": [],
    "blockNumber": 21,
    "cumulativeGasUsed": "541720",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "54a7063fbd1377e55e2032f74c4aa199",
  "metadata": "{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"MigrationAlreadyCompleted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MigrationAlreadyInitiated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MigrationNotInitiated\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"name\":\"MemberBanned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"level\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"indexed\":false,\"internalType\":\"struct LibMemberLevel.Leaf\",\"name\":\"leaf\",\"type\":\"tuple\"}],\"name\":\"MemberLevelUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"newRoot\",\"type\":\"bytes32\"}],\"name\":\"MerkleRootUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cancellor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"timeCancelled\",\"type\":\"uint32\"}],\"name\":\"MigrationCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"initiatior\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"timeInitiatied\",\"type\":\"uint32\"}],\"name\":\"MigrationInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"banMember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"level\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"internalType\":\"struct LibMemberLevel.Leaf[]\",\"name\":\"_leaves\",\"type\":\"tuple[]\"}],\"name\":\"batchSetLevels\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getMemberLevel\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"memberLevel_\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getMemberLevelStruct\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"level\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"memberAddress\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"level\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"internalType\":\"struct LibMemberLevel.Leaf\",\"name\":\"_leaf\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"verifyAndSetLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"banMember(address)\":{\"details\":\"Bans a user by setting their level to 0\",\"params\":{\"_user\":\"Address of the user to ban\"}},\"batchSetLevels((address,uint32,uint32)[])\":{\"details\":\"Batch set levels for multiple addresses (permissioned function)\",\"params\":{\"_leaves\":\"user resource denoting their membership status\"}},\"getMemberLevel(address)\":{\"details\":\"Returns the level info for a given address\",\"params\":{\"_user\":\"Address to query\"}},\"getMemberLevelStruct(address)\":{\"details\":\"Returns the level info for a given address\",\"params\":{\"_user\":\"Address to query\"},\"returns\":{\"level\":\"and timestamp of the user\"}},\"verifyAndSetLevel((address,uint32,uint32),bytes32[])\":{\"details\":\"Verifies Merkle proof and sets user's level\",\"params\":{\"_leaf\":\"Level to assign to the user\",\"_merkleProof\":\"Array of hashed data to verify proof\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/facets/MemberLevel/Members.sol\":\"Members\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/facets/ERC2771Recipient/LibERC2771Recipient.sol\":{\"content\":\"// LibEventStorage.sol\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n\\r\\nlibrary LibERC2771Recipient {\\r\\n    bytes32 constant STORAGE_POSITION = keccak256(\\\"diamond.storage.ERC2771Recipient\\\");\\r\\n\\r\\n   \\r\\n    struct ERC2771RecipientStorage {\\r\\n        address trustedForwarder;\\r\\n    }\\r\\n\\r\\n    function erc2771RecipientStorage() internal pure returns ( ERC2771RecipientStorage storage es) {\\r\\n        bytes32 position = STORAGE_POSITION;\\r\\n        assembly {\\r\\n            es.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n   function __getTrustedForwarder() internal  view returns (address trustedForwarder_){\\r\\n       ERC2771RecipientStorage storage es =  erc2771RecipientStorage();\\r\\n        trustedForwarder_ =  es.trustedForwarder;\\r\\n    }\\r\\n\\r\\n    function __setTrustedForwarder(address _forwarder) internal {\\r\\n        ERC2771RecipientStorage storage es =  erc2771RecipientStorage();\\r\\n        es.trustedForwarder = _forwarder; \\r\\n    }\\r\\n \\r\\n  \\r\\n    function _isTrustedForwarder(address forwarder) public  view returns(bool) {\\r\\n        ERC2771RecipientStorage storage es =  erc2771RecipientStorage();\\r\\n        return forwarder == es.trustedForwarder;\\r\\n    }\\r\\n \\r\\n    \\r\\n    function _msgSender() internal  view returns (address ret) {\\r\\n        if (msg.data.length >= 20 && _isTrustedForwarder(msg.sender)) {\\r\\n            // At this point we know that the sender is a trusted forwarder,\\r\\n            // so we trust that the last bytes of msg.data are the verified sender address.\\r\\n            // extract sender address from the end of msg.data\\r\\n            assembly {\\r\\n                ret := shr(96,calldataload(sub(calldatasize(),20)))\\r\\n            }\\r\\n        } else {\\r\\n            ret = msg.sender;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \\r\\n    function _msgData() internal  view returns (bytes calldata ret) {\\r\\n        if (msg.data.length >= 20 && _isTrustedForwarder(msg.sender)) {\\r\\n            return msg.data[0:msg.data.length-20];\\r\\n        } else {\\r\\n            return msg.data;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x6ff10e2f12c8a61f2ae6ff642711976888a210d309d0e03885193162664330cb\"},\"contracts/facets/ERC2771Recipient/_ERC2771Recipient.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// solhint-disable no-inline-assembly\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\n\\r\\n\\r\\nimport { LibERC2771Recipient } from \\\"./LibERC2771Recipient.sol\\\";  \\r\\n/**\\r\\n * @title The ERC-2771 Recipient Base Abstract Class - Implementation\\r\\n *\\r\\n * @notice Note that this contract was called `BaseRelayRecipient` in the previous revision of the GSN.\\r\\n *\\r\\n * @notice A base contract to be inherited by any contract that want to receive relayed transactions.\\r\\n *\\r\\n * @notice A subclass must use `_msgSender()` instead of `msg.sender`.\\r\\n */\\r\\ncontract iERC2771Recipient {\\r\\n \\r\\n    /*\\r\\n     * Forwarder singleton we accept calls from\\r\\n     */\\r\\n     \\r\\n    \\r\\n\\r\\n    function _getTrustedForwarder() internal  view returns (address forwarder){\\r\\n        return LibERC2771Recipient.__getTrustedForwarder();\\r\\n    }\\r\\n\\r\\n    function _setTrustedForwarder(address _forwarder) internal {\\r\\n        LibERC2771Recipient.__setTrustedForwarder(_forwarder); \\r\\n    }\\r\\n  \\r\\n  \\r\\n    function _isTrustedForwarder(address forwarder) internal  view returns(bool) {\\r\\n        return LibERC2771Recipient._isTrustedForwarder(forwarder);\\r\\n    } \\r\\n\\r\\n    \\r\\n    function msgSender() internal  view returns (address ret_) {\\r\\n        ret_ = LibERC2771Recipient._msgSender();\\r\\n    }\\r\\n    \\r\\n    function msgData() internal  view returns (bytes calldata ret_) {\\r\\n        ret_ = LibERC2771Recipient._msgData();\\r\\n    }\\r\\n}\",\"keccak256\":\"0x0a097bedc1831e582bf1b64b8406b71a3441ed6f9d09b12874821b94d3ce9a88\",\"license\":\"MIT\"},\"contracts/facets/MemberLevel/IMembers.sol\":{\"content\":\"pragma solidity ^0.8.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./_Members.sol\\\"; \\r\\n\\r\\n/// @title Members Contract Interface\\r\\n/// @notice This interface provides a set of functions for managing membership ranks and bounties.\\r\\ninterface IMembers {\\r\\n \\r\\n /**\\r\\n     * @dev Verifies Merkle proof and sets user's level\\r\\n     * @param _leaf Level to assign to the user\\r\\n     * @param _merkleProof Array of hashed data to verify proof\\r\\n     */\\r\\n    function verifyAndSetLevel(LibMemberLevel.Leaf memory _leaf, bytes32[] calldata _merkleProof) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Batch set levels for multiple addresses (permissioned function)\\r\\n     * @param _leaves user resource denoting their membership status\\r\\n     */\\r\\n    function batchSetLevels(LibMemberLevel.Leaf[] calldata _leaves) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the level info for a given address\\r\\n     * @param _user Address to query\\r\\n     * @return level and timestamp of the user\\r\\n     */\\r\\n    function getMemberLevelStruct(address _user) external view returns (uint32 level, uint32 timestamp);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the level info for a given address\\r\\n     * @param _user Address to query\\r\\n     */\\r\\n    function getMemberLevel(address _user) external view returns (uint32 memberLevel_);\\r\\n\\r\\n    /**\\r\\n     * @dev Bans a user by setting their level to 0\\r\\n     * @param _user Address of the user to ban\\r\\n     */\\r\\n    function banMember(address _user) external;\\r\\n}\\r\\n\",\"keccak256\":\"0x94cef54b4a937470b8d10c0c74d295f625882e26f23086d2db64aa18cc71686c\"},\"contracts/facets/MemberLevel/LibMemberLevel.sol\":{\"content\":\"pragma solidity ^0.8.6;\\r\\n\\r\\nimport \\\"../../libraries/utils/Incrementer.sol\\\"; \\r\\n\\r\\n/**\\r\\n    user level history keys are designed to be unique by following the program of\\r\\n    using 8 bytes for the total history length ~1E19 for the highest order 8 bytes \\r\\n    and the lowest order 20 bytes for their address (28 byte total)\\r\\n\\r\\n    Why use a key when can just use uint96 for level history max index?\\r\\n */\\r\\nlibrary LibMemberLevel {\\r\\n    using Incrementer for bytes28;\\r\\n    using Incrementer for bytes8;\\r\\n    bytes32 constant MEMBER_STORAGE_POSITION = keccak256(\\\"diamond.standard.members.storage\\\");\\r\\n    struct MemberLevelStorage {\\r\\n        mapping( address => MemberLevel ) memberLevel; // level history \\r\\n        bytes32 merkleRoot;\\r\\n    }\\r\\n\\r\\n    struct Leaf {\\r\\n        address memberAddress;\\r\\n        uint32 level;\\r\\n        uint32 timestamp;\\r\\n    }\\r\\n\\r\\n    struct MemberLevel{\\r\\n        uint32 timestamp;\\r\\n        uint32 level;\\r\\n    }\\r\\n    \\r\\n    type level is uint32;\\r\\n\\r\\n    function memberLevelStorage() internal pure returns (MemberLevelStorage storage ms_) { \\r\\n        bytes32 position = MEMBER_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ms_.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function permissionedChangeLevel( uint32 _level, address member) internal {\\r\\n        MemberLevelStorage storage ms = memberLevelStorage();\\r\\n        ms.memberLevel[ member ] = MemberLevel( uint32( block.timestamp ), _level ); \\r\\n    }\\r\\n  \\r\\n \\r\\n}\\r\\n\",\"keccak256\":\"0x7cefbdd11110e035371d6352310286b00867ab055242b358edbd9bb7c027ca95\"},\"contracts/facets/MemberLevel/Members.sol\":{\"content\":\"pragma solidity ^0.8.9;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"../Tokens/ERC1155/ERC1155Transfer.sol\\\";\\r\\nimport \\\"./_Members.sol\\\";   \\r\\nimport \\\"../../libraries/merkleVerify/MembersVerify.sol\\\"; \\r\\nimport \\\"./IMembers.sol\\\";\\r\\n  \\r\\ncontract Members is IMembers, iMembers { \\r\\n\\r\\n    /**\\r\\n     * @dev Verifies Merkle proof and sets user's level\\r\\n     * @param _leaf Level to assign to the user\\r\\n     * @param _merkleProof Array of hashed data to verify proof\\r\\n     */\\r\\n    function verifyAndSetLevel(LibMemberLevel.Leaf memory _leaf, bytes32[] calldata _merkleProof) external {\\r\\n        _verifyAndSetLevel(_leaf, _merkleProof);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Batch set levels for multiple addresses (permissioned function)\\r\\n     * @param _leaves user resource denoting their membership status\\r\\n     */\\r\\n    function batchSetLevels(LibMemberLevel.Leaf[] calldata _leaves) external {\\r\\n        _batchSetLevels(_leaves);\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the level info for a given address\\r\\n     * @param _user Address to query\\r\\n     * @return level and timestamp of the user\\r\\n     */\\r\\n    function getMemberLevelStruct(address _user) external view returns (uint32 level, uint32 timestamp) {\\r\\n        return _getMemberLevelStruct(_user);\\r\\n    }\\r\\n\\r\\n  \\r\\n\\r\\n    /**\\r\\n     * @dev Returns the level info for a given address\\r\\n     * @param _user Address to query\\r\\n     */\\r\\n    function getMemberLevel(address _user) external view returns (uint32 memberLevel_) {\\r\\n        return _getMemberLevel(_user);\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Bans a user by setting their level to 0\\r\\n     * @param _user Address of the user to ban\\r\\n     */\\r\\n    function banMember(address _user) external onlyOwner {\\r\\n        _banMember(_user);\\r\\n    }\\r\\n\\r\\n\\r\\n \\r\\n\\r\\n\\r\\n}\\r\\n\\r\\n\",\"keccak256\":\"0x2519800f64637c85949d75be0b5c17918c678733b8d1c09f514f3597781d5376\"},\"contracts/facets/MemberLevel/_Members.sol\":{\"content\":\"pragma solidity ^0.8.9;\\r\\n \\r\\n   \\r\\nimport \\\"./LibMemberLevel.sol\\\";  \\r\\nimport \\\"../../libraries/utils/Incrementer.sol\\\"; \\r\\nimport \\\"../Moderator/LibModerator.sol\\\";  \\r\\nimport \\\"../Moderator/ModeratorModifiers.sol\\\";   \\r\\nimport {iOwnership} from \\\"../Ownership/_Ownership.sol\\\"; \\r\\nimport { LibMemberLevel} from \\\"./LibMemberLevel.sol\\\"; \\r\\n  \\r\\ncontract iMembers is iOwnership {   \\r\\n    event MerkleRootUpdated(bytes32 newRoot);\\r\\n    event MemberLevelUpdated(LibMemberLevel.Leaf leaf);\\r\\n    event MemberBanned(address indexed user, uint32 timestamp); \\r\\n      /**  \\r\\n     * @dev Updates the Merkle root\\r\\n     * @param _merkleRoot New Merkle root to be stored\\r\\n     */\\r\\n     function updateMemberMerkleRoot(bytes32 _merkleRoot) internal  {\\r\\n        isEcosystemOwnerVerification();\\r\\n        LibMemberLevel.MemberLevelStorage storage mrs = LibMemberLevel.memberLevelStorage();\\r\\n        mrs.merkleRoot = _merkleRoot; \\r\\n        emit MerkleRootUpdated(_merkleRoot);\\r\\n    }\\r\\n        /**\\r\\n     * @dev Verifies Merkle proof and sets user's level\\r\\n     * @param _leaf Level to assign to the user\\r\\n     * @param _merkleProof Array of hashed data to verify proof\\r\\n     */ \\r\\n    function _verifyAndSetLevel(LibMemberLevel.Leaf memory _leaf, bytes32[] calldata _merkleProof) internal {\\r\\n        // Create leaf from msg.sender and level\\r\\n        LibMemberLevel.MemberLevelStorage storage mrs = LibMemberLevel.memberLevelStorage();\\r\\n\\r\\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, _leaf.level, _leaf.timestamp));\\r\\n        \\r\\n        require(_verifyMerkleProof(_merkleProof, mrs.merkleRoot, leaf), \\\"Invalid Merkle proof\\\");\\r\\n          \\r\\n        // Set the member level\\r\\n        mrs.memberLevel[msg.sender] = LibMemberLevel.MemberLevel({\\r\\n            level: _leaf.level,\\r\\n            timestamp: _leaf.timestamp\\r\\n        });\\r\\n        \\r\\n        emit MemberLevelUpdated(_leaf);  \\r\\n    }\\r\\n\\r\\n       /**\\r\\n     * @dev Helper function to verify Merkle proofs\\r\\n     */\\r\\n    function _verifyMerkleProof(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\r\\n        bytes32 computedHash = leaf;\\r\\n        \\r\\n        for (uint256 i = 0; i < proof.length; i++) {\\r\\n            bytes32 proofElement = proof[i];\\r\\n            \\r\\n            if (computedHash <= proofElement) {\\r\\n                // Hash(current computed hash + current element of the proof)\\r\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\r\\n            } else {\\r\\n                // Hash(current element of the proof + current computed hash)\\r\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        // Check if the computed hash equals the root of the Merkle tree\\r\\n        return computedHash == root;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Batch set levels for multiple addresses (permissioned function)\\r\\n     * @param _leaves user resource denoting their membership status\\r\\n     *   \\r\\n     */\\r\\n    function _batchSetLevels( LibMemberLevel.Leaf[] calldata _leaves) internal {\\r\\n        isEcosystemOwnerVerification();\\r\\n        LibMemberLevel.MemberLevelStorage storage mrs = LibMemberLevel.memberLevelStorage();\\r\\n        \\r\\n        for (uint256 i = 0; i < _leaves.length; i++) {\\r\\n            LibMemberLevel.Leaf memory _leaf = _leaves[ i ]; \\r\\n            mrs.memberLevel[ _leaf.memberAddress ] = LibMemberLevel.MemberLevel({\\r\\n                level: _leaf.level,\\r\\n                timestamp: _leaf.timestamp\\r\\n            });\\r\\n            \\r\\n            emit MemberLevelUpdated(_leaf);    \\r\\n        }\\r\\n    }\\r\\n\\r\\n     /**\\r\\n     * @dev Returns the level info for a given address\\r\\n     * @param _user Address to query\\r\\n     * @return level and timestamp of the user\\r\\n     */\\r\\n    function _getMemberLevelStruct(address _user) internal view returns (uint32 level, uint32 timestamp) {\\r\\n        LibMemberLevel.MemberLevelStorage storage mrs = LibMemberLevel.memberLevelStorage();\\r\\n        LibMemberLevel.MemberLevel storage memberLevelStruct = mrs.memberLevel[ _user ];\\r\\n        return (memberLevelStruct.level, memberLevelStruct.timestamp);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the level info for a given address\\r\\n     * @param _user Address to query \\r\\n     */\\r\\n    function _getMemberLevel(address _user) internal view returns (uint32 memberLevel_) {\\r\\n        LibMemberLevel.MemberLevelStorage storage mrs = LibMemberLevel.memberLevelStorage();\\r\\n        memberLevel_ = mrs.memberLevel[ _user ].level;  \\r\\n    }\\r\\n    \\r\\n\\r\\n    /**\\r\\n     * @dev Bans a user by setting their level to 0\\r\\n     * @param _user Address of the user to ban\\r\\n     */\\r\\n    function _banMember(address _user) internal onlyOwner {\\r\\n        LibMemberLevel.MemberLevelStorage storage mrs = LibMemberLevel.memberLevelStorage();\\r\\n        uint32 currentTimestamp = uint32(block.timestamp);\\r\\n        \\r\\n        mrs.memberLevel[_user] = LibMemberLevel.MemberLevel({\\r\\n            level: 0,\\r\\n            timestamp: currentTimestamp\\r\\n        });\\r\\n        \\r\\n        emit MemberBanned(_user, currentTimestamp);\\r\\n    }\\r\\n}\\r\\n\\r\\n\",\"keccak256\":\"0x07b9e69ea7f3a83cb7c184802223dac94e1f9ea8631600e15bb0e771bdac7086\"},\"contracts/facets/Moderator/LibModerator.sol\":{\"content\":\"pragma solidity ^0.8.6;\\r\\n\\r\\nlibrary LibModerator{\\r\\n    bytes32 constant MODERATOR_STORAGE_POSITION = keccak256(\\\"diamond.standard.Moderator.storage\\\");\\r\\n    struct Moderator_Storage{\\r\\n        mapping( address => uint8 ) moderatorRank;\\r\\n    }\\r\\n\\r\\n    function moderatorStorage() internal pure returns (Moderator_Storage storage es){\\r\\n        bytes32 Moderator_STORAGE_POSITION = MODERATOR_STORAGE_POSITION;\\r\\n        assembly{\\r\\n            es.slot := Moderator_STORAGE_POSITION\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setModeratorRank(address _moderator, uint8 rank) internal {\\r\\n        moderatorStorage().moderatorRank[ _moderator ] = rank;\\r\\n    }\\r\\n    function getModeratorRank(address _moderator) internal view returns (uint8 rank_) {\\r\\n        rank_ = moderatorStorage().moderatorRank[ _moderator ];\\r\\n    }\\r\\n}\",\"keccak256\":\"0xf25a2532479212be318e406d567a6c55854139cf6b3eee3142ef15375514ef4b\"},\"contracts/facets/Moderator/ModeratorModifiers.sol\":{\"content\":\"pragma solidity ^0.8.9;\\r\\n\\r\\nimport {iERC2771Recipient} from \\\"../ERC2771Recipient/_ERC2771Recipient.sol\\\";    \\r\\nimport \\\"./ModeratorRankConstants.sol\\\";\\r\\nimport \\\"./LibModerator.sol\\\"; \\r\\n\\r\\ncontract ModeratorModifiers is ModeratorRankConstants, iERC2771Recipient {\\r\\n    modifier moderatorMemberPermission(){\\r\\n        require( LibModerator.getModeratorRank( msgSender() ) \\r\\n                 >= MODERATOR_MEMBER_PERMISSIONED ,\\\"MS - Insufficient Priveleges.\\\");\\r\\n        _;\\r\\n    }\\r\\n}\",\"keccak256\":\"0x882815af7f8f780d8ff9839554eaac6d419009daaf3eb5eb0093d61eca9d2332\"},\"contracts/facets/Moderator/ModeratorRankConstants.sol\":{\"content\":\"pragma solidity ^0.8.9;\\r\\n\\r\\ncontract ModeratorRankConstants {\\r\\n    uint8 constant MODERATOR_MEMBER_PERMISSIONED = 200;\\r\\n}\",\"keccak256\":\"0xb901e110b796cbf22309409abb5e9c9b67fd71f39ce98e5d1bdb85f66c03e281\"},\"contracts/facets/Ownership/LibOwnership.sol\":{\"content\":\"pragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n\\r\\nlibrary LibOwnership {\\r\\nbytes32 constant OWNERSHIP_STORAGE_POSITION = keccak256(\\\"diamond.ownership.storage\\\");\\r\\nuint24 constant MIGRATION_TRANSITION_LOCK_TIMESPAN = 259200; // 3 days\\r\\n\\r\\nstruct OwnershipStorage{\\r\\n    address ecosystemOwner;\\r\\n    address registry;\\r\\n    Migration migration;\\r\\n}\\r\\nstruct Migration{\\r\\n    bool isMigrating;\\r\\n    uint32 initiationTimestamp;\\r\\n}\\r\\n\\r\\nfunction ownershipStorage() internal pure returns (OwnershipStorage storage os) {\\r\\n        bytes32 position = OWNERSHIP_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            os.slot := position \\r\\n        }\\r\\n    }\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n        Should never be used outside of iOwnership.sol (exception for the initial diamond constructor)\\r\\n        @notice Sets the owner of this ecosystem\\r\\n        @param _newEcosystemOwner  new ecosystem owner \\r\\n     */\\r\\n    function _setEcosystemOwner(address _newEcosystemOwner) internal {\\r\\n        OwnershipStorage storage os = ownershipStorage();\\r\\n        address previousOwner = os.ecosystemOwner;\\r\\n        os.ecosystemOwner = _newEcosystemOwner;\\r\\n        emit OwnershipTransferred(previousOwner, _newEcosystemOwner);\\r\\n    }\\r\\n\\r\\n    function _ecosystemOwner() internal view returns (address ecosystemOwner_) {\\r\\n        ecosystemOwner_ = ownershipStorage().ecosystemOwner;\\r\\n    }\\r\\n\\r\\n    function _setRegistry(address _registry) internal {\\r\\n        OwnershipStorage storage os = ownershipStorage();\\r\\n        os.registry = _registry;\\r\\n    }\\r\\n    function _getRegistry() internal view returns (address registry_) {\\r\\n        OwnershipStorage storage os = ownershipStorage();\\r\\n        registry_ = os.registry;\\r\\n    }\\r\\n    \\r\\n    \\r\\n} \",\"keccak256\":\"0x424fd62131dbaccfa06ef6f6deb4e1ef1d75db9d9e0908c864faff0e1d52099e\"},\"contracts/facets/Ownership/_Ownership.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {LibOwnership} from \\\"./LibOwnership.sol\\\";\\r\\nimport {iERC2771Recipient} from \\\"../ERC2771Recipient/_ERC2771Recipient.sol\\\";     \\r\\n\\r\\ncontract iOwnership is iERC2771Recipient {\\r\\n    error MigrationAlreadyInitiated();\\r\\n    error MigrationAlreadyCompleted();\\r\\n    error MigrationNotInitiated();\\r\\n\\r\\n    event MigrationInitiated(address initiatior, uint32 timeInitiatied);\\r\\n    event MigrationCancelled(address cancellor, uint32 timeCancelled);\\r\\n    event OwnershipChanged(address oldOwner, address newOwner); \\r\\n    modifier onlyOwner(){\\r\\n        msgSender() == _ecosystemOwner();\\r\\n        _;\\r\\n    }\\r\\n    function _setEcosystemOwner( address _newOwner) internal {\\r\\n        isEcosystemOwnerVerification();\\r\\n        LibOwnership._setEcosystemOwner(_newOwner);\\r\\n    }\\r\\n\\r\\n    function _ecosystemOwner() internal view returns (address owner_) {\\r\\n        owner_ = LibOwnership._ecosystemOwner();\\r\\n    }\\r\\n\\r\\n    function isEcosystemOwnerVerification() internal view {\\r\\n        require( msgSender() == _ecosystemOwner(), \\\"Must be the Ecosystem owner\\\"); \\r\\n    }\\r\\n    \\r\\n\\r\\n    //Migration related methods\\r\\n\\r\\n    /**\\r\\n     * @dev sole purpose is to restrict user from having access to ecosystem modularity\\r\\n     * until they initiate a migration. only modular changes are done via registry until\\r\\n     * then. \\r\\n     */\\r\\n    function isEffectiveOwner() internal view {\\r\\n        LibOwnership.OwnershipStorage storage os = LibOwnership.ownershipStorage();\\r\\n        LibOwnership.Migration storage _migration = os.migration;\\r\\n        if( _migration.isMigrating && isMigrationPeriodOver( _migration.initiationTimestamp ) ){\\r\\n            require( msgSender() == os.ecosystemOwner, \\\"Sender must be the owner.\\\");\\r\\n        }\\r\\n        else{\\r\\n            require(msgSender() == os.registry, \\\"Sender must be from the registry.\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \\r\\n    /**\\r\\n     * @dev start the migration \\r\\n     */\\r\\n    function _initiateMigration() internal {\\r\\n        LibOwnership.OwnershipStorage storage os = LibOwnership.ownershipStorage();\\r\\n        LibOwnership.Migration storage _migration = os.migration;\\r\\n        if( _migration.isMigrating ){\\r\\n            revert MigrationAlreadyInitiated();\\r\\n        }\\r\\n        else{\\r\\n            _migration.isMigrating = true;\\r\\n            _migration.initiationTimestamp = uint32(block.timestamp);\\r\\n            emit MigrationInitiated(msgSender(), uint32(block.timestamp) );\\r\\n        } \\r\\n    }\\r\\n    function _cancelMigration() internal {\\r\\n        LibOwnership.OwnershipStorage storage os = LibOwnership.ownershipStorage();\\r\\n        LibOwnership.Migration storage _migration = os.migration;\\r\\n        uint32 _initiationTimestamp = _migration.initiationTimestamp;\\r\\n        if( _migration.isMigrating  ) {\\r\\n            if(isMigrationPeriodOver( _initiationTimestamp )){\\r\\n                revert MigrationAlreadyCompleted();\\r\\n            }\\r\\n            else{\\r\\n                _migration.isMigrating = false;\\r\\n                emit MigrationCancelled(msgSender(), uint32(block.timestamp));\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            revert MigrationNotInitiated();\\r\\n        }\\r\\n        \\r\\n    }\\r\\n    function isMigrationPeriodOver( uint32 _initiationTimestamp ) internal view returns (bool isOver_){\\r\\n        isOver_ = uint32(block.timestamp) + LibOwnership.MIGRATION_TRANSITION_LOCK_TIMESPAN > _initiationTimestamp;\\r\\n    }\\r\\n}\\r\\n \",\"keccak256\":\"0x3fa7c0716afb600bfa154cef5596f51bb7a707b1d394648498ff24e35731f0ba\",\"license\":\"MIT\"},\"contracts/facets/Tokens/ERC1155/ERC1155Transfer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC1155/ERC1155.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./interfaces/IERC1155.sol\\\";\\r\\nimport \\\"./interfaces/IERC1155Receiver.sol\\\";\\r\\nimport \\\"./interfaces/IERC1155MetadataURI.sol\\\";\\r\\nimport \\\"./interfaces/IERC1155Transfer.sol\\\";\\r\\nimport \\\"./internals/iERC1155.sol\\\";\\r\\nimport \\\"../../../libraries//utils/Address.sol\\\";\\r\\nimport \\\"../../../libraries/utils/Context.sol\\\";\\r\\nimport \\\"./libraries/LibERC1155.sol\\\";\\r\\nimport \\\"./internals/iERC1155Transfer.sol\\\";\\r\\n/**\\r\\n * @dev Implementation of the basic standard multi-token.\\r\\n * See https://eips.ethereum.org/EIPS/eip-1155\\r\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\r\\n *\\r\\n * _Available since v3.1._\\r\\n */\\r\\ncontract ERC1155Transfer is    iERC1155Transfer {\\r\\n    using Address for address;\\r\\n    /**\\r\\n     * @dev See {IERC1155-safeTransferFrom}.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to, \\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    ) public   {\\r\\n        require(\\r\\n            from == msgSender() || isApprovedForAll(from, msgSender()),\\r\\n            \\\"ERC1155: caller is not token owner or approved\\\"\\r\\n        );\\r\\n        _safeTransferFrom(from, to, id, amount, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\r\\n     */\\r\\n    function safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) public  {\\r\\n        require(\\r\\n            from == msgSender() || isApprovedForAll(from, msgSender()),\\r\\n            \\\"ERC1155: caller is not token owner or approved\\\"\\r\\n        );\\r\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-setApprovalForAll}.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) public  {\\r\\n        _setApprovalForAll(msgSender(), operator, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-isApprovedForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(address account, address operator) public view  returns (bool) {\\r\\n        LibERC1155.ERC1155Storage storage es = LibERC1155.erc1155Storage();\\r\\n\\r\\n        return es.operatorApprovals[account][operator];\\r\\n    }\\r\\n    \\r\\n}\\r\\n\",\"keccak256\":\"0xd10431d55a295dae089e745b8f7c3cfb56b8d114f1a0032f8ee3029fc2649881\",\"license\":\"MIT\"},\"contracts/facets/Tokens/ERC1155/interfaces/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\r\\n *\\r\\n * _Available since v3.1._\\r\\n */\\r\\ninterface IERC1155 {\\r\\n    /**\\r\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\r\\n     *\\r\\n     * If an {URI} event was emitted for `id`, the standard\\r\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\r\\n     * returned by {IERC1155MetadataURI-uri}.\\r\\n     */\\r\\n    event URI(string value, uint256 indexed id);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `accounts` and `ids` must have the same length.\\r\\n     */\\r\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155MetadataURI-uri}.\\r\\n     *\\r\\n     * This implementation returns the same URI for *all* token types. It relies\\r\\n     * on the token type ID substitution mechanism\\r\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\r\\n     *\\r\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\r\\n     * actual token type ID.\\r\\n     */\\r\\n    function mint(address to, uint256 id, uint256 amount, bytes memory data) external;\\r\\n\\r\\n    function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) external;\\r\\n\\r\\n    function burn(address from, uint256 id, uint256 amount) external;\\r\\n\\r\\n    function burnBatch(address from, uint256[] memory ids, uint256[] memory amounts) external;\\r\\n}\\r\\n\",\"keccak256\":\"0xc4b5dedca297f6e634dbe618b5ac7645d9b57254ff65cd1cdd75338e7afeeab3\",\"license\":\"MIT\"},\"contracts/facets/Tokens/ERC1155/interfaces/IERC1155MetadataURI.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\r\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\r\\n *\\r\\n * _Available since v3.1._\\r\\n */\\r\\ninterface IERC1155MetadataURI  {\\r\\n    /**\\r\\n     * @dev Returns the URI for token type `id`.\\r\\n     *\\r\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\r\\n     * clients with the actual token type ID.\\r\\n     */\\r\\n    function uri(uint256 id) external view returns (string memory);\\r\\n}\",\"keccak256\":\"0x4ef49699111ec060ff59c11773f6664a9c13c74695c57701b1348dd044f20695\",\"license\":\"MIT\"},\"contracts/facets/Tokens/ERC1155/interfaces/IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev _Available since v3.1._\\r\\n */\\r\\ninterface IERC1155Receiver  {\\r\\n    /**\\r\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\r\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\r\\n     *\\r\\n     * NOTE: To accept the transfer, this must return\\r\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\r\\n     * (i.e. 0xf23a6e61, or its own function selector).\\r\\n     *\\r\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\r\\n     * @param from The address which previously owned the token\\r\\n     * @param id The ID of the token being transferred\\r\\n     * @param value The amount of tokens being transferred\\r\\n     * @param data Additional data with no specified format\\r\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\r\\n     */\\r\\n    function onERC1155Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 id,\\r\\n        uint256 value,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n\\r\\n    /**\\r\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\r\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\r\\n     * been updated.\\r\\n     *\\r\\n     * NOTE: To accept the transfer(s), this must return\\r\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\r\\n     * (i.e. 0xbc197c81, or its own function selector).\\r\\n     *\\r\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\r\\n     * @param from The address which previously owned the token\\r\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\r\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\r\\n     * @param data Additional data with no specified format\\r\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\r\\n     */\\r\\n    function onERC1155BatchReceived(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata values,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n}\\r\\n\",\"keccak256\":\"0x903479627911c42b944018e3af01eecab68fbc134c6002f8fdc21d1626abf762\",\"license\":\"MIT\"},\"contracts/facets/Tokens/ERC1155/interfaces/IERC1155Transfer.sol\":{\"content\":\"pragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\ninterface IERC1155Transfer{\\r\\n\\r\\n\\r\\n /**\\r\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\r\\n     *\\r\\n     * Emits a {TransferSingle} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\r\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\r\\n    \\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\r\\n     *\\r\\n     * Emits a {TransferBatch} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `ids` and `amounts` must have the same length.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata amounts,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n      /**\\r\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `operator` cannot be the caller.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\r\\n     *\\r\\n     * See {setApprovalForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\r\\n\\r\\n}\",\"keccak256\":\"0x1fba6f123b029993faac5769a036f58dd1ea79ce27136031aa2f366e982b0737\"},\"contracts/facets/Tokens/ERC1155/internals/iERC1155.sol\":{\"content\":\"pragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../libraries/LibERC1155.sol\\\";\\r\\nimport \\\"./iERC1155ContractTransfer.sol\\\";\\r\\nimport \\\"../interfaces/IERC1155Transfer.sol\\\";\\r\\nimport \\\"../interfaces/IERC1155Receiver.sol\\\";\\r\\nimport \\\"../../../../libraries/utils/Address.sol\\\";\\r\\n\\r\\nimport {iOwnership} from \\\"../../../Ownership/_Ownership.sol\\\";\\r\\n\\r\\n\\r\\ncontract iERC1155 is iERC1155ContractTransfer, iOwnership {\\r\\n    using Address for address;\\r\\n\\r\\n    /**\\r\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\r\\n     * substitution mechanism\\r\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\r\\n     *\\r\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\r\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\r\\n     * clients with the token type ID.\\r\\n     *\\r\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\r\\n     * interpreted by clients as\\r\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\r\\n     * for token type ID 0x4cce0.\\r\\n     *\\r\\n     * See {uri}.\\r\\n     *\\r\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\r\\n     * this function emits no events.\\r\\n     */\\r\\n    function _setURI(string memory newuri) internal {\\r\\n        LibERC1155.ERC1155Storage storage es = LibERC1155.erc1155Storage();\\r\\n        es.uri = newuri;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\\r\\n     *\\r\\n     * Emits a {TransferSingle} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal {\\r\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\r\\n\\r\\n        LibERC1155.ERC1155Storage storage es = LibERC1155.erc1155Storage();\\r\\n        address operator = msgSender();\\r\\n        uint256[] memory ids = LibERC1155._asSingletonArray(id);\\r\\n        uint256[] memory amounts = LibERC1155._asSingletonArray(amount);\\r\\n\\r\\n        es.balance[id][to] += amount;\\r\\n        es.totalSupply += amount;\\r\\n        emit TransferSingle(operator, address(0), to, id, amount);\\r\\n\\r\\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\r\\n     *\\r\\n     * Emits a {TransferBatch} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `ids` and `amounts` must have the same length.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal {\\r\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\r\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\r\\n        uint256 _totalSupply;\\r\\n        LibERC1155.ERC1155Storage storage es = LibERC1155.erc1155Storage();\\r\\n\\r\\n        address operator = msgSender();\\r\\n\\r\\n        for (uint256 i = 0; i < ids.length; i++) {\\r\\n            es.balance[ids[i]][to] += amounts[i];\\r\\n            _totalSupply += amounts[i];\\r\\n        }\\r\\n        es.totalSupply = _totalSupply;\\r\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\r\\n\\r\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens of token type `id` from `from`\\r\\n     *\\r\\n     * Emits a {TransferSingle} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `from` must have at least `amount` tokens of token type `id`.\\r\\n     */\\r\\n    function _burn(address from, uint256 id, uint256 amount) internal {\\r\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\r\\n\\r\\n        LibERC1155.ERC1155Storage storage es = LibERC1155.erc1155Storage();\\r\\n\\r\\n        address operator = msgSender();\\r\\n        uint256[] memory ids = LibERC1155._asSingletonArray(id);\\r\\n        uint256[] memory amounts = LibERC1155._asSingletonArray(amount);\\r\\n\\r\\n        uint256 fromBalance = es.balance[id][from];\\r\\n        require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\r\\n        require(es.totalSupply >= amount, \\\"Exceeds total supply.\\\");\\r\\n        unchecked {\\r\\n            es.balance[id][from] = fromBalance - amount;\\r\\n            es.totalSupply -= amount;\\r\\n        }\\r\\n\\r\\n        emit TransferSingle(operator, from, address(0), id, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\r\\n     *\\r\\n     * Emits a {TransferBatch} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `ids` and `amounts` must have the same length.\\r\\n     */\\r\\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory amounts) internal {\\r\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\r\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\r\\n\\r\\n        LibERC1155.ERC1155Storage storage es = LibERC1155.erc1155Storage();\\r\\n        address operator = msgSender();\\r\\n\\r\\n        uint256 _totalAmount;\\r\\n        for (uint256 i = 0; i < ids.length; i++) {\\r\\n            uint256 id = ids[i];\\r\\n            uint256 amount = amounts[i];\\r\\n            _totalAmount += amount;\\r\\n\\r\\n            uint256 fromBalance = es.balance[id][from];\\r\\n            require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\r\\n            require(es.totalSupply >= _totalAmount, \\\"Exceeds total supply.\\\");\\r\\n            unchecked {\\r\\n                es.balance[id][from] = fromBalance - amount;\\r\\n            }\\r\\n        }\\r\\n        es.totalSupply -= _totalAmount;\\r\\n\\r\\n        emit TransferBatch(operator, from, address(0), ids, amounts);\\r\\n    }\\r\\n\\r\\n    \\r\\n}\\r\\n\",\"keccak256\":\"0x309447f5d09a0118c953a9cf2089978e7d3d915b343fa106799986933a5bb5bf\"},\"contracts/facets/Tokens/ERC1155/internals/iERC1155ContractTransfer.sol\":{\"content\":\"pragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../interfaces/IERC1155Receiver.sol\\\";\\r\\nimport \\\"../../../../libraries/utils/Address.sol\\\";\\r\\nimport \\\"./iERC1155Receiver.sol\\\";\\r\\n\\r\\n//Safety check for transfers to contracts\\r\\ncontract iERC1155ContractTransfer is iERC1155Receiver {\\r\\n    \\r\\n    using Address for address;\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\r\\n     */\\r\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\r\\n     * transfers.\\r\\n     */\\r\\n   /**\\r\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\r\\n     * transfers.\\r\\n     */\\r\\n    event TransferBatch(\\r\\n        address indexed operator,\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256[] ids,\\r\\n        uint256[] values\\r\\n    );\\r\\n\\r\\n     function _doSafeTransferAcceptanceCheck(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    ) internal {\\r\\n        if (to.isContract()) {\\r\\n            if( to == address(this)){\\r\\n               return;\\r\\n            }\\r\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\r\\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\\r\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\r\\n                }\\r\\n            } catch Error(string memory reason) {\\r\\n                revert(reason);\\r\\n            } catch {\\r\\n                revert(\\\"ERC1155: transfer to non-ERC1155Receiver implementer\\\");\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _doSafeBatchTransferAcceptanceCheck(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) internal {\\r\\n        if (to.isContract()) {\\r\\n            if( to == address(this)){\\r\\n               return;\\r\\n            }\\r\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\r\\n                bytes4 response\\r\\n            ) {\\r\\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\\r\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\r\\n                }\\r\\n            } catch Error(string memory reason) {\\r\\n                revert(reason);\\r\\n            } catch {\\r\\n                revert(\\\"ERC1155: transfer to non-ERC1155Receiver implementer\\\");\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n}\",\"keccak256\":\"0x929836d5a0c4a3961eb6d8c0dbc85213a50dff7fca377dd4df6e5e92832ab352\"},\"contracts/facets/Tokens/ERC1155/internals/iERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev _Available since v3.1._\\r\\n */\\r\\ncontract iERC1155Receiver   {\\r\\n\\r\\n    function _onERC1155Received(\\r\\n    ) internal pure returns (bytes4){\\r\\n        return 0xf23a6e61;\\r\\n    }\\r\\n    function _onERC1155BatchReceived(\\r\\n    ) internal pure returns (bytes4){\\r\\n        return 0xbc197c81;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xbeaf6ce27c1d8a0f9e54061b5cd887071a88a229e9ce742ad51d01e915b5b459\",\"license\":\"MIT\"},\"contracts/facets/Tokens/ERC1155/internals/iERC1155Transfer.sol\":{\"content\":\"pragma solidity ^0.8.0;\\r\\n\\r\\nimport {iERC2771Recipient} from \\\"../../../ERC2771Recipient/_ERC2771Recipient.sol\\\";    \\r\\nimport \\\"../libraries/LibERC1155.sol\\\";\\r\\nimport \\\"./iERC1155ContractTransfer.sol\\\";\\r\\nimport \\\"../interfaces/IERC1155Transfer.sol\\\";\\r\\n\\r\\ncontract iERC1155Transfer is iERC1155ContractTransfer, iERC2771Recipient {\\r\\n    /**\\r\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\r\\n     * `approved`.\\r\\n     */\\r\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\r\\n\\r\\n    /**\\r\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\r\\n     * transfers.\\r\\n     */\\r\\n\\r\\n    function _safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes memory data) internal {\\r\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\r\\n        LibERC1155.ERC1155Storage storage es = LibERC1155.erc1155Storage();\\r\\n        address operator = msgSender(); \\r\\n        uint256[] memory ids = LibERC1155._asSingletonArray(id);\\r\\n        uint256[] memory amounts = LibERC1155._asSingletonArray(amount);\\r\\n\\r\\n        uint256 fromBalance = es.balance[id][from];\\r\\n        require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\r\\n        unchecked {\\r\\n            es.balance[id][from] = fromBalance - amount;\\r\\n        }\\r\\n        es.balance[id][to] += amount;\\r\\n        emit TransferSingle(operator, from, to, id, amount);\\r\\n\\r\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\r\\n     *\\r\\n     * Emits a {TransferBatch} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function _safeBatchTransferFrom(address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal {\\r\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\r\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\r\\n        LibERC1155.ERC1155Storage storage es = LibERC1155.erc1155Storage();\\r\\n        address operator = msgSender();\\r\\n\\r\\n        for (uint256 i = 0; i < ids.length; ++i) {\\r\\n            uint256 id = ids[i];\\r\\n            uint256 amount = amounts[i];\\r\\n\\r\\n            uint256 fromBalance = es.balance[id][from];\\r\\n            require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\r\\n            unchecked {\\r\\n                es.balance[id][from] = fromBalance - amount;\\r\\n            }\\r\\n            es.balance[id][to] += amount;\\r\\n        }\\r\\n\\r\\n        emit TransferBatch(operator, from, to, ids, amounts);\\r\\n\\r\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     */\\r\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal {\\r\\n        require(owner != operator, \\\"ERC1155: setting approval status for self\\\");\\r\\n\\r\\n        LibERC1155.ERC1155Storage storage es = LibERC1155.erc1155Storage();\\r\\n        es.operatorApprovals[owner][operator] = approved;\\r\\n        emit ApprovalForAll(owner, operator, approved);\\r\\n    }\\r\\n\\r\\n    \\r\\n}\\r\\n\\r\\n\",\"keccak256\":\"0xbf776bb883cccddbaa660798a6e0f972c01864c9ee17fe9bf7ef3d0738a8da4f\"},\"contracts/facets/Tokens/ERC1155/libraries/LibERC1155.sol\":{\"content\":\"pragma solidity ^0.8.0;\\r\\n\\r\\nlibrary LibERC1155 {\\r\\n    bytes32 constant STORAGE_ERC1155 = \\\"diamond.storage.erc1155\\\";\\r\\n\\r\\n    struct ERC1155Storage {\\r\\n        // Mapping from token ID to account balances\\r\\n        mapping(uint256 => mapping(address => uint256)) balance;\\r\\n        // Mapping from account to operator approvals\\r\\n        mapping(address => mapping(address => bool)) operatorApprovals;\\r\\n        // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\r\\n        string uri;\\r\\n        uint256 totalSupply;\\r\\n    }\\r\\n\\r\\n    function erc1155Storage() internal pure returns (ERC1155Storage storage es_) {\\r\\n        bytes32 erc1155_key = STORAGE_ERC1155;\\r\\n        assembly {\\r\\n            es_.slot := erc1155_key\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getBalance(uint256 tokenId, address user) internal view returns (uint256 balance_) {\\r\\n        ERC1155Storage storage es = erc1155Storage();\\r\\n        balance_ = es.balance[tokenId][user];\\r\\n    }\\r\\n\\r\\n    function getOperatorApproval(address user, address operator) internal view returns (bool approved_) {\\r\\n        ERC1155Storage storage es = erc1155Storage();\\r\\n        approved_ = es.operatorApprovals[user][operator];\\r\\n    }\\r\\n    function _asSingletonArray(uint256 element) internal pure  returns (uint256[] memory) {\\r\\n        uint256[] memory array = new uint256[](1);\\r\\n        array[0] = element;\\r\\n\\r\\n        return array;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x2b0592f9db824744321e8eb08cfed2fb6f7ee07e0acd5d5daf3fc3e4c3318779\"},\"contracts/libraries/merkleVerify/MembersVerify.sol\":{\"content\":\"// pragma solidity ^0.8.6;\\r\\n\\r\\n// import \\\"../utils/MerkleProof.sol\\\";\\r\\n// import \\\"../LibMembers.sol\\\";\\r\\n\\r\\n\\r\\n// library MembersVerify {\\r\\n\\r\\n//     function verify(bytes32[] memory proof, address addr, uint256 amount) public view{\\r\\n//         LibMembers.MembersStorage storage ms = LibMembers.memberStorage();\\r\\n//         bytes32 root = ms.MembersMerkleRoot;\\r\\n//         // (2)\\r\\n//         bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(addr, amount))));\\r\\n//         // (3)\\r\\n//         require(MerkleProof.verify(proof, root, leaf), \\\"Invalid proof\\\");\\r\\n//         // (4)\\r\\n//         // ...\\r\\n//     }\\r\\n\\r\\n//     function multiProofVerify(bytes32[] memory proof, bool[] memory proofFlags, LibMembers.Leaf[] memory leaves) internal view {\\r\\n//         LibMembers.MembersStorage storage ms = LibMembers.memberStorage();\\r\\n//         bytes32 root = ms.MembersMerkleRoot;\\r\\n//         bytes32[] memory hashedLeaves = new bytes32[](leaves.length);\\r\\n//         for (uint32 i; i < leaves.length; i++) {\\r\\n//             bytes32 hashedLeaf = keccak256(\\r\\n//                 bytes.concat(keccak256(abi.encode(leaves[i].memberAddress, leaves[i].memberRank.timestamp, leaves[i].memberRank.rank)))\\r\\n//             );\\r\\n//             hashedLeaves[i] = hashedLeaf;\\r\\n//         }\\r\\n//         // (2)\\r\\n//         //bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(addr, amount))));\\r\\n//         // (3)\\r\\n//         require(MerkleProof.multiProofVerify(proof, proofFlags, root, hashedLeaves), \\\"Invalid Multiproof\\\");\\r\\n//         // (4)\\r\\n//         // ...\\r\\n//     }\\r\\n// }\\r\\n\",\"keccak256\":\"0xf18f30563f0bfe416e6a06a055f780208937ca8482c1aa0710b7cd7ed4d40820\"},\"contracts/libraries/utils/Address.sol\":{\"content\":\"library Address {\\r\\n\\r\\n    /**\\r\\n     * Returns whether the target address is a contract\\r\\n     * @dev This function will return false if invoked during the constructor of a contract,\\r\\n     * as the code is not actually created until after the constructor finishes.\\r\\n     * @param account address of the account to check\\r\\n     * @return whether the target address is a contract\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        uint256 size;\\r\\n        // XXX Currently there is no better way to check if there is a contract in an address\\r\\n        // than to check the size of the code at that address.\\r\\n        // See https://ethereum.stackexchange.com/a/14016/36603\\r\\n        // for more details about how this works.\\r\\n        // TODO Check this again before the Serenity release, because all addresses will be\\r\\n        // contracts then.\\r\\n        // solium-disable-next-line security/no-inline-assembly\\r\\n        assembly { size := extcodesize(account) }\\r\\n        return size > 0;\\r\\n    }\\r\\n\\r\\n}\",\"keccak256\":\"0x332f7fa5b7e5de602575ce60b90e9f003ef7b6c5f6440064deb33ecca39c04d0\"},\"contracts/libraries/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n    function msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xc0396a4816197ac7b903c3d4f8a5c9ea28e908c74cf9f48b89f51f55aa95bc36\",\"license\":\"MIT\"},\"contracts/libraries/utils/Incrementer.sol\":{\"content\":\"pragma solidity ^0.8.6;\\r\\n\\r\\nlibrary Incrementer {\\r\\n\\r\\n     function decrementKey(bytes28 self) internal pure returns( bytes28 ){\\r\\n        if( bytes8(self)  == bytes8(0) ) {\\r\\n            return self;\\r\\n        }\\r\\n        bytes8 decrementedIndex = bytes8( uint64( bytes8( self ) ) - 1 );\\r\\n        bytes28 decrementedKey = bytes28( abi.encodePacked(decrementedIndex, bytes20( self << 64) ) );\\r\\n        return decrementedKey ;\\r\\n    }\\r\\n    \\r\\n     function incrementKey(bytes28 self) internal pure returns( bytes28 ){\\r\\n        bytes8 decrementedIndex = bytes8( uint64( bytes8( self ) ) + 1 );\\r\\n        bytes28 decrementedKey = bytes28( abi.encodePacked(decrementedIndex, bytes20( self << 64) ) );\\r\\n        return decrementedKey ;\\r\\n    }\\r\\n    function decrementIndex(bytes8 self) internal returns( bytes8 decrementMaxIndex_ ){\\r\\n        decrementMaxIndex_ = bytes8( uint64( self ) - 1 );\\r\\n    }\\r\\n    function incrementIndex(bytes8 self) internal returns( bytes8 incrementMaxIndex_ ){\\r\\n        incrementMaxIndex_ = bytes8( uint64( self ) + 1 );\\r\\n    }\\r\\n}\",\"keccak256\":\"0xfef14fdef8f3de3f0ab8961bc9222df94f51ff451517768109c0cebcd165cd81\"}},\"version\":1}",
  "bytecode": "0x6080604052348015600e575f5ffd5b506108d48061001c5f395ff3fe608060405234801561000f575f5ffd5b5060043610610055575f3560e01c806359269e671461005957806359362078146100b55780637080a94c146100ca578063a091588c1461012d578063d6f74c4514610140575b5f5ffd5b61009b6100673660046106b1565b6001600160a01b03165f9081525f51602061087f5f395f51905f526020526040902054640100000000900463ffffffff1690565b60405163ffffffff90911681526020015b60405180910390f35b6100c86100c33660046106d1565b610153565b005b6101106100d83660046106b1565b6001600160a01b03165f9081525f51602061087f5f395f51905f52602052604090205463ffffffff6401000000008204811692911690565b6040805163ffffffff9384168152929091166020830152016100ac565b6100c861013b3660046107ce565b610161565b6100c861014e3660046106b1565b610171565b61015d8282610198565b5050565b61016c83838361029f565b505050565b61017961042c565b6001600160a01b031661018a610463565b50506101958161046c565b50565b6101a0610531565b5f51602061087f5f395f51905f525f5b82811015610299575f8484838181106101cb576101cb610850565b9050606002018036038101906101e19190610864565b604080518082018252828201805163ffffffff908116835260208086018051831682860190815287516001600160a01b039081165f9081528c855288902096518754925186166401000000000267ffffffffffffffff19909316908616179190911790955585518751909516855251821690840152905116918101919091529091507f60800807689785e0f531edc4af31b4d93d6169484ba759561f0650cdeaeaca0b9060600160405180910390a1506001016101b0565b50505050565b60208381015160408086015181516bffffffffffffffffffffffff193360601b16818601526001600160e01b031960e094851b811660348301529190931b1660388301528051808303601c018152603c909201905280519101207f46f9ff21a2b472f426fedec0a9a686a7aac5ea547036206278caba142b070cb0545f51602061087f5f395f51905f5291906103399085908590846105a2565b6103815760405162461bcd60e51b815260206004820152601460248201527324b73b30b634b21026b2b935b63290383937b7b360611b60448201526064015b60405180910390fd5b604080518082018252868201805163ffffffff90811683526020808a0180518316828601908152335f90815289845287902095518654915185166401000000000267ffffffffffffffff19909216908516171790945584518a516001600160a01b031681529351821690840152905116918101919091527f60800807689785e0f531edc4af31b4d93d6169484ba759561f0650cdeaeaca0b9060600160405180910390a15050505050565b5f61045e7fd00049dc7109015045860694acecd3dc33338404aaf6e55a1c98a2bf41477b85546001600160a01b031690565b905090565b5f61045e610644565b61047461042c565b6001600160a01b0316610485610463565b50505f61049c5f51602061087f5f395f51905f5290565b60408051808201825263ffffffff428181168084525f60208086018281526001600160a01b038b168084528983529288902096518754915187166401000000000267ffffffffffffffff1990921696169590951794909417909455935193845293945090917f951cf4b0cf410b98c391185a978142896782f9d4687093b9c616991976bc1108910160405180910390a2505050565b61053961042c565b6001600160a01b031661054a610463565b6001600160a01b0316146105a05760405162461bcd60e51b815260206004820152601b60248201527f4d757374206265207468652045636f73797374656d206f776e657200000000006044820152606401610378565b565b5f81815b85811015610638575f8787838181106105c1576105c1610850565b90506020020135905080831161060257604080516020810185905290810182905260600160405160208183030381529060405280519060200120925061062f565b60408051602081018390529081018490526060016040516020818303038152906040528051906020012092505b506001016105a6565b50909214949350505050565b5f6014361080159061067f57507f413a4c31c13c7c3de0c7da37be5d779b152baf3f21a1cb760fda41eb8ca97776546001600160a01b031633145b15610691575060131936013560601c90565b503390565b80356001600160a01b03811681146106ac575f5ffd5b919050565b5f602082840312156106c1575f5ffd5b6106ca82610696565b9392505050565b5f5f602083850312156106e2575f5ffd5b823567ffffffffffffffff8111156106f8575f5ffd5b8301601f81018513610708575f5ffd5b803567ffffffffffffffff81111561071e575f5ffd5b856020606083028401011115610732575f5ffd5b6020919091019590945092505050565b803563ffffffff811681146106ac575f5ffd5b5f60608284031215610765575f5ffd5b6040516060810181811067ffffffffffffffff8211171561079457634e487b7160e01b5f52604160045260245ffd5b6040529050806107a383610696565b81526107b160208401610742565b60208201526107c260408401610742565b60408201525092915050565b5f5f5f608084860312156107e0575f5ffd5b6107ea8585610755565b9250606084013567ffffffffffffffff811115610805575f5ffd5b8401601f81018613610815575f5ffd5b803567ffffffffffffffff81111561082b575f5ffd5b8660208260051b840101111561083f575f5ffd5b939660209190910195509293505050565b634e487b7160e01b5f52603260045260245ffd5b5f60608284031215610874575f5ffd5b6106ca838361075556fe46f9ff21a2b472f426fedec0a9a686a7aac5ea547036206278caba142b070cafa2646970667358221220b363f25db6c0237be12a64491494603dbcd3d2693ac0ddb2a88e356965673a6a64736f6c634300081c0033",
  "deployedBytecode": "0x608060405234801561000f575f5ffd5b5060043610610055575f3560e01c806359269e671461005957806359362078146100b55780637080a94c146100ca578063a091588c1461012d578063d6f74c4514610140575b5f5ffd5b61009b6100673660046106b1565b6001600160a01b03165f9081525f51602061087f5f395f51905f526020526040902054640100000000900463ffffffff1690565b60405163ffffffff90911681526020015b60405180910390f35b6100c86100c33660046106d1565b610153565b005b6101106100d83660046106b1565b6001600160a01b03165f9081525f51602061087f5f395f51905f52602052604090205463ffffffff6401000000008204811692911690565b6040805163ffffffff9384168152929091166020830152016100ac565b6100c861013b3660046107ce565b610161565b6100c861014e3660046106b1565b610171565b61015d8282610198565b5050565b61016c83838361029f565b505050565b61017961042c565b6001600160a01b031661018a610463565b50506101958161046c565b50565b6101a0610531565b5f51602061087f5f395f51905f525f5b82811015610299575f8484838181106101cb576101cb610850565b9050606002018036038101906101e19190610864565b604080518082018252828201805163ffffffff908116835260208086018051831682860190815287516001600160a01b039081165f9081528c855288902096518754925186166401000000000267ffffffffffffffff19909316908616179190911790955585518751909516855251821690840152905116918101919091529091507f60800807689785e0f531edc4af31b4d93d6169484ba759561f0650cdeaeaca0b9060600160405180910390a1506001016101b0565b50505050565b60208381015160408086015181516bffffffffffffffffffffffff193360601b16818601526001600160e01b031960e094851b811660348301529190931b1660388301528051808303601c018152603c909201905280519101207f46f9ff21a2b472f426fedec0a9a686a7aac5ea547036206278caba142b070cb0545f51602061087f5f395f51905f5291906103399085908590846105a2565b6103815760405162461bcd60e51b815260206004820152601460248201527324b73b30b634b21026b2b935b63290383937b7b360611b60448201526064015b60405180910390fd5b604080518082018252868201805163ffffffff90811683526020808a0180518316828601908152335f90815289845287902095518654915185166401000000000267ffffffffffffffff19909216908516171790945584518a516001600160a01b031681529351821690840152905116918101919091527f60800807689785e0f531edc4af31b4d93d6169484ba759561f0650cdeaeaca0b9060600160405180910390a15050505050565b5f61045e7fd00049dc7109015045860694acecd3dc33338404aaf6e55a1c98a2bf41477b85546001600160a01b031690565b905090565b5f61045e610644565b61047461042c565b6001600160a01b0316610485610463565b50505f61049c5f51602061087f5f395f51905f5290565b60408051808201825263ffffffff428181168084525f60208086018281526001600160a01b038b168084528983529288902096518754915187166401000000000267ffffffffffffffff1990921696169590951794909417909455935193845293945090917f951cf4b0cf410b98c391185a978142896782f9d4687093b9c616991976bc1108910160405180910390a2505050565b61053961042c565b6001600160a01b031661054a610463565b6001600160a01b0316146105a05760405162461bcd60e51b815260206004820152601b60248201527f4d757374206265207468652045636f73797374656d206f776e657200000000006044820152606401610378565b565b5f81815b85811015610638575f8787838181106105c1576105c1610850565b90506020020135905080831161060257604080516020810185905290810182905260600160405160208183030381529060405280519060200120925061062f565b60408051602081018390529081018490526060016040516020818303038152906040528051906020012092505b506001016105a6565b50909214949350505050565b5f6014361080159061067f57507f413a4c31c13c7c3de0c7da37be5d779b152baf3f21a1cb760fda41eb8ca97776546001600160a01b031633145b15610691575060131936013560601c90565b503390565b80356001600160a01b03811681146106ac575f5ffd5b919050565b5f602082840312156106c1575f5ffd5b6106ca82610696565b9392505050565b5f5f602083850312156106e2575f5ffd5b823567ffffffffffffffff8111156106f8575f5ffd5b8301601f81018513610708575f5ffd5b803567ffffffffffffffff81111561071e575f5ffd5b856020606083028401011115610732575f5ffd5b6020919091019590945092505050565b803563ffffffff811681146106ac575f5ffd5b5f60608284031215610765575f5ffd5b6040516060810181811067ffffffffffffffff8211171561079457634e487b7160e01b5f52604160045260245ffd5b6040529050806107a383610696565b81526107b160208401610742565b60208201526107c260408401610742565b60408201525092915050565b5f5f5f608084860312156107e0575f5ffd5b6107ea8585610755565b9250606084013567ffffffffffffffff811115610805575f5ffd5b8401601f81018613610815575f5ffd5b803567ffffffffffffffff81111561082b575f5ffd5b8660208260051b840101111561083f575f5ffd5b939660209190910195509293505050565b634e487b7160e01b5f52603260045260245ffd5b5f60608284031215610874575f5ffd5b6106ca838361075556fe46f9ff21a2b472f426fedec0a9a686a7aac5ea547036206278caba142b070cafa2646970667358221220b363f25db6c0237be12a64491494603dbcd3d2693ac0ddb2a88e356965673a6a64736f6c634300081c0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "banMember(address)": {
        "details": "Bans a user by setting their level to 0",
        "params": {
          "_user": "Address of the user to ban"
        }
      },
      "batchSetLevels((address,uint32,uint32)[])": {
        "details": "Batch set levels for multiple addresses (permissioned function)",
        "params": {
          "_leaves": "user resource denoting their membership status"
        }
      },
      "getMemberLevel(address)": {
        "details": "Returns the level info for a given address",
        "params": {
          "_user": "Address to query"
        }
      },
      "getMemberLevelStruct(address)": {
        "details": "Returns the level info for a given address",
        "params": {
          "_user": "Address to query"
        },
        "returns": {
          "level": "and timestamp of the user"
        }
      },
      "verifyAndSetLevel((address,uint32,uint32),bytes32[])": {
        "details": "Verifies Merkle proof and sets user's level",
        "params": {
          "_leaf": "Level to assign to the user",
          "_merkleProof": "Array of hashed data to verify proof"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}