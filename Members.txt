pragma solidity ^0.8.0;


interface IERC1155Transfer {


 /**
     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.
     *
     * Emits a {TransferSingle} event.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.
     * - `from` must have a balance of tokens of type `id` of at least `amount`.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
     * acceptance magic value.
     */
    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.
     *
     * Emits a {TransferBatch} event.
     *
     * Requirements:
     *
     * - `ids` and `amounts` must have the same length.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
     * acceptance magic value.
     */
    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata amounts,
        bytes calldata data
    ) external;

      /**
     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,
     *
     * Emits an {ApprovalForAll} event.
     *
     * Requirements:
     *
     * - `operator` cannot be the caller.
     */
    function setApprovalForAll(address operator, bool approved) external;

    /**
     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.
     *
     * See {setApprovalForAll}.
     */
    function isApprovedForAll(address account, address operator) external view returns (bool);

}

// LibEventStorage.sol
library LibEventFactoryStorage {
    bytes32 constant STORAGE_POSITION = keccak256("diamond.storage.EventFactory");

    struct TicketDetail {
        uint256 minAmount;
        uint256 maxAmount;
    }

    enum EventStatus {
        Pending,
        Active,
        Deactivated,
        Completed
    }

    struct EventDetail {
        uint32 startTime;
        uint32 endTime;
        uint256 minEntries;
        uint256 maxEntries;
        uint256 currentEntries;
        string imageUri;
        EventStatus status;
        bytes32 merkleRoot;
        mapping(uint256 => TicketDetail) ticketDetails;
        mapping(address => mapping(uint256 => uint256)) ticketsRedeemed;
    }

    struct EventStorage {
        address owner;
        IERC1155Transfer tokenContract;
        mapping(uint256 => EventDetail) events;
    }

    function eventStorage() internal pure returns (EventStorage storage es) {
        bytes32 position = STORAGE_POSITION;
        assembly {
            es.slot := position
        }
    }

    function getEventDetail(uint256 eventId) internal view returns (EventDetail storage) {
        EventStorage storage es = eventStorage();
        require(es.events[eventId].startTime != 0, "Event does not exist");
        return es.events[eventId];
    }

    function getTicketDetail(uint256 eventId, uint256 ticketId) internal view returns (TicketDetail storage) {
        return getEventDetail(eventId).ticketDetails[ticketId];
    }

    function getRedeemedTickets(uint256 eventId, address user, uint256[] memory ticketId) internal view returns (uint256[] memory) {
        uint256[] memory redeemedTickets = new uint256[](ticketId.length);
        for (uint256 i; i < ticketId.length; i++) {
            redeemedTickets[i] = getEventDetail(eventId).ticketsRedeemed[user][ticketId[i]];
        }
    }

    function getMerkleRoot(uint256 eventId) internal view returns (bytes32) {
        return getEventDetail(eventId).merkleRoot;
    }

    function getEventTimes(uint256 eventId) internal view returns (uint32 startTime, uint32 endTime) {
        EventDetail storage es = getEventDetail(eventId);
        return (es.startTime, es.endTime);
    }

    function getEventEntries(uint256 eventId) internal view returns (uint256 minEntries, uint256 maxEntries, uint256 currentEntries) {
        EventDetail storage es = getEventDetail(eventId);
        return (es.minEntries, es.maxEntries, es.currentEntries);
    }

    function getEventImageUri(uint256 eventId) internal view returns (string memory) {
        EventDetail storage es = getEventDetail(eventId);
        return es.imageUri;
    }

    function getEventStatus(uint256 eventId) internal view returns (EventStatus) {
        EventDetail storage es = getEventDetail(eventId);
        return es.status;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)
/**
 * @dev These functions deal with verification of Merkle Tree proofs.
 *
 * The tree and the proofs can be generated using our
 * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].
 * You will find a quickstart guide in the readme.
 *
 * WARNING: You should avoid using leaf values that are 64 bytes long prior to
 * hashing, or use a hash function other than keccak256 for hashing leaves.
 * This is because the concatenation of a sorted pair of internal nodes in
 * the merkle tree could be reinterpreted as a leaf value.
 * OpenZeppelin's JavaScript library generates merkle trees that are safe
 * against this attack out of the box.
 */
library MerkleProof {
    /**
     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree
     * defined by `root`. For this, a `proof` must be provided, containing
     * sibling hashes on the branch from the leaf to the root of the tree. Each
     * pair of leaves and each pair of pre-images are assumed to be sorted.
     */
    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {
        return processProof(proof, leaf) == root;
    }

    /**
     * @dev Calldata version of {verify}
     *
     * _Available since v4.7._
     */
    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {
        return processProofCalldata(proof, leaf) == root;
    }

    /**
     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up
     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt
     * hash matches the root of the tree. When processing the proof, the pairs
     * of leafs & pre-images are assumed to be sorted.
     *
     * _Available since v4.4._
     */
    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {
        bytes32 computedHash = leaf;
        for (uint256 i = 0; i < proof.length; i++) {
            computedHash = _hashPair(computedHash, proof[i]);
        }
        return computedHash;
    }

    /**
     * @dev Calldata version of {processProof}
     *
     * _Available since v4.7._
     */
    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {
        bytes32 computedHash = leaf;
        for (uint256 i = 0; i < proof.length; i++) {
            computedHash = _hashPair(computedHash, proof[i]);
        }
        return computedHash;
    }

    /**
     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by
     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.
     *
     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.
     *
     * _Available since v4.7._
     */
    function multiProofVerify(
        bytes32[] memory proof,
        bool[] memory proofFlags,
        bytes32 root,
        bytes32[] memory leaves
    ) internal pure returns (bool) {
        return processMultiProof(proof, proofFlags, leaves) == root;
    }

    /**
     * @dev Calldata version of {multiProofVerify}
     *
     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.
     *
     * _Available since v4.7._
     */
    function multiProofVerifyCalldata(
        bytes32[] calldata proof,
        bool[] calldata proofFlags,
        bytes32 root,
        bytes32[] memory leaves
    ) internal pure returns (bool) {
        return processMultiProofCalldata(proof, proofFlags, leaves) == root;
    }

    /**
     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction
     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another
     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false
     * respectively.
     *
     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree
     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the
     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).
     *
     * _Available since v4.7._
     */
    function processMultiProof(
        bytes32[] memory proof,
        bool[] memory proofFlags,
        bytes32[] memory leaves
    ) internal pure returns (bytes32 merkleRoot) {
        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by
        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the
        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of
        // the merkle tree.
        uint256 leavesLen = leaves.length;
        uint256 totalHashes = proofFlags.length;

        // Check proof validity.
        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");

        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using
        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's "pop".
        bytes32[] memory hashes = new bytes32[](totalHashes);
        uint256 leafPos = 0;
        uint256 hashPos = 0;
        uint256 proofPos = 0;
        // At each step, we compute the next hash using two values:
        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we
        //   get the next hash.
        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the
        //   `proof` array.
        for (uint256 i = 0; i < totalHashes; i++) {
            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];
            bytes32 b = proofFlags[i]
                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])
                : proof[proofPos++];
            hashes[i] = _hashPair(a, b);
        }

        if (totalHashes > 0) {
            unchecked {
                return hashes[totalHashes - 1];
            }
        } else if (leavesLen > 0) {
            return leaves[0];
        } else {
            return proof[0];
        }
    }

    /**
     * @dev Calldata version of {processMultiProof}.
     *
     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.
     *
     * _Available since v4.7._
     */
    function processMultiProofCalldata(
        bytes32[] calldata proof,
        bool[] calldata proofFlags,
        bytes32[] memory leaves
    ) internal pure returns (bytes32 merkleRoot) {
        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by
        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the
        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of
        // the merkle tree.
        uint256 leavesLen = leaves.length;
        uint256 totalHashes = proofFlags.length;

        // Check proof validity.
        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");

        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using
        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's "pop".
        bytes32[] memory hashes = new bytes32[](totalHashes);
        uint256 leafPos = 0;
        uint256 hashPos = 0;
        uint256 proofPos = 0;
        // At each step, we compute the next hash using two values:
        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we
        //   get the next hash.
        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the
        //   `proof` array.
        for (uint256 i = 0; i < totalHashes; i++) {
            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];
            bytes32 b = proofFlags[i]
                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])
                : proof[proofPos++];
            hashes[i] = _hashPair(a, b);
        }

        if (totalHashes > 0) {
            unchecked {
                return hashes[totalHashes - 1];
            }
        } else if (leavesLen > 0) {
            return leaves[0];
        } else {
            return proof[0];
        }
    }

    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {
        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);
    }

    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {
        /// @solidity memory-safe-assembly
        assembly {
            mstore(0x00, a)
            mstore(0x20, b)
            value := keccak256(0x00, 0x40)
        }
    }
}

interface IDiamondCut {
    enum FacetCutAction {Add, Replace, Remove}
    // Add=0, Replace=1, Remove=2

    struct FacetCut {
        address facetAddress;
        FacetCutAction action;
        bytes4[] functionSelectors;
    }

    /// @notice Add/replace/remove any number of functions and optionally execute
    ///         a function with delegatecall
    /// @param _diamondCut Contains the facet addresses and function selectors
    /// @param _init The address of the contract or facet to execute _calldata
    /// @param _calldata A function call, including function selector and arguments
    ///                  _calldata is executed with delegatecall on _init
    function diamondCut(
        FacetCut[] calldata _diamondCut,
        address _init,
        bytes calldata _calldata
    ) external;

    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);
}

library LibDiamond {
    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256("diamond.standard.diamond.storage");

    struct FacetAddressAndPosition {
        address facetAddress;
        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array
    }

    struct FacetFunctionSelectors {
        bytes4[] functionSelectors;
        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array
    }

    struct DiamondStorage {
        // maps function selector to the facet address and
        // the position of the selector in the facetFunctionSelectors.selectors array
        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;
        // maps facet addresses to function selectors
        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;
        // facet addresses
        address[] facetAddresses;
        // Used to query if a contract implements an interface.
        // Used to implement ERC-165.
        mapping(bytes4 => bool) supportedInterfaces;
        // owner of the contract
        address contractOwner;
    }

    function diamondStorage() internal pure returns (DiamondStorage storage ds) {
        bytes32 position = DIAMOND_STORAGE_POSITION;
        assembly {
            ds.slot := position
        }
    }

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    function setContractOwner(address _newOwner) internal {
        DiamondStorage storage ds = diamondStorage();
        address previousOwner = ds.contractOwner;
        ds.contractOwner = _newOwner;
        emit OwnershipTransferred(previousOwner, _newOwner);
    }

    function contractOwner() internal view returns (address contractOwner_) {
        contractOwner_ = diamondStorage().contractOwner;
    }

    function enforceIsContractOwner() internal view {
        require(msg.sender == diamondStorage().contractOwner, "LibDiamond: Must be contract owner");
    }

    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);

    // Internal function version of diamondCut
    function diamondCut(
        IDiamondCut.FacetCut[] memory _diamondCut,
        address _init,
        bytes memory _calldata
    ) internal {
        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {
            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;
            if (action == IDiamondCut.FacetCutAction.Add) {
                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);
            } else if (action == IDiamondCut.FacetCutAction.Replace) {
                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);
            } else if (action == IDiamondCut.FacetCutAction.Remove) {
                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);
            } else {
                revert("LibDiamondCut: Incorrect FacetCutAction");
            }
        }
        emit DiamondCut(_diamondCut, _init, _calldata);
        initializeDiamondCut(_init, _calldata);
    }

    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {

        require(_functionSelectors.length > 0, "LibDiamondCut: No selectors in facet to cut");
        DiamondStorage storage ds = diamondStorage();        
        require(_facetAddress != address(0), "LibDiamondCut: Add facet can't be address(0)");
        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);
        // add new facet address if it does not exist
        if (selectorPosition == 0) {
            addFacet(ds, _facetAddress);            
        }
        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {
            bytes4 selector = _functionSelectors[selectorIndex];
            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;
            require(oldFacetAddress == address(0), "LibDiamondCut: Can't add function that already exists");
            addFunction(ds, selector, selectorPosition, _facetAddress);
            selectorPosition++;
        }
    }

    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {
        require(_functionSelectors.length > 0, "LibDiamondCut: No selectors in facet to cut");
        DiamondStorage storage ds = diamondStorage();
        require(_facetAddress != address(0), "LibDiamondCut: Add facet can't be address(0)");
        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);
        // add new facet address if it does not exist
        if (selectorPosition == 0) {
            addFacet(ds, _facetAddress);
        }
        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {
            bytes4 selector = _functionSelectors[selectorIndex];
            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;
            require(oldFacetAddress != _facetAddress, "LibDiamondCut: Can't replace function with same function");
            removeFunction(ds, oldFacetAddress, selector);
            addFunction(ds, selector, selectorPosition, _facetAddress);
            selectorPosition++;
        }
    }

    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {
        require(_functionSelectors.length > 0, "LibDiamondCut: No selectors in facet to cut");
        DiamondStorage storage ds = diamondStorage();
        // if function does not exist then do nothing and return
        require(_facetAddress == address(0), "LibDiamondCut: Remove facet address must be address(0)");
        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {
            bytes4 selector = _functionSelectors[selectorIndex];
            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;
            removeFunction(ds, oldFacetAddress, selector);
        }
    }

    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {
        enforceHasContractCode(_facetAddress, "LibDiamondCut: New facet has no code");
        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;
        ds.facetAddresses.push(_facetAddress);
    }    


    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {
        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;
        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);
        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;
    }

    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        
        require(_facetAddress != address(0), "LibDiamondCut: Can't remove function that doesn't exist");
        // an immutable function is a function defined directly in a diamond
        require(_facetAddress != address(this), "LibDiamondCut: Can't remove immutable function");
        // replace selector with last selector, then delete last selector
        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;
        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;
        // if not the same then replace _selector with lastSelector
        if (selectorPosition != lastSelectorPosition) {
            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];
            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;
            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);
        }
        // delete the last selector
        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();
        delete ds.selectorToFacetAndPosition[_selector];

        // if no more selectors for facet address then delete the facet address
        if (lastSelectorPosition == 0) {
            // replace facet address with last facet address and delete last facet address
            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;
            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;
            if (facetAddressPosition != lastFacetAddressPosition) {
                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];
                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;
                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;
            }
            ds.facetAddresses.pop();
            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;
        }
    }

    function initializeDiamondCut(address _init, bytes memory _calldata) internal {
        if (_init == address(0)) {
            return;
        }
        enforceHasContractCode(_init, "LibDiamondCut: _init address has no code");        
        (bool success, bytes memory error) = _init.delegatecall(_calldata);
        if (!success) {
            if (error.length > 0) {
                // bubble up error
                /// @solidity memory-safe-assembly
                assembly {
                    let returndata_size := mload(error)
                    revert(add(32, error), returndata_size)
                }
            } else {
                revert InitializationFunctionReverted(_init, _calldata);
            }
        }
    }

    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {
        uint256 contractSize;
        assembly {
            contractSize := extcodesize(_contract)
        }
        require(contractSize > 0, _errorMessage);
    }
    
}

// SPDX-License-Identifier: MIT
contract iOwnership {
    function _transferOwnership(address _newOwner) internal  {
        LibDiamond.enforceIsContractOwner();
        LibDiamond.setContractOwner(_newOwner);
    }

    function _owner() internal view returns (address owner_) {
        owner_ = LibDiamond.contractOwner();
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }
    function msgSender() internal view virtual returns (address) {
        return msg.sender;
    }
    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

// SPDX-License-Identifier: MIT
contract iEventFactory is iOwnership, Context {
    IERC1155Transfer public tokenContract;

    /// @dev Emitted when an event is deactivated by the owner.
    /// @param eventId The unique identifier for the event.
    event EventDeactivated(uint256 eventId);

    /// @dev Emitted when an event transitions from a pending state to an active state, which generally happens when the first ticket for the event is redeemed.
    /// @param eventId The unique identifier for the event.
    event EventActivated(uint256 eventId);

    /// @dev Emitted when one or more tickets are redeemed for an event. Contains details of the ticket IDs and the respective amounts that have been redeemed.
    /// @param eventId The unique identifier for the event.
    /// @param ticketIds An array of unique identifiers for the tickets that have been redeemed.
    /// @param amounts An array of amounts representing the quantity redeemed for each corresponding ticket ID.
    event TicketRedeemed(uint256 eventId, uint256[] ticketIds, uint256[] amounts);

    /// @dev Emitted when a ticket is refunded. This occurs after a successful call to the `refundTicketsWithProof` function, indicating that the refund was processed successfully.
    /// @param eventId The unique identifier for the event.
    /// @param ticketId The unique identifier for the ticket that has been refunded.
    /// @param amount The amount that has been refunded for the particular ticket id.
    event TicketRefunded(uint256 eventId, uint256 ticketId, uint256 amount);

    /// @dev Emitted when a new event is created. Contains all the essential details regarding the event including its schedule and entry conditions.
    /// @param eventId The unique identifier for the event.
    /// @param startTime The start time of the event, represented as a UNIX timestamp.
    /// @param endTime The end time of the event, represented as a UNIX timestamp.
    /// @param minEntries The minimum number of entries required for the event.
    /// @param maxEntries The maximum number of entries allowed for the event.
    /// @param imageUri A URI pointing to the event's image resource.
    /// @param status The current status of the event.
    event EventDetails(
        uint256 eventId,
        uint32 startTime,
        uint32 endTime,
        uint256 minEntries,
        uint256 maxEntries,
        string imageUri,
        LibEventFactoryStorage.EventStatus status
    );

    /// @dev Emitted when ticket details for a specific event are defined or updated. Contains arrays of ticket IDs and their corresponding details.
    /// @param eventId The unique identifier for the event.
    /// @param ticketIds An array of unique identifiers for the tickets associated with the event.
    /// @param ticketDetails An array of structures holding details for each ticket corresponding to the IDs in the `ticketIds` parameter.
    event TicketDetails(uint256 eventId, uint256[] ticketIds, LibEventFactoryStorage.TicketDetail[] ticketDetails);
    /**
     * @dev Emitted when an event's duration is extended
     * @param eventId The unique identifier for the event.
     * @param addedTime Time added to the endTime property of the event
     */
    event EventExtended(uint256 eventId, uint32 addedTime);

    event ImageUriUpdated(uint256 eventId, string imageUri);
    event RefundsEnabled(uint256 eventId, bytes32 merkleRoot);

    constructor(address _tokenContract) {
        tokenContract = IERC1155Transfer(_tokenContract);
    }

    modifier onlyOwner() {
        require(msg.sender == _owner(), "Not owner");
        _;
    }

    function _extendEvent(uint256 eventId, uint32 addedTime) internal {
        LibEventFactoryStorage.EventDetail storage eventDetail = LibEventFactoryStorage.getEventDetail(eventId);
        eventDetail.endTime += addedTime;
        emit EventExtended(eventId, addedTime);
    }

    function _deactivateEvent(uint256 eventId, bytes32 root) internal onlyOwner {
        LibEventFactoryStorage.EventDetail storage eventDetail = LibEventFactoryStorage.getEventDetail(eventId);

        require(
            eventDetail.status == LibEventFactoryStorage.EventStatus.Active || eventDetail.status == LibEventFactoryStorage.EventStatus.Pending,
            "Event has already terminated"
        );

        eventDetail.status = LibEventFactoryStorage.EventStatus.Deactivated;
        emit EventDeactivated(eventId);

        if (root != bytes32(0)) {
            eventDetail.merkleRoot = root;
        }
    }

    function _setMerkleRoot(uint256 eventId, bytes32 root) internal {
        LibEventFactoryStorage.EventDetail storage eventDetail = LibEventFactoryStorage.getEventDetail(eventId);
        LibEventFactoryStorage.EventStatus _eventStatus = eventDetail.status;
        require(
            _eventStatus == LibEventFactoryStorage.EventStatus.Deactivated || _eventStatus == LibEventFactoryStorage.EventStatus.Completed,
            "Event must be finished."
        );

        bytes32 _merkleRoot = eventDetail.merkleRoot;
        require(_merkleRoot == bytes32(0), "Merkle root has already been set for this event.");
        eventDetail.merkleRoot = root;
        emit RefundsEnabled(eventId, _merkleRoot);
    }

    function _setImageUri(uint256 eventId, string memory imageUri) internal {
        LibEventFactoryStorage.EventDetail storage eventDetail = LibEventFactoryStorage.getEventDetail(eventId);
        require(eventDetail.endTime != 0, "Event does not exist");
        eventDetail.imageUri = imageUri;
        emit ImageUriUpdated(eventId, imageUri);
    }

    // Additional functions such as `_redeemTickets`, `_refundTicketsWithProof`, and `_createEvent` would be implemented here following the existing logic, but leveraging the `LibEventFactoryStorage` library to interact with storage.

    // Assuming the necessary imports and library setup are done at the top of your file

    function _createEvent(
        uint32 _startTime,
        uint32 _endTime,
        uint256 _minEntries,
        uint256 _maxEntries,
        string memory _imageUri,
        uint256[] memory _ticketIds,
        LibEventFactoryStorage.TicketDetail[] memory _ticketDetails
    ) internal returns (uint256) {
        LibEventFactoryStorage.EventStorage storage es = LibEventFactoryStorage.eventStorage();

        require(_ticketIds.length == _ticketDetails.length, "Must be same length.");
        require(_endTime > block.timestamp - 1, "Must be non-trivial event time window");

        uint256 eventId = uint256(keccak256(abi.encodePacked(_startTime, _endTime, _minEntries, _maxEntries, _imageUri, block.timestamp)));
        require(es.events[eventId].endTime == 0, "Event must not exist");
        LibEventFactoryStorage.EventDetail storage newEvent = es.events[eventId];
        newEvent.startTime = _startTime;
        newEvent.endTime = _endTime;
        newEvent.minEntries = _minEntries;
        newEvent.maxEntries = _maxEntries;
        newEvent.imageUri = _imageUri;
        newEvent.status = uint32(block.timestamp) < _startTime
            ? LibEventFactoryStorage.EventStatus.Pending
            : LibEventFactoryStorage.EventStatus.Active;

        emit EventDetails(eventId, _startTime, _endTime, _minEntries, _maxEntries, _imageUri, newEvent.status);

        for (uint256 i = 0; i < _ticketIds.length; i++) {
            require(_ticketDetails[i].maxAmount != 0, "Must have non-trivial maximum ticket amount");
            newEvent.ticketDetails[_ticketIds[i]] = _ticketDetails[i];
        }

        emit TicketDetails(eventId, _ticketIds, _ticketDetails);

        return eventId;
    }

    function _redeemTickets(uint256 eventId, uint256[] memory ticketIds, uint256[] memory amounts) internal {
        LibEventFactoryStorage.EventDetail storage eventDetail = LibEventFactoryStorage.getEventDetail(eventId);
        LibEventFactoryStorage.EventStatus _status = eventDetail.status;

        require(block.timestamp >= eventDetail.startTime && block.timestamp <= eventDetail.endTime, "Event not active");
        require(ticketIds.length == amounts.length, "Mismatched ticketIds and amounts lengths");

        if (_status == LibEventFactoryStorage.EventStatus.Pending) {
            eventDetail.status = LibEventFactoryStorage.EventStatus.Active;
            emit EventActivated(eventId);
        }

        for (uint i = 0; i < ticketIds.length; i++) {
            LibEventFactoryStorage.TicketDetail storage ticketDetail = LibEventFactoryStorage.getTicketDetail(eventId, ticketIds[i]);
            require(eventDetail.currentEntries + 1 <= eventDetail.maxEntries, "Exceeding max entries");
            require(amounts[i] >= ticketDetail.minAmount && amounts[i] <= ticketDetail.maxAmount, "Invalid ticket amount");

            // Transfer ERC1155 tokens from user to contract
            tokenContract.safeTransferFrom(msgSender(), address(this), ticketIds[i], amounts[i], "");

            // Update event and ticket details
            eventDetail.currentEntries += 1;
            eventDetail.ticketsRedeemed[msgSender()][ticketIds[i]] += amounts[i];
        }
        emit TicketRedeemed(eventId, ticketIds, amounts);
    }

    function _refundTicketsWithProof(
        uint256 eventId,
        uint256[] memory ticketIds,
        address lowerBound,
        address upperBound,
        bytes32[] calldata merkleProof
    ) internal {
        LibEventFactoryStorage.EventDetail storage eventDetail = LibEventFactoryStorage.getEventDetail(eventId);

        require(validateNonInclusion(eventId, lowerBound, upperBound, merkleProof), "User was honored or proof is incorrect");

        for (uint i = 0; i < ticketIds.length; i++) {
            uint256 amountToRefund = eventDetail.ticketsRedeemed[msgSender()][ticketIds[i]];
            require(amountToRefund > 0, "No tickets to refund for this ID");

            // Update event details before transfer to ensure state consistency
            eventDetail.currentEntries -= 1;
            eventDetail.ticketsRedeemed[msgSender()][ticketIds[i]] = 0;

            // Transfer ERC1155 tokens back to the user
            tokenContract.safeTransferFrom(address(this), msgSender(), ticketIds[i], amountToRefund, "");
            emit TicketRefunded(eventId, ticketIds[i], amountToRefund);
        }
    }

    function validateNonInclusion(
        uint256 eventId,
        address lowerBound,
        address upperBound,
        bytes32[] calldata merkleProof
    ) internal view returns (bool) {
        LibEventFactoryStorage.EventStorage storage es = LibEventFactoryStorage.eventStorage();
        LibEventFactoryStorage.EventDetail storage eventDetail = LibEventFactoryStorage.getEventDetail(eventId);

        // Ensure sender is within bounds
        require(
            uint160(lowerBound) < uint160(msgSender()) && uint160(msgSender()) < uint160(upperBound),
            "Sender is not within the exclusive bounds"
        );

        // Verify non-inclusion proof
        bytes32 leaf = keccak256(abi.encodePacked(lowerBound, upperBound));
        return !MerkleProof.verify(merkleProof, eventDetail.merkleRoot, leaf);
    }
}

// SPDX-License-Identifier: MIT
contract EventFactory is iEventFactory {
    constructor(address erc1155Address) iEventFactory(erc1155Address){}
     function setMerkleRoot(uint256 eventId, bytes32 root) external onlyOwner {
        _setMerkleRoot(eventId, root);
    }
    function setImageUri(uint256 eventId, string memory imageUri) external onlyOwner {
        _setImageUri(eventId, imageUri);
    }
    function createEvent(
        uint32 _startTime,
        uint32 _endTime,
        uint256 _minEntries,
        uint256 _maxEntries,
        string calldata _imageUri,
        uint256[] memory _ticketIds,
        LibEventFactoryStorage.TicketDetail[] memory _ticketDetails
    ) external returns (uint256) {
       return _createEvent(_startTime, _endTime, _minEntries, _maxEntries, _imageUri, _ticketIds, _ticketDetails);
    }
     function deactivateEvent(uint256 eventId, bytes32 root) external {
        _deactivateEvent(eventId, root);
     }

    function extendEvent(uint256 eventId, uint32 addedTime) external {
        _extendEvent(eventId, addedTime);
    }

    function redeemTickets(uint256 eventId, uint256[] calldata ticketIds, uint256[] calldata amounts) external {
        _redeemTickets(eventId, ticketIds, amounts);
    }


    function refundTicketsWithProof(
        uint256 eventId, 
        uint256[] memory ticketIds, 
        address lowerBound, 
        address upperBound, 
        bytes32[] calldata merkleProof
    ) external  {
        _refundTicketsWithProof(eventId, ticketIds, lowerBound, upperBound, merkleProof);
    }
}